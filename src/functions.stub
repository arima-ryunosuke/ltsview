<?php
# Don't touch this code. This is auto generated.
namespace ryunosuke\ltsv;

if (!defined('ryunosuke\\ltsv\\IS_OWNSELF')) {
    define('ryunosuke\\ltsv\\IS_OWNSELF', 2);
}

if (!defined('ryunosuke\\ltsv\\IS_PUBLIC')) {
    define('ryunosuke\\ltsv\\IS_PUBLIC', 4);
}

if (!defined('ryunosuke\\ltsv\\IS_PROTECTED')) {
    define('ryunosuke\\ltsv\\IS_PROTECTED', 8);
}

if (!defined('ryunosuke\\ltsv\\IS_PRIVATE')) {
    define('ryunosuke\\ltsv\\IS_PRIVATE', 16);
}

if (!defined('ryunosuke\\ltsv\\EN_MONTH_SHORT')) {
    define('ryunosuke\\ltsv\\EN_MONTH_SHORT', [
        1  => "jan",
        2  => "feb",
        3  => "mar",
        4  => "apr",
        5  => "may",
        6  => "jun",
        7  => "jul",
        8  => "aug",
        9  => "sep",
        10 => "oct",
        11 => "nov",
        12 => "dec",
    ]);
}

if (!defined('ryunosuke\\ltsv\\EN_MONTH_LONG')) {
    define('ryunosuke\\ltsv\\EN_MONTH_LONG', [
        1  => "january",
        2  => "february",
        3  => "march",
        4  => "april",
        5  => "may",
        6  => "june",
        7  => "july",
        8  => "august",
        9  => "september",
        10 => "october",
        11 => "november",
        12 => "december",
    ]);
}

if (!defined('ryunosuke\\ltsv\\JP_ERA')) {
    define('ryunosuke\\ltsv\\JP_ERA', [
        [
            "name"  => "令和",
            "abbr"  => "R",
            "since" => 1556636400,
        ],
        [
            "name"  => "平成",
            "abbr"  => "H",
            "since" => 600188400,
        ],
        [
            "name"  => "昭和",
            "abbr"  => "S",
            "since" => -1357635600,
        ],
        [
            "name"  => "大正",
            "abbr"  => "T",
            "since" => -1812186000,
        ],
        [
            "name"  => "明治",
            "abbr"  => "M",
            "since" => -3216790800,
        ],
    ]);
}

if (!defined('ryunosuke\\ltsv\\GENERAL_MIMETYPE')) {
    define('ryunosuke\\ltsv\\GENERAL_MIMETYPE', [
        "csv"   => "text/csv",
        "dcm"   => "application/dicom",
        "dvc"   => "application/dvcs",
        "finf"  => "application/fastinfoset",
        "stk"   => "application/hyperstudio",
        "ipfix" => "application/ipfix",
        "json"  => "application/json",
        "mrc"   => "application/marc",
        "nb"    => "application/mathematica",
        "ma"    => "application/mathematica",
        "mb"    => "application/mathematica",
        "mbox"  => "application/mbox",
        "m21"   => "application/mp21",
        "mp21"  => "application/mp21",
        "xls"   => "application/vnd.ms-excel",
        "doc"   => "application/vnd.ms-word",
        "mxf"   => "application/mxf",
        "oda"   => "application/oda",
        "ogx"   => "application/ogg",
        "pdf"   => "application/pdf",
        "p10"   => "application/pkcs10",
        "ai"    => "application/postscript",
        "eps"   => "application/postscript",
        "ps"    => "application/postscript",
        "rtf"   => "application/rtf",
        "sdp"   => "application/sdp",
        "siv"   => "application/sieve",
        "sieve" => "application/sieve",
        "smil"  => "application/smil",
        "smi"   => "application/smil",
        "sml"   => "application/smil",
        "gram"  => "application/srgs",
        "xml"   => "text/xml",
        "zip"   => "application/x-zip-compressed",
        "xlsx"  => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "docx"  => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        726     => "audio/32kadpcm",
        "amr"   => "audio/AMR",
        "at3"   => "audio/ATRAC3",
        "aa3"   => "audio/ATRAC3",
        "omg"   => "audio/ATRAC3",
        "evc"   => "audio/EVRC",
        "evb"   => "audio/EVRCB",
        "evw"   => "audio/EVRCWB",
        "l16"   => "audio/L16",
        "smv"   => "audio/SMV",
        "ac3"   => "audio/ac3",
        "au"    => "audio/basic",
        "snd"   => "audio/basic",
        "dls"   => "audio/dls",
        "lbc"   => "audio/iLBC",
        "mid"   => "audio/midi",
        "midi"  => "audio/midi",
        "kar"   => "audio/midi",
        "mpga"  => "audio/mpeg",
        "mp1"   => "audio/mpeg",
        "mp2"   => "audio/mpeg",
        "mp3"   => "audio/mpeg",
        "oga"   => "audio/ogg",
        "ogg"   => "audio/ogg",
        "spx"   => "audio/ogg",
        "qcp"   => "audio/qcelp",
        "bmp"   => "image/bmp",
        "fits"  => "image/fits",
        "fit"   => "image/fits",
        "fts"   => "image/fits",
        "gif"   => "image/gif",
        "ief"   => "image/ief",
        "jp2"   => "image/jp2",
        "jpg2"  => "image/jp2",
        "jpeg"  => "image/jpeg",
        "jpg"   => "image/jpeg",
        "jpe"   => "image/jpeg",
        "jfif"  => "image/jpeg",
        "jpm"   => "image/jpm",
        "jpgm"  => "image/jpm",
        "jpx"   => "image/jpx",
        "jpf"   => "image/jpx",
        "svg"   => "image/svg+xml",
        "png"   => "image/png",
        "t38"   => "image/t38",
        "tiff"  => "image/tiff",
        "tif"   => "image/tiff",
        "u8msg" => "message/global",
        "eml"   => "message/rfc822",
        "mail"  => "message/rfc822",
        "art"   => "message/rfc822",
        "igs"   => "model/iges",
        "iges"  => "model/iges",
        "msh"   => "model/mesh",
        "mesh"  => "model/mesh",
        "silo"  => "model/mesh",
        "wrl"   => "model/vrml",
        "vrml"  => "model/vrml",
        "ics"   => "text/calendar",
        "ifb"   => "text/calendar",
        "css"   => "text/css",
        "soa"   => "text/dns",
        "zone"  => "text/dns",
        "html"  => "text/html",
        "htm"   => "text/html",
        "js"    => "text/javascript",
        "asc"   => "text/plain",
        "txt"   => "text/plain",
        "text"  => "text/plain",
        "pm"    => "text/plain",
        "el"    => "text/plain",
        "c"     => "text/plain",
        "h"     => "text/plain",
        "cc"    => "text/plain",
        "hh"    => "text/plain",
        "cxx"   => "text/plain",
        "hxx"   => "text/plain",
        "f90"   => "text/plain",
        "rtx"   => "text/richtext",
        "sgml"  => "text/sgml",
        "sgm"   => "text/sgml",
        "3gp"   => "video/3gpp",
        "3gpp"  => "video/3gpp",
        "3g2"   => "video/3gpp2",
        "3gpp2" => "video/3gpp2",
        "mj2"   => "video/mj2",
        "mjp2"  => "video/mj2",
        "mp4"   => "video/mp4",
        "mpg4"  => "video/mp4",
        "mpeg"  => "video/mpeg",
        "mpg"   => "video/mpeg",
        "mpe"   => "video/mpeg",
        "ogv"   => "video/ogg",
        "qt"    => "video/quicktime",
        "mov"   => "video/quicktime",
        "webm"  => "video/webm",
    ]);
}

if (!defined('ryunosuke\\ltsv\\GLOB_RECURSIVE')) {
    define('ryunosuke\\ltsv\\GLOB_RECURSIVE', 65536);
}

if (!defined('ryunosuke\\ltsv\\JSON_MAX_DEPTH')) {
    define('ryunosuke\\ltsv\\JSON_MAX_DEPTH', -1);
}

if (!defined('ryunosuke\\ltsv\\JSON_INDENT')) {
    define('ryunosuke\\ltsv\\JSON_INDENT', -71);
}

if (!defined('ryunosuke\\ltsv\\JSON_CLOSURE')) {
    define('ryunosuke\\ltsv\\JSON_CLOSURE', -72);
}

if (!defined('ryunosuke\\ltsv\\JSON_NEST_LEVEL')) {
    define('ryunosuke\\ltsv\\JSON_NEST_LEVEL', -73);
}

if (!defined('ryunosuke\\ltsv\\JSON_INLINE_LEVEL')) {
    define('ryunosuke\\ltsv\\JSON_INLINE_LEVEL', -74);
}

if (!defined('ryunosuke\\ltsv\\JSON_INLINE_SCALARLIST')) {
    define('ryunosuke\\ltsv\\JSON_INLINE_SCALARLIST', -75);
}

if (!defined('ryunosuke\\ltsv\\JSON_ES5')) {
    define('ryunosuke\\ltsv\\JSON_ES5', -100);
}

if (!defined('ryunosuke\\ltsv\\JSON_INT_AS_STRING')) {
    define('ryunosuke\\ltsv\\JSON_INT_AS_STRING', -101);
}

if (!defined('ryunosuke\\ltsv\\JSON_FLOAT_AS_STRING')) {
    define('ryunosuke\\ltsv\\JSON_FLOAT_AS_STRING', -102);
}

if (!defined('ryunosuke\\ltsv\\JSON_TRAILING_COMMA')) {
    define('ryunosuke\\ltsv\\JSON_TRAILING_COMMA', -103);
}

if (!defined('ryunosuke\\ltsv\\JSON_COMMENT_PREFIX')) {
    define('ryunosuke\\ltsv\\JSON_COMMENT_PREFIX', -104);
}

if (!defined('ryunosuke\\ltsv\\JSON_TEMPLATE_LITERAL')) {
    define('ryunosuke\\ltsv\\JSON_TEMPLATE_LITERAL', -105);
}

if (!defined('ryunosuke\\ltsv\\JSON_BARE_AS_STRING')) {
    define('ryunosuke\\ltsv\\JSON_BARE_AS_STRING', -106);
}

if (!defined('ryunosuke\\ltsv\\SI_UNITS')) {
    define('ryunosuke\\ltsv\\SI_UNITS', [
        -8 => ["y"],
        -7 => ["z"],
        -6 => ["a"],
        -5 => ["f"],
        -4 => ["p"],
        -3 => ["n"],
        -2 => ["u", "μ", "µ"],
        -1 => ["m"],
        0  => [],
        1  => ["k", "K"],
        2  => ["M"],
        3  => ["G"],
        4  => ["T"],
        5  => ["P"],
        6  => ["E"],
        7  => ["Z"],
        8  => ["Y"],
    ]);
}

if (!defined('ryunosuke\\ltsv\\SORT_STRICT')) {
    define('ryunosuke\\ltsv\\SORT_STRICT', 256);
}

assert(!function_exists('ryunosuke\\ltsv\\array_all') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_all'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_all')) {
    /**
     * 全要素が true になるなら true を返す（1つでも false なら false を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_all([true, true]))->isTrue();
     * that(array_all([true, false]))->isFalse();
     * that(array_all([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が true なら true
     */
    function array_all($array, $callback = null, $default = true)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if (!$callback($v, $k, $n++)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_any') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_any'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_any')) {
    /**
     * 全要素が false になるなら false を返す（1つでも true なら true を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_any([true, true]))->isTrue();
     * that(array_any([true, false]))->isTrue();
     * that(array_any([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が false なら false
     */
    function array_any($array, $callback = null, $default = false)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if ($callback($v, $k, $n++)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_keys_exist') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_keys_exist'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_keys_exist')) {
    /**
     * array_key_exists の複数版
     *
     * 指定キーが全て存在するなら true を返す。
     * 配列ではなく単一文字列を与えても動作する（array_key_exists と全く同じ動作になる）。
     *
     * $keys に空を与えると例外を投げる。
     * $keys に配列を与えるとキーで潜ってチェックする（Example 参照）。
     *
     * Example:
     * ```php
     * // すべて含むので true
     * that(array_keys_exist(['a', 'b', 'c'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isTrue();
     * // N は含まないので false
     * that(array_keys_exist(['a', 'b', 'N'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isFalse();
     * // 配列を与えると潜る（日本語で言えば「a というキーと、x というキーとその中に x1, x2 というキーがあるか？」）
     * that(array_keys_exist(['a', 'x' => ['x1', 'x2']], ['a' => 'A', 'x' => ['x1' => 'X1', 'x2' => 'X2']]))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|string $keys 調べるキー
     * @param array|\ArrayAccess $array 調べる配列
     * @return bool 指定キーが全て存在するなら true
     */
    function array_keys_exist($keys, $array)
    {
        $keys = is_iterable($keys) ? $keys : [$keys];
        if (is_empty($keys)) {
            throw new \InvalidArgumentException('$keys is empty.');
        }

        $is_arrayaccess = $array instanceof \ArrayAccess;

        foreach ($keys as $k => $key) {
            if (is_array($key)) {
                // まずそのキーをチェックして
                if (!array_keys_exist($k, $array)) {
                    return false;
                }
                // あるなら再帰する
                if (!array_keys_exist($key, $array[$k])) {
                    return false;
                }
            }
            elseif ($is_arrayaccess) {
                if (!$array->offsetExists($key)) {
                    return false;
                }
            }
            elseif (!array_key_exists($key, $array)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_unset') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_unset'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_unset')) {
    /**
     * 伏せると同時にその値を返す
     *
     * $key に配列を与えると全て伏せて配列で返す。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 配列を与えた場合の返り値は与えた配列の順番・キーが活きる。
     * これを利用すると list の展開の利便性が上がったり、連想配列で返すことができる。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを伏せて配列で返す。
     * callable ではなくクロージャのみ対応する。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B'];
     * // ない場合は $default を返す
     * that(array_unset($array, 'x', 'X'))->isSame('X');
     * // 指定したキーを返す。そのキーは伏せられている
     * that(array_unset($array, 'a'))->isSame('A');
     * that($array)->isSame(['b' => 'B']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列を与えるとそれらを返す。そのキーは全て伏せられている
     * that(array_unset($array, ['a', 'b', 'x']))->isSame(['A', 'B']);
     * that($array)->isSame(['c' => 'C']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列のキーは返されるキーを表す。順番も維持される
     * that(array_unset($array, ['x2' => 'b', 'x1' => 'a']))->isSame(['x2' => 'B', 'x1' => 'A']);
     *
     * $array = ['hoge' => 'HOGE', 'fuga' => 'FUGA', 'piyo' => 'PIYO'];
     * // 値に "G" を含むものを返す。その要素は伏せられている
     * that(array_unset($array, fn($v) => strpos($v, 'G') !== false))->isSame(['hoge' => 'HOGE', 'fuga' => 'FUGA']);
     * that($array)->isSame(['piyo' => 'PIYO']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\ArrayAccess $array 配列
     * @param string|int|array|callable $key 伏せたいキー。配列を与えると全て伏せる。クロージャの場合は true 相当を伏せる
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_unset(&$array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $rk => $ak) {
                if (array_keys_exist($ak, $array)) {
                    $result[$rk] = $array[$ak];
                    unset($array[$ak]);
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    $result[$k] = $v;
                    unset($array[$k]);
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            $result = $array[$key];
            unset($array[$key]);
            return $result;
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arrayize') || (new \ReflectionFunction('ryunosuke\\ltsv\\arrayize'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arrayize')) {
    /**
     * 引数の配列を生成する。
     *
     * 配列以外を渡すと配列化されて追加される。
     * 配列を渡してもそのままだが、連番配列の場合はマージ、連想配列の場合は結合となる。
     * iterable や Traversable は考慮せずあくまで「配列」としてチェックする。
     *
     * Example:
     * ```php
     * // 値は配列化される
     * that(arrayize(1, 2, 3))->isSame([1, 2, 3]);
     * // 配列はそのまま
     * that(arrayize([1], [2], [3]))->isSame([1, 2, 3]);
     * // 連想配列、連番配列の挙動
     * that(arrayize([1, 2, 3], [4, 5, 6], ['a' => 'A1'], ['a' => 'A2']))->isSame([1, 2, 3, 4, 5, 6, 'a' => 'A1']);
     * // stdClass は foreach 可能だがあくまで配列としてチェックする
     * $object = new \stdClass();
     * that(arrayize($object, false, [1, 2, 3]))->isSame([$object, false, 1, 2, 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param mixed ...$variadic 生成する要素（可変引数）
     * @return array 引数を配列化したもの
     */
    function arrayize(...$variadic)
    {
        $result = [];
        foreach ($variadic as $arg) {
            if (!is_array($arg)) {
                $result[] = $arg;
            }
            elseif ($result && !is_hasharray($arg)) {
                $result = array_merge($result, $arg);
            }
            else {
                // array_merge に合わせるなら $result = $arg + $result で後方上書きの方がいいかも
                // 些細な変更だけど後方互換性が完全に壊れるのでいったん保留（可変引数なんてほとんど使ってないと思うけど…）
                $result += $arg; // for compatible
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_hasharray') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_hasharray'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_hasharray')) {
    /**
     * 配列が連想配列か調べる
     *
     * 空の配列は普通の配列とみなす。
     *
     * Example:
     * ```php
     * that(is_hasharray([]))->isFalse();
     * that(is_hasharray([1, 2, 3]))->isFalse();
     * that(is_hasharray(['x' => 'X']))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @return bool 連想配列なら true
     */
    function is_hasharray(array $array)
    {
        if (function_exists('array_is_list')) {
            return !array_is_list($array); // @codeCoverageIgnore
        }

        $i = 0;
        foreach ($array as $k => $dummy) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\last_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\last_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\last_key')) {
    /**
     * 配列の最後のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_key(['a', 'b', 'c']))->isSame(2);
     * that(last_key([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後のキー
     */
    function last_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $k;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\last_keyvalue') || (new \ReflectionFunction('ryunosuke\\ltsv\\last_keyvalue'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\last_keyvalue')) {
    /**
     * 配列の最後のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_keyvalue(['a', 'b', 'c']))->isSame([2, 'c']);
     * that(last_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最後のキー, 最後の値]
     */
    function last_keyvalue($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        if (is_array($array)) {
            $k = array_key_last($array);
            return [$k, $array[$k]];
        }
        /** @noinspection PhpStatementHasEmptyBodyInspection */
        foreach ($array as $k => $v) {
            // dummy
        }
        // $k がセットされてるなら「ループが最低でも1度回った（≠空）」とみなせる
        if (isset($k)) {
            /** @noinspection PhpUndefinedVariableInspection */
            return [$k, $v];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\object_properties') || (new \ReflectionFunction('ryunosuke\\ltsv\\object_properties'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\object_properties')) {
    /**
     * オブジェクトのプロパティを可視・不可視を問わず取得する
     *
     * get_object_vars + no public プロパティを返すイメージ。
     * クロージャだけは特別扱いで this + use 変数を返す。
     *
     * Example:
     * ```php
     * $object = new #[\AllowDynamicProperties] class('something', 42) extends \Exception{};
     * $object->oreore = 'oreore';
     *
     * // get_object_vars はそのスコープから見えないプロパティを取得できない
     * // var_dump(get_object_vars($object));
     *
     * // array キャストは全て得られるが null 文字を含むので扱いにくい
     * // var_dump((array) $object);
     *
     * // この関数を使えば不可視プロパティも取得できる
     * that(object_properties($object))->subsetEquals([
     *     'message' => 'something',
     *     'code'    => 42,
     *     'oreore'  => 'oreore',
     * ]);
     *
     * // クロージャは this と use 変数を返す
     * that(object_properties(fn() => $object))->is([
     *     'this'   => $this,
     *     'object' => $object,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param object $object オブジェクト
     * @param array $privates 継承ツリー上の private が格納される
     * @return array 全プロパティの配列
     */
    function object_properties($object, &$privates = [])
    {
        if ($object instanceof \Closure) {
            $ref = new \ReflectionFunction($object);
            $uses = method_exists($ref, 'getClosureUsedVariables') ? $ref->getClosureUsedVariables() : $ref->getStaticVariables();
            return ['this' => $ref->getClosureThis()] + $uses;
        }

        $fields = [];
        foreach ((array) $object as $name => $field) {
            $cname = '';
            $names = explode("\0", $name);
            if (count($names) > 1) {
                $name = array_pop($names);
                $cname = $names[1];
            }
            $fields[$cname][$name] = $field;
        }

        $classname = get_class($object);
        $parents = array_values(['', '*', $classname] + class_parents($object));
        uksort($fields, function ($a, $b) use ($parents) {
            return array_search($a, $parents, true) <=> array_search($b, $parents, true);
        });

        $result = [];
        foreach ($fields as $cname => $props) {
            foreach ($props as $name => $field) {
                if ($cname !== '' && $cname !== '*' && $classname !== $cname) {
                    $privates[$cname][$name] = $field;
                }
                if (!array_key_exists($name, $result)) {
                    $result[$name] = $field;
                }
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\sql_quote') || (new \ReflectionFunction('ryunosuke\\ltsv\\sql_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\sql_quote')) {
    /**
     * ものすごく雑に値をクオートする
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた値で**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * - null は NULL になる
     * - 数字はそのまま数字になる
     * - bool は 0 or 1 になる
     * - 配列は再帰的にカンマ区切りになる
     *   - この実装はエラー回避の意味合いが強く、実装は変更される可能性がある
     * - それ以外は addcslashes される
     *
     * Example:
     * ```php
     * that(sql_quote(null))->isSame('NULL');
     * that(sql_quote(123))->isSame(123);
     * that(sql_quote(true))->isSame(1);
     * that(sql_quote("hoge"))->isSame("'hoge'");
     * that(sql_quote([1, 2, 3]))->isSame("1,2,3");
     * ```
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param mixed $value クオートする値
     * @return mixed クオートされた値
     */
    function sql_quote($value)
    {
        if ($value === null) {
            return 'NULL';
        }
        if (is_numeric($value)) {
            return $value;
        }
        if (is_bool($value)) {
            return (int) $value;
        }
        if (is_iterable($value) && !is_stringable($value)) {
            return implode(',', array_map(fn($v) => sql_quote($v), arrayval($value)));
        }
        return "'" . addcslashes((string) $value, "\0\e\f\n\r\t\v'\\") . "'";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\path_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\path_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\path_parse')) {
    /**
     * パスをパースする
     *
     * pathinfo の（ほぼ）上位互換で下記の差異がある。
     * - drive: Windows 環境におけるドライブ文字
     * - root: 絶対パスの場合はルートパス
     * - parents: 正規化したディレクトリ名の配列
     * - dirnames: ディレクトリ名の配列（余計なことはしない）
     * - localname: 複数拡張子を考慮した本当のファイル名部分
     * - localpath: ディレクトリ名（余計なことはしない）＋複数拡張子を考慮した本当のファイル名部分（フルパス - 拡張子）
     * - extensions: 複数拡張子の配列（余計なことはしない）
     *
     * 「余計なことはしない」とは空文字をフィルタしたりパスを正規化したりを指す。
     * 結果のキーはバージョンアップで増えることがある（その場合は互換性破壊とはみなさない）。
     *
     * なお、いわゆる URL はサポートしない（スキーム付きを与えた場合の挙動は未定義）。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * // 色々混ぜたサンプル
     * that(path_parse('C:/dir1/.././dir2/file.sjis..min.js'))->is([
     *     "dirname"    => "C:/dir1/.././dir2",
     *     "basename"   => "file.sjis..min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis..min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "C:",
     *     "root"       => "/",                          // 環境依存しない元のルートパス
     *     "parents"    => ["dir2"],                     // 正規化されたディレクトリ配列
     *     "dirnames"   => ["dir1", "..", ".", "dir2"],  // 余計なことをしていないディレクトリ配列
     *     "localname"  => "file",                       // 複数拡張子を考慮した本当のファイル名部分
     *     "localpath"  => "C:/dir1/.././dir2{$DS}file", // ↑にディレクトリ名を付与したもの
     *     "extensions" => ["sjis", "", "min", "js"],    // 余計なことをしていない拡張子配列
     * ]);
     * // linux における絶対パス
     * that(path_parse('/dir1/dir2/file.sjis.min.js'))->is([
     *     "dirname"    => "/dir1/dir2",
     *     "basename"   => "file.sjis.min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis.min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "",                    // 環境を問わず空
     *     "root"       => "/",                   // 絶対パスなので "/"
     *     "parents"    => ["dir1", "dir2"],      // ..等がないので dirnames と同じ
     *     "dirnames"   => ["dir1", "dir2"],      // ディレクトリ配列
     *     "localname"  => "file",
     *     "localpath"  => "/dir1/dir2{$DS}file",
     *     "extensions" => ["sjis", "min", "js"], // 余計なことをしていない拡張子配列
     * ]);
     * // linux における相対パス
     * that(path_parse('dir1/dir2/file.sjis.min.js'))->is([
     *     "dirname"    => "dir1/dir2",
     *     "basename"   => "file.sjis.min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis.min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "",
     *     "root"       => "",                    // 相対パスなので空（ここ以外は絶対パスと同じ）
     *     "parents"    => ["dir1", "dir2"],
     *     "dirnames"   => ["dir1", "dir2"],
     *     "localname"  => "file",
     *     "localpath"  => "dir1/dir2{$DS}file",
     *     "extensions" => ["sjis", "min", "js"],
     * ]);
     * // ディレクトリ無し
     * that(path_parse('file.sjis.min.js'))->is([
     *     "dirname"    => ".",
     *     "basename"   => "file.sjis.min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis.min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "",
     *     "root"       => "",
     *     "parents"    => [], // オリジナルの pathinfo のようにドットが紛れ込んだりはしない
     *     "dirnames"   => [], // オリジナルの pathinfo のようにドットが紛れ込んだりはしない
     *     "localname"  => "file",
     *     "localpath"  => "file",
     *     "extensions" => ["sjis", "min", "js"],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス
     * @return array パス情報
     */
    function path_parse($path)
    {
        $DS = DIRECTORY_SEPARATOR === '\\' ? '\\/' : '/';

        // キーが存在しないことがあるので順番も含めて正規化する
        $pathinfo = array_replace([
            'dirname'   => '',
            'basename'  => '',
            'extension' => '',
            'filename'  => '',
        ], pathinfo($path));

        $result = $pathinfo;

        // pathinfo の直感的でない挙動を補正する（dirname が . を返したり C:/ の結果が曖昧だったり）
        if ($pathinfo['dirname'] === '.') {
            $pathinfo['dirname'] = '';
        }
        if (DIRECTORY_SEPARATOR === '\\' && strlen(rtrim($path, '\\')) === 2) {
            $pathinfo['basename'] = '';
            $pathinfo['extension'] = '';
            $pathinfo['filename'] = '';
        }
        $dirnames = preg_split("#([" . preg_quote($DS) . "]+)#u", $pathinfo['dirname'], -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
        $basenames = explode('.', $pathinfo['basename']);

        $result['drive'] = '';
        if (isset($dirnames[0]) && preg_match('#^[a-z]:$#ui', $dirnames[0])) {
            $result['drive'] = array_shift($dirnames);
        }

        $result['root'] = '';
        if (isset($dirnames[0]) && strpbrk($dirnames[0], $DS) !== false) {
            $result['root'] = array_shift($dirnames);
        }

        $result['parents'] = array_reduce($dirnames, function ($carry, $dirname) use ($DS) {
            if (strpbrk($dirname, $DS) !== false || $dirname === '.') {
                return $carry;
            }
            if ($dirname === '..') {
                return array_slice($carry, 0, -1);
            }
            else {
                return array_merge($carry, [$dirname]);
            }
        }, []);

        $result['dirnames'] = array_reduce($dirnames, function ($carry, $dirname) use ($DS) {
            if (strpbrk($dirname, $DS) === false) {
                return array_merge($carry, [$dirname]);
            }
            else {
                return array_merge($carry, array_pad([], strlen($dirname) - 1, ''));
            }
        }, []);

        $result['localname'] = array_shift($basenames);
        $result['localpath'] = implode(DIRECTORY_SEPARATOR, array_filter([$pathinfo['dirname'], $result['localname']], 'strlen'));
        $result['extensions'] = $basenames;

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\func_user_func_array') || (new \ReflectionFunction('ryunosuke\\ltsv\\func_user_func_array'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\func_user_func_array')) {
    /**
     * パラメータ定義数に応じて呼び出し引数を可変にしてコールする
     *
     * デフォルト引数はカウントされない。必須パラメータの数で呼び出す。
     *
     * $callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。
     *
     * php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。
     *
     * Example:
     * ```php
     * // strlen に2つの引数を渡してもエラーにならない
     * $strlen = func_user_func_array('strlen');
     * that($strlen('abc', null))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param callable|null $callback 呼び出すクロージャ
     * @return callable 引数ぴったりで呼び出すクロージャ
     */
    function func_user_func_array($callback)
    {
        // null は第1引数を返す特殊仕様
        if ($callback === null) {
            return fn($v) => $v;
        }
        // クロージャはユーザ定義しかありえないので調べる必要がない
        if ($callback instanceof \Closure) {
            // と思ったが、\Closure::fromCallable で作成されたクロージャは内部属性が伝播されるようなので除外
            if (reflect_callable($callback)->isUserDefined()) {
                return $callback;
            }
        }

        // 上記以外は「引数ぴったりで削ぎ落としてコールするクロージャ」を返す
        $plength = parameter_length($callback, true, true);
        return function (...$args) use ($callback, $plength) {
            if (is_infinite($plength)) {
                return $callback(...$args);
            }
            return $callback(...array_slice($args, 0, $plength));
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_bindable_closure') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_bindable_closure'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_bindable_closure')) {
    /**
     * $this を bind 可能なクロージャか調べる
     *
     * Example:
     * ```php
     * that(is_bindable_closure(function () {}))->isTrue();
     * that(is_bindable_closure(static function () {}))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param \Closure $closure 調べるクロージャ
     * @return bool $this を bind 可能なクロージャなら true
     */
    function is_bindable_closure(\Closure $closure)
    {
        return !!@$closure->bindTo(new \stdClass());
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arguments') || (new \ReflectionFunction('ryunosuke\\ltsv\\arguments'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arguments')) {
    /**
     * コマンドライン引数をパースして引数とオプションを返す
     *
     * 少しリッチな {@link http://php.net/manual/function.getopt.php getopt} として使える（shell 由来のオプション構文(a:b::)はどうも馴染みにくい）。
     * ただし「値が必須なオプション」はサポートしない。
     * もっとも、オプションとして空文字が来ることはほぼ無いのでデフォルト値を空文字にすることで対応可能。
     *
     * $rule に従って `--noval filename --opt optval` のような文字列・配列をパースする。
     * $rule 配列の仕様は下記。
     *
     * - キーは「オプション名」を指定する。ただし・・・
     *     - 数値キーは「引数」を意味する
     *     - スペースの後に「ショート名」を与えられる
     * - 値は「デフォルト値」を指定する。ただし・・・
     *     - `[]` は「複数値オプション」を意味する（配列にしない限り同オプションの多重指定は許されない）
     *     - `null` は「値なしオプション」を意味する（スイッチングオプション）
     * - 空文字キーは解釈自体のオプションを与える
     *     - 今のところ throw のみの実装。配列ではなく bool を与えられる
     *
     * 上記の仕様でパースして「引数は数値連番、オプションはオプション名をキーとした配列」を返す。
     * なお、いわゆる「引数」はどこに来ても良い（前オプション、後オプションの区別がない）。
     *
     * $argv には配列や文字列が与えられるが、ほとんどテスト用に近く、普通は未指定で $argv を使うはず。
     *
     * Example:
     * ```php
     * // いくつか織り交ぜたスタンダードな例
     * $rule = [
     *     'opt'       => 'def',    // 基本的には「デフォルト値」を表す
     *     'longopt l' => '',       // スペース区切りで「ショート名」を意味する
     *     1           => 'defarg', // 数値キーは「引数」を意味する
     * ];
     * that(arguments($rule, '--opt optval arg1 -l longval'))->isSame([
     *     'opt'     => 'optval',  // optval と指定している
     *     'longopt' => 'longval', // ショート名指定でも本来の名前で返ってくる
     *     'arg1',   // いわゆるコマンドライン引数（optval は opt に飲まれるので含まれない）
     *     'defarg', // いわゆるコマンドライン引数（与えられていないが、ルールの 1 => 'defarg' が活きている）
     * ]);
     *
     * // 「値なしオプション」と「複数値オプション」の例
     * $rule = [
     *     'noval1 l'  => null, // null は「値なしオプション」を意味する（指定されていれば true されていなければ false を返す）
     *     'noval2 m'  => null, // 同上
     *     'noval3 n'  => null, // 同上
     *     'opts o' => [],      // 配列を与えると「複数値オプション」を表す
     * ];
     * that(arguments($rule, '--opts o1 -ln arg1 -o o2 arg2 --opts o3'))->isSame([
     *     'noval1' => true,  // -ln で同時指定されているので true
     *     'noval2' => false, // -ln で同時指定されてないので false
     *     'noval3' => true,  // -ln の同時指定されているので true
     *     'opts'   => ['o1', 'o2', 'o3'], // ロング、ショート混在でも OK
     *     'arg1', // 一見 -ln のオプション値に見えるが、 noval は値なしなので引数として得られる
     *     'arg2', // 前オプション、後オプションの区別はないのでどこに居ようと引数として得られる
     * ]);
     *
     * // 空文字で解釈自体のオプションを与える
     * $rule = [
     *     ''  => false, // 定義されていないオプションが来ても例外を投げずに引数として処理する
     * ];
     * that(arguments($rule, '--long A -short B'))->isSame([
     *     '--long', // 明らかにオプション指定に見えるが、 long というオプションは定義されていないので引数として解釈される
     *     'A',      // 同上。long のオプション値に見えるが、ただの引数
     *     '-short', // 同上。short というオプションは定義されていない
     *     'B',      // 同上。short のオプション値に見えるが、ただの引数
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param array $rule オプションルール
     * @param array|string|null $argv パースするコマンドライン引数。未指定時は $argv が使用される
     * @return array コマンドライン引数＋オプション
     */
    function arguments($rule, $argv = null)
    {
        $opt = array_unset($rule, '', []);
        if (is_bool($opt)) {
            $opt = ['thrown' => $opt];
        }
        $opt += [
            'thrown' => true,
        ];

        if ($argv === null) {
            $argv = array_slice($_SERVER['argv'], 1); // @codeCoverageIgnore
        }
        if (is_string($argv)) {
            $argv = quoteexplode([" ", "\t"], $argv);
            $argv = array_filter($argv, 'strlen');
        }
        $argv = array_values($argv);

        $shortmap = [];
        $argsdefaults = [];
        $optsdefaults = [];
        foreach ($rule as $name => $default) {
            if (is_int($name)) {
                $argsdefaults[$name] = $default;
                continue;
            }
            [$longname, $shortname] = preg_split('#\s+#u', $name, -1, PREG_SPLIT_NO_EMPTY) + [1 => ''];
            if (strlen($shortname)) {
                if (array_key_exists($shortname, $shortmap)) {
                    throw new \InvalidArgumentException("duplicated short option name '$shortname'");
                }
                $shortmap[$shortname] = $longname;
            }
            if (array_key_exists($longname, $optsdefaults)) {
                throw new \InvalidArgumentException("duplicated option name '$shortname'");
            }
            $optsdefaults[$longname] = $default;
        }

        $n = 0;
        $already = [];
        $result = array_map(fn($v) => $v === null ? false : $v, $optsdefaults);
        while (($token = array_shift($argv)) !== null) {
            if (strlen($token) >= 2 && $token[0] === '-') {
                if ($token[1] === '-') {
                    $optname = substr($token, 2);
                    if (!$opt['thrown'] && !array_key_exists($optname, $optsdefaults)) {
                        $result[$n++] = $token;
                        continue;
                    }
                }
                else {
                    $shortname = substr($token, 1);
                    if (!$opt['thrown'] && !array_keys_exist(str_split($shortname, 1), $shortmap)) {
                        $result[$n++] = $token;
                        continue;
                    }
                    if (strlen($shortname) > 1) {
                        array_unshift($argv, '-' . substr($shortname, 1));
                        $shortname = substr($shortname, 0, 1);
                    }
                    if (!isset($shortmap[$shortname])) {
                        throw new \InvalidArgumentException("undefined short option name '$shortname'.");
                    }
                    $optname = $shortmap[$shortname];
                }

                if (!array_key_exists($optname, $optsdefaults)) {
                    throw new \InvalidArgumentException("undefined option name '$optname'.");
                }
                if (isset($already[$optname]) && !is_array($result[$optname])) {
                    throw new \InvalidArgumentException("'$optname' is specified already.");
                }
                $already[$optname] = true;

                if ($optsdefaults[$optname] === null) {
                    $result[$optname] = true;
                }
                else {
                    if (!isset($argv[0]) || strpos($argv[0], '-') === 0) {
                        throw new \InvalidArgumentException("'$optname' requires value.");
                    }
                    if (is_array($result[$optname])) {
                        $result[$optname][] = array_shift($argv);
                    }
                    else {
                        $result[$optname] = array_shift($argv);
                    }
                }
            }
            else {
                $result[$n++] = $token;
            }
        }

        array_walk_recursive($result, function (&$v) {
            if (is_string($v)) {
                $v = trim(str_replace('\\"', '"', $v), '"');
            }
        });
        return $result + $argsdefaults;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\finalize') || (new \ReflectionFunction('ryunosuke\\ltsv\\finalize'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\finalize')) {
    /**
     * 自身が死ぬときに指定 callable を呼ぶオブジェクトを返す
     *
     * invoke を実装しているので明示的にも呼べる。
     * 明示的だろうと暗黙的だろうと必ず1回しか呼ばれない。
     *
     * Example:
     * ```php
     * $called = 0;
     * $finalizer = finalize(function()use(&$called){$called++;});
     * that($called)->is(0); // まだ呼ばれていない
     *
     * // コールすると・・・
     * $finalizer();
     * that($called)->is(1); // 呼ばれている
     *
     * // unset（GC）でも呼ばれる
     * unset($finalizer);
     * that($called)->is(1); // が、一度しか呼ばれないので呼ばれない
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param callable $finalizer 実行する php コード
     * @return callable GC 時に $finalizer を実行する callable
     */
    function finalize(callable $finalizer)
    {
        return new class($finalizer) {
            public function __construct(private $finalizer) { }

            public function __destruct() { $this->__invoke(); }

            public function __invoke()
            {
                if (isset($this->finalizer)) {
                    ($this->finalizer)();
                    unset($this->finalizer);
                    gc_collect_cycles();
                }
            }
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ini_sets') || (new \ReflectionFunction('ryunosuke\\ltsv\\ini_sets'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ini_sets')) {
    /**
     * 複数の php.ini の設定をまとめて設定する
     *
     * 返り値として「もとに戻すためのクロージャ」を返すので、復元するためにはそのクロージャを呼ぶだけで良い。
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param array $values ini のエントリ名と値の配列
     * @return callable ini を元に戻す callable
     */
    function ini_sets($values)
    {
        $main = static function ($values) {
            $currents = [];
            foreach ($values as $name => $value) {
                $current = ini_set($name, $value);
                if ($current !== false) {
                    $currents[$name] = $current;
                }
            }
            return $currents;
        };
        $currents = $main($values);
        return finalize(fn() => $main($currents));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\evaluate') || (new \ReflectionFunction('ryunosuke\\ltsv\\evaluate'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\evaluate')) {
    /**
     * eval のプロキシ関数
     *
     * 一度ファイルに吐いてから require した方が opcache が効くので抜群に速い。
     * また、素の eval は ParseError が起こったときの表示がわかりにくすぎるので少し見やすくしてある。
     *
     * 関数化してる以上 eval におけるコンテキストの引き継ぎはできない。
     * ただし、引数で変数配列を渡せるようにしてあるので get_defined_vars を併用すれば基本的には同じ（$this はどうしようもない）。
     *
     * 短いステートメントだと opcode が少ないのでファイルを経由せず直接 eval したほうが速いことに留意。
     * 一応引数で指定できるようにはしてある。
     *
     * Example:
     * ```php
     * $a = 1;
     * $b = 2;
     * $phpcode = ';
     * $c = $a + $b;
     * return $c * 3;
     * ';
     * that(evaluate($phpcode, get_defined_vars()))->isSame(9);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode 実行する php コード
     * @param array $contextvars コンテキスト変数配列
     * @param int $cachesize キャッシュするサイズ
     * @return mixed eval の return 値
     */
    function evaluate($phpcode, $contextvars = [], $cachesize = 256)
    {
        $cachefile = null;
        if ($cachesize && strlen($phpcode) >= $cachesize) {
            $cachefile = function_configure('storagedir') . '/' . rawurlencode(__FUNCTION__) . '-' . sha1($phpcode) . '.php';
            if (!file_exists($cachefile)) {
                file_put_contents($cachefile, "<?php $phpcode", LOCK_EX);
            }
        }

        try {
            if ($cachefile) {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return require func_get_arg(0);
                })($cachefile, $contextvars);
            }
            else {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return eval(func_get_arg(0));
                })($phpcode, $contextvars);
            }
        }
        catch (\ParseError $ex) {
            $errline = $ex->getLine();
            $errline_1 = $errline - 1;
            $codes = preg_split('#\\R#u', $phpcode);
            $codes[$errline_1] = '>>> ' . $codes[$errline_1];

            $N = 5; // 前後の行数
            $message = $ex->getMessage();
            $message .= "\n" . implode("\n", array_slice($codes, max(0, $errline_1 - $N), $N * 2 + 1));
            if ($cachefile) {
                $message .= "\n in " . realpath($cachefile) . " on line " . $errline . "\n";
            }
            throw new \ParseError($message, $ex->getCode(), $ex);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\php_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\php_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\php_parse')) {
    /**
     * php のコード断片をパースする
     *
     * @todo そもそも何がしたいのかよくわからない関数になってきたので動作の洗い出しが必要
     *
     * Example:
     * ```php
     * $phpcode = '<?php
     * namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * // namespace ～ ; を取得
     * $part = php_parse($phpcode, [
     *     'begin' => T_NAMESPACE,
     *     'end'   => ';',
     * ]);
     * that(implode('', array_column($part, 'text')))->isSame('namespace Hogera;');
     *
     * // class ～ { を取得
     * $part = php_parse($phpcode, [
     *     'begin' => T_CLASS,
     *     'end'   => '{',
     * ]);
     * that(implode('', array_column($part, 'text')))->isSame("class Example\n{");
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode パースする php コード
     * @param array|int $option パースオプション
     * @return \PhpToken[] トークン配列
     */
    function php_parse($phpcode, $option = [])
    {
        if (is_int($option)) {
            $option = ['flags' => $option];
        }

        $default = [
            'short_open_tag' => null, // ショートオープンタグを扱うか（null だと余計なことはせず ini に従う）
            'line'           => [],   // 行の範囲（以上以下）
            'position'       => [],   // 文字位置の範囲（以上以下）
            'begin'          => [],   // 開始トークン
            'end'            => [],   // 終了トークン
            'offset'         => 0,    // 開始トークン位置
            'flags'          => 0,    // PHPToken の $flags. TOKEN_PARSE を与えると ParseError が出ることがあるのでデフォルト 0
            'cache'          => true, // キャッシュするか否か
            'greedy'         => false,// end と nest か一致したときに処理を継続するか
            'backtick'       => true, // `` もパースするか
            'nest_token'     => [
                ')' => '(',
                '}' => '{',
                ']' => '[',
            ],
        ];
        $option += $default;

        $cachekey = var_hash($phpcode) . $option['flags'] . '-' . $option['backtick'] . '-' . var_export($option['short_open_tag'], true);
        static $cache = [];
        if (!($option['cache'] && isset($cache[$cachekey]))) {
            $position = 0;
            $backtick = '';
            $backticktoken = null;
            $backticking = false;

            $tokens = [];
            $tmp = \PhpToken::tokenize($phpcode, $option['flags']);
            for ($i = 0; $i < count($tmp); $i++) {
                $token = $tmp[$i];

                // @codeCoverageIgnoreStart
                if ($option['short_open_tag'] === true && $token->id === T_INLINE_HTML && ($p = strpos($token->text, '<?')) !== false) {
                    $newtokens = [];
                    $nlcount = 0;

                    if ($p !== 0) {
                        $html = substr($token->text, 0, $p);
                        $nlcount = preg_match_all('#\r\n|\r|\n#u', $html);
                        $newtokens[] = new \PhpToken(T_INLINE_HTML, $html, $token->line);
                    }

                    $code = substr($token->text, $p + 2);
                    $subtokens = \PhpToken::tokenize("<?php $code");
                    $subtokens[0]->text = '<?';
                    foreach ($subtokens as $subtoken) {
                        $subtoken->line += $token->line + $nlcount - 1;
                        $newtokens[] = $subtoken;
                    }

                    array_splice($tmp, $i + 1, 0, $newtokens);
                    continue;
                }
                if ($option['short_open_tag'] === false && $token->id === T_OPEN_TAG && $token->text === '<?') {
                    for ($j = $i + 1; $j < count($tmp); $j++) {
                        if ($tmp[$j]->id === T_CLOSE_TAG) {
                            break;
                        }
                    }
                    $html = implode('', array_map(fn($token) => $token->text, array_slice($tmp, $i, $j - $i + 1)));
                    array_splice($tmp, $i + 1, $j - $i, [new \PhpToken(T_INLINE_HTML, $html, $token->line)]);
                    continue;
                }
                // @codeCoverageIgnoreEnd

                if (!$option['backtick']) {
                    if ($token->text === '`') {
                        if ($backticking) {
                            $token->text = $backtick . $token->text;
                            $token->line = $backticktoken->line;
                            $token->pos = $backticktoken->pos;
                            $backtick = '';
                        }
                        else {
                            $backticktoken = $token;
                        }
                        $backticking = !$backticking;
                    }
                    if ($backticking) {
                        $backtick .= $token->text;
                        continue;
                    }
                }

                $token->pos = $position;
                $position += strlen($token->text);

                /* PhpToken になりコピーオンライトが効かなくなったので時々書き換えをチェックした方が良い
                $token = new class($token->id, $token->text, $token->line, $token->pos) extends \PhpToken {
                    private array $backup = [];
    
                    public function backup()
                    {
                        $this->backup = [
                            'id'   => $this->id,
                            'text' => $this->text,
                            'line' => $this->line,
                            'pos'  => $this->pos,
                        ];
                    }
    
                    public function __clone(): void
                    {
                        $this->backup = [];
                    }
    
                    public function __destruct()
                    {
                        foreach ($this->backup as $name => $value) {
                            assert($this->$name === $value);
                        }
                    }
                };
                $token->backup();
                 */

                $tokens[] = $token;
            }
            // @codeCoverageIgnoreStart
            if ($option['short_open_tag'] === false) {
                for ($i = 0; $i < count($tokens); $i++) {
                    if ($tokens[$i]->id === T_INLINE_HTML && isset($tokens[$i + 1]) && $tokens[$i + 1]->id === T_INLINE_HTML) {
                        $tokens[$i]->text .= $tokens[$i + 1]->text;
                        array_splice($tokens, $i + 1, 1, []);
                        $i--;
                    }
                }
            }
            // @codeCoverageIgnoreEnd
            $cache[$cachekey] = $tokens;
        }
        $tokens = $cache[$cachekey];

        $lines = $option['line'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $positions = $option['position'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $begin_tokens = (array) $option['begin'];
        $end_tokens = (array) $option['end'];
        $nest_tokens = $option['nest_token'];
        $greedy = $option['greedy'];

        $result = [];
        $starting = !$begin_tokens;
        $nesting = 0;
        $offset = is_array($option['offset']) ? ($option['offset'][0] ?? 0) : $option['offset'];
        $endset = is_array($option['offset']) ? ($option['offset'][1] ?? count($tokens)) : count($tokens);

        for ($i = $offset; $i < $endset; $i++) {
            $token = $tokens[$i];

            if ($lines[0] > $token->line) {
                continue;
            }
            if ($lines[1] < $token->line) {
                continue;
            }
            if ($positions[0] > $token->pos) {
                continue;
            }
            if ($positions[1] < $token->pos) {
                continue;
            }

            foreach ($begin_tokens as $t) {
                if ($t === $token->id || $t === $token->text) {
                    $starting = true;
                    break;
                }
            }
            if (!$starting) {
                continue;
            }

            $result[$i] = $token;

            foreach ($nest_tokens as $end_nest => $start_nest) {
                if ($token->id === $start_nest || $token->text === $start_nest) {
                    $nesting++;
                }
                if ($token->id === $end_nest || $token->text === $end_nest) {
                    $nesting--;
                }
            }

            foreach ($end_tokens as $t) {
                if ($t === $token->id || $t === $token->text) {
                    if ($nesting <= 0 || ($nesting === 1 && in_array($t, $nest_tokens, true))) {
                        if ($nesting === 0 && $greedy && isset($nest_tokens[$t])) {
                            break;
                        }
                        break 2;
                    }
                    break;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\preg_capture') || (new \ReflectionFunction('ryunosuke\\ltsv\\preg_capture'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\preg_capture')) {
    /**
     * キャプチャを主軸においた preg_match
     *
     * $pattern で $subject をマッチングして $default で埋めて返す。$default はフィルタも兼ねる。
     * 空文字マッチは「マッチしていない」とみなすので注意（$default が使用される）。
     *
     * キャプチャを主軸においているので「マッチしなかった」は検出不可能。
     * $default がそのまま返ってくる。
     *
     * Example:
     * ```php
     * $pattern = '#(\d{4})/(\d{1,2})(/(\d{1,2}))?#';
     * $default = [1 => '2000', 2 => '1', 4 => '1'];
     * // 完全にマッチするのでそれぞれ返ってくる
     * that(preg_capture($pattern, '2014/12/24', $default))->isSame([1 => '2014', 2 => '12', 4 => '24']);
     * // 最後の \d{1,2} はマッチしないのでデフォルト値が使われる
     * that(preg_capture($pattern, '2014/12', $default))->isSame([1 => '2014', 2 => '12', 4 => '1']);
     * // 一切マッチしないので全てデフォルト値が使われる
     * that(preg_capture($pattern, 'hoge', $default))->isSame([1 => '2000', 2 => '1', 4 => '1']);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param string $subject 対象文字列
     * @param array $default デフォルト値
     * @return array キャプチャした配列
     */
    function preg_capture($pattern, $subject, $default)
    {
        preg_match($pattern, $subject, $matches);

        foreach ($matches as $n => $match) {
            if (array_key_exists($n, $default) && strlen($match)) {
                $default[$n] = $match;
            }
        }

        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\preg_splice') || (new \ReflectionFunction('ryunosuke\\ltsv\\preg_splice'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\preg_splice')) {
    /**
     * キャプチャも行える preg_replace
     *
     * 「置換を行いつつ、キャプチャ文字列が欲しい」状況はまれによくあるはず。
     *
     * $replacement に callable を渡すと preg_replace_callback がコールされる。
     * callable とはいっても単純文字列 callble （"strtoupper" など）は callable とはみなされない。
     * 配列形式の callable や クロージャのみ preg_replace_callback になる。
     *
     * Example:
     * ```php
     * // 数字を除去しつつその除去された数字を得る
     * that(preg_splice('#\\d+#', '', 'abc123', $m))->isSame('abc');
     * that($m)->isSame(['123']);
     *
     * // callable だと preg_replace_callback が呼ばれる
     * that(preg_splice('#[a-z]+#', fn($m) => strtoupper($m[0]), 'abc123', $m))->isSame('ABC123');
     * that($m)->isSame(['abc']);
     *
     * // ただし、 文字列 callable は文字列として扱う
     * that(preg_splice('#[a-z]+#', 'strtoupper', 'abc123', $m))->isSame('strtoupper123');
     * that($m)->isSame(['abc']);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param string|callable $replacement 置換文字列
     * @param string $subject 対象文字列
     * @param array $matches キャプチャ配列が格納される
     * @param int $limit 置換回数
     * @return string 置換された文字列
     */
    function preg_splice($pattern, $replacement, $subject, &$matches = [], $limit = -1)
    {
        // for compatible. $limit => 1
        // preg_match なので $matches は最初しか引っかからないにも関わらず $limit:-1 だとすべて置換されてしまう

        if (preg_match($pattern, $subject, $matches)) {
            if (!is_string($replacement) && is_callable($replacement)) {
                $subject = preg_replace_callback($pattern, $replacement, $subject, $limit);
            }
            else {
                $subject = preg_replace($pattern, $replacement, $subject, $limit);
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\unique_string') || (new \ReflectionFunction('ryunosuke\\ltsv\\unique_string'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\unique_string')) {
    /**
     * 文字列に含まれない文字列を生成する
     *
     * 例えば http のマルチパートバウンダリのような、「競合しない文字列」を生成する。
     * 実装は愚直に文字列を調べて存在しなければそれを返すようになっている。
     * 一応初期値や文字セットは指定可能。
     *
     * $initial に int を与えると初期値としてその文字数分 $charlist から確保する。
     * 例えば生成後の変更が前提で、ある程度の長さを担保したいときに指定すれば最低でもその長さ以上は保証される。
     * $initial に string を与えるとそれがそのまま初期値として使用される。
     * 例えば「ほぼ存在しない文字列」が予測できるのであればそれを指定すれば無駄な処理が省ける。
     *
     * Example:
     * ```php
     * // 単純に呼ぶと生成1,2文字程度の文字列になる
     * that(unique_string('hello, world'))->stringLengthEqualsAny([1, 2]);
     * // 数値を含んでいないので候補文字に数値のみを指定すれば1文字で「存在しない文字列」となる
     * that(unique_string('hello, world', null, range(0, 9)))->stringLengthEquals(1);
     * // int を渡すと最低でもそれ以上は保証される
     * that(unique_string('hello, world', 5))->stringLengthEqualsAny([5, 6]);
     * // string を渡すとそれが初期値となる
     * that(unique_string('hello, world', 'prefix-'))->stringStartsWith('prefix');
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param string $source 元文字列
     * @param string|int $initial 初期文字列あるいは文字数
     * @param string|array $charlist 使用する文字セット
     * @return string 一意な文字列
     */
    function unique_string($source, $initial = null, $charlist = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    {
        assert(is_stringable($initial) || is_int($initial) || is_null($initial));

        if (is_stringable($charlist)) {
            $charlist = preg_split('//', $charlist, -1, PREG_SPLIT_NO_EMPTY);
        }

        $charlength = count($charlist);
        if ($charlength === 0) {
            throw new \InvalidArgumentException('charlist is empty.');
        }

        $result = '';
        if (is_int($initial)) {
            shuffle($charlist);
            $result = implode('', array_slice($charlist, 0, $initial));
        }
        elseif (is_null($initial)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }
        else {
            $result = $initial;
        }

        while ((($p = strpos($source, $result, $p ?? 0)) !== false)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\callable_code') || (new \ReflectionFunction('ryunosuke\\ltsv\\callable_code'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\callable_code')) {
    /**
     * callable のコードブロックを返す
     *
     * 返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。
     *
     * Example:
     * ```php
     * list($meta, $body) = callable_code(function (...$args) {return true;});
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     *
     * // ReflectionFunctionAbstract を渡しても動作する
     * list($meta, $body) = callable_code(new \ReflectionFunction(function (...$args) {return true;}));
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable|\ReflectionFunctionAbstract $callable コードを取得する callable
     * @param bool $return_token true にすると生のトークン配列で返す
     * @return array ['定義部分', '{処理コード}']
     */
    function callable_code($callable, bool $return_token = false)
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $contents = file($ref->getFileName());
        $start = $ref->getStartLine();
        $end = $ref->getEndLine();
        $codeblock = implode('', array_slice($contents, $start - 1, $end - $start + 1));

        $meta = php_parse("<?php $codeblock", [
            'begin' => [T_FN, T_FUNCTION],
            'end'   => ['{', T_DOUBLE_ARROW],
        ]);
        $end = array_pop($meta);

        if ($end->id === T_DOUBLE_ARROW) {
            $body = php_parse("<?php $codeblock", [
                'begin'  => T_DOUBLE_ARROW,
                'end'    => [';', ',', ')'],
                'offset' => last_key($meta),
                'greedy' => true,
            ]);
            $body = array_slice($body, 1, -1);
        }
        else {
            $body = php_parse("<?php $codeblock", [
                'begin'  => '{',
                'end'    => '}',
                'offset' => last_key($meta),
            ]);
        }

        if ($return_token) {
            return [$meta, $body];
        }

        return [trim(implode('', array_column($meta, 'text'))), trim(implode('', array_column($body, 'text')))];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\parameter_length') || (new \ReflectionFunction('ryunosuke\\ltsv\\parameter_length'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\parameter_length')) {
    /**
     * callable の引数の数を返す
     *
     * クロージャはキャッシュされない。毎回リフレクションを生成し、引数の数を調べてそれを返す。
     * （クロージャには一意性がないので key-value なキャッシュが適用できない）。
     * ので、ループ内で使ったりすると目に見えてパフォーマンスが低下するので注意。
     *
     * Example:
     * ```php
     * // trim の引数は2つ
     * that(parameter_length('trim'))->isSame(2);
     * // trim の必須引数は1つ
     * that(parameter_length('trim', true))->isSame(1);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param bool $require_only true を渡すと必須パラメータの数を返す
     * @param bool $thought_variadic 可変引数を考慮するか。 true を渡すと可変引数の場合に無限長を返す
     * @return int 引数の数
     */
    function parameter_length($callable, $require_only = false, $thought_variadic = false)
    {
        // クロージャの $call_name には一意性がないのでキャッシュできない（spl_object_hash でもいいが、かなり重複するので完全ではない）
        if ($callable instanceof \Closure) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            if ($thought_variadic && $ref->isVariadic()) {
                return INF;
            }
            elseif ($require_only) {
                return $ref->getNumberOfRequiredParameters();
            }
            else {
                return $ref->getNumberOfParameters();
            }
        }

        // $call_name 取得
        is_callable($callable, false, $call_name);

        $cache = cache($call_name, function () use ($callable) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            return [
                '00' => $ref->getNumberOfParameters(),
                '01' => $ref->isVariadic() ? INF : $ref->getNumberOfParameters(),
                '10' => $ref->getNumberOfRequiredParameters(),
                '11' => $ref->isVariadic() ? INF : $ref->getNumberOfRequiredParameters(),
            ];
        }, __FUNCTION__);
        return $cache[(int) $require_only . (int) $thought_variadic];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\reflect_callable') || (new \ReflectionFunction('ryunosuke\\ltsv\\reflect_callable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\reflect_callable')) {
    /**
     * callable から ReflectionFunctionAbstract を生成する
     *
     * 実際には ReflectionFunctionAbstract を下記の独自拡張した Reflection クラスを返す（メソッドのオーバーライド等はしていないので完全互換）。
     * - __invoke: 元となったオブジェクトを $this として invoke する（関数・クロージャは invoke と同義）
     * - call: 実行 $this を指定して invoke する（クロージャ・メソッドのみ）
     *   - 上記二つは __call/__callStatic のメソッドも呼び出せる
     * - getDeclaration: 宣言部のコードを返す
     * - getCode: 定義部のコードを返す
     * - isStatic: $this バインド可能かを返す（クロージャのみ）
     * - getUsedVariables: use している変数配列を返す（クロージャのみ）
     *
     * Example:
     * ```php
     * that(reflect_callable('sprintf'))->isInstanceOf(\ReflectionFunction::class);
     * that(reflect_callable('\Closure::bind'))->isInstanceOf(\ReflectionMethod::class);
     *
     * $x = 1;
     * $closure = function ($a, $b) use (&$x) { return $a + $b; };
     * $reflection = reflect_callable($closure);
     * // 単純実行
     * that($reflection(1, 2))->is(3);
     * // 無名クラスを $this として実行
     * that($reflection->call(new class(){}, 1, 2))->is(3);
     * // 宣言部を返す
     * that($reflection->getDeclaration())->is('function ($a, $b) use (&$x)');
     * // 定義部を返す
     * that($reflection->getCode())->is('{ return $a + $b; }');
     * // static か返す
     * that($reflection->isStatic())->is(false);
     * // use 変数を返す
     * that($reflection->getUsedVariables())->is(['x' => 1]);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @return \ReflectCallable|\ReflectionFunction|\ReflectionMethod リフレクションインスタンス
     */
    function reflect_callable($callable)
    {
        // callable チェック兼 $call_name 取得
        if (!is_callable($callable, true, $call_name)) {
            throw new \InvalidArgumentException("'$call_name' is not callable");
        }

        if (is_string($call_name) && strpos($call_name, '::') === false) {
            return new class($callable) extends \ReflectionFunction {
                private $definition;

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }
            };
        }
        elseif ($callable instanceof \Closure) {
            return new class($callable) extends \ReflectionFunction {
                private $callable;
                private $definition;

                public function __construct($function)
                {
                    parent::__construct($function);

                    $this->callable = $function;
                }

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    return ($this->callable)->call($newThis ?? $this->getClosureThis(), ...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isStatic(): bool
                {
                    return !is_bindable_closure($this->callable);
                }

                public function getUsedVariables(): array
                {
                    $uses = object_properties($this->callable);
                    unset($uses['this']);
                    return $uses;
                }
            };
        }
        else {
            [$class, $method] = explode('::', $call_name, 2);
            // for タイプ 5: 相対指定による静的クラスメソッドのコール (PHP 5.3.0 以降)
            if (strpos($method, 'parent::') === 0) {
                [, $method] = explode('::', $method);
                $class = get_parent_class($class);
            }

            $called_name = '';
            if (!method_exists(is_array($callable) && is_object($callable[0]) ? $callable[0] : $class, $method)) {
                $called_name = $method;
                $method = is_array($callable) && is_object($callable[0]) ? '__call' : '__callStatic';
            }

            return new class($class, $method, $callable, $called_name) extends \ReflectionMethod {
                private $callable;
                private $call_name;
                private $definition;

                public function __construct($class, $method, $callable, $call_name)
                {
                    parent::__construct($class, $method);

                    $this->setAccessible(true); // 8.1 はデフォルトで true になるので模倣する
                    $this->callable = $callable;
                    $this->call_name = $call_name;
                }

                public function __invoke(...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->invoke($this->isStatic() ? null : $this->callable[0], ...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->getClosure($newThis ?? ($this->isStatic() ? null : $this->callable[0]))(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }
            };
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\concat') || (new \ReflectionFunction('ryunosuke\\ltsv\\concat'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\concat')) {
    /**
     * strcat の空文字回避版
     *
     * 基本は strcat と同じ。ただし、**引数の内1つでも空文字を含むなら空文字を返す**。
     * さらに*引数の内1つでも null を含むなら null を返す**。
     *
     * 「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。
     * コードで言えば `strlen($string) ? 'prefix-' . $string : '';` のようなもの。
     * 可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる。
     *
     * ```php
     * that(concat('prefix-', 'middle', '-suffix'))->isSame('prefix-middle-suffix');
     * that(concat('prefix-', '', '-suffix'))->isSame('');
     * that(concat('prefix-', null, '-suffix'))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param ?string ...$variadic 結合する文字列（可変引数）
     * @return ?string 結合した文字列
     */
    function concat(...$variadic)
    {
        if (count(array_filter($variadic, 'is_null')) > 0) {
            return null;
        }
        $result = '';
        foreach ($variadic as $s) {
            if (strlen($s) === 0) {
                return '';
            }
            $result .= $s;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\quoteexplode') || (new \ReflectionFunction('ryunosuke\\ltsv\\quoteexplode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\quoteexplode')) {
    /**
     * エスケープやクオートに対応した explode
     *
     * $enclosures は配列で開始・終了文字が別々に指定できるが、実装上の都合で今のところ1文字ずつのみ。
     *
     * Example:
     * ```php
     * // シンプルな例
     * that(quoteexplode(',', 'a,b,c\\,d,"e,f"'))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     'c\\,d', // \\ でエスケープしているので区切り文字とみなされない
     *     '"e,f"', // "" でクオートされているので区切り文字とみなされない
     * ]);
     *
     * // $enclosures で囲い文字の開始・終了文字を明示できる
     * that(quoteexplode(',', 'a,b,{e,f}', null, ['{' => '}']))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     '{e,f}', // { } で囲まれているので区切り文字とみなされない
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array $delimiter 分割文字列
     * @param string $string 対象文字列
     * @param ?int $limit 分割数。負数未対応
     * @param array|string $enclosures 囲い文字。 ["start" => "end"] で開始・終了が指定できる
     * @param string $escape エスケープ文字
     * @param array $options オプション
     * @return array 分割された配列
     */
    function quoteexplode($delimiter, ?string $string, $limit = null, $enclosures = "'\"", $escape = '\\', $options = [])
    {
        $options += [
            'delim-capture' => false, // デリミタも結果に含まれるようになる
        ];

        if ($limit === null) {
            $limit = PHP_INT_MAX;
        }
        $limit = max(1, $limit);

        $delimiters = arrayize($delimiter);
        $current = 0;
        $result = [];
        for ($i = 0, $l = strlen($string); $i < $l; $i++) {
            if (count($result) === $limit - 1) {
                break;
            }
            $i = strpos_quoted($string, $delimiters, $i, $enclosures, $escape);
            if ($i === null) {
                break;
            }
            foreach ($delimiters as $delimiter) {
                $delimiterlen = strlen($delimiter);
                if (substr_compare($string, $delimiter, $i, $delimiterlen) === 0) {
                    $result[] = substr($string, $current, $i - $current);
                    if ($options['delim-capture']) {
                        $result[] = $delimiter;
                    }
                    $current = $i + $delimiterlen;
                    $i += $delimiterlen - 1;
                    break;
                }
            }
        }
        $result[] = substr($string, $current, $l);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\split_noempty') || (new \ReflectionFunction('ryunosuke\\ltsv\\split_noempty'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\split_noempty')) {
    /**
     * 空文字を除外する文字列分割
     *
     * - 空文字を任意の区切り文字で分割しても常に空配列
     * - キーは連番で返す（歯抜けがないただの配列）
     *
     * $triming を指定した場合、結果配列にも影響する。
     * つまり「除外は trim したいが結果配列にはしたくない」はできない。
     *
     * Example:
     * ```php
     * that(split_noempty(',', 'a, b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c', false))->isSame(['a', ' ', ' ', ' b', ' c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $delimiter 区切り文字
     * @param string $string 対象文字
     * @param string|bool $trimchars 指定した文字を trim する。true を指定すると trim する
     * @return array 指定文字で分割して空文字を除いた配列
     */
    function split_noempty(?string $delimiter, ?string $string, $trimchars = true)
    {
        // trim しないなら preg_split(PREG_SPLIT_NO_EMPTY) で十分
        if (strlen($trimchars) === 0) {
            return preg_split('#' . preg_quote($delimiter, '#') . '#u', $string, -1, PREG_SPLIT_NO_EMPTY);
        }

        // trim するなら preg_split だと無駄にややこしくなるのでベタにやる
        $trim = ($trimchars === true) ? 'trim' : fn($v) => trim($v, $trimchars);
        $parts = explode($delimiter, $string);
        $parts = array_map($trim, $parts);
        $parts = array_filter($parts, 'strlen');
        $parts = array_values($parts);
        return $parts;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_exists') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_exists')) {
    /**
     * 指定文字列を含むか返す
     *
     * Example:
     * ```php
     * that(str_exists('abc', 'b'))->isTrue();
     * that(str_exists('abc', 'B', true))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, false))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 調べる文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @param bool $and_flag すべて含む場合に true を返すか
     * @return bool $needle を含むなら true
     */
    function str_exists(?string $haystack, $needle, $case_insensitivity = false, $and_flag = false)
    {
        if (!is_array($needle)) {
            $needle = [$needle];
        }

        $needle = array_map('strval', $needle);

        foreach ($needle as $str) {
            if ($str === '') {
                continue;
            }
            $pos = $case_insensitivity ? stripos($haystack, $str) : strpos($haystack, $str);
            if ($and_flag && $pos === false) {
                return false;
            }
            if (!$and_flag && $pos !== false) {
                return true;
            }
        }
        return !!$and_flag;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_quote') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_quote')) {
    /**
     * 文字列をダブルクォート文字列に変換する
     *
     * 文字ではうまく表現できないが、例えば「本当の改行」が \n になり、「本当のタブ文字」が \t になる。
     * コントロール文字は "\code" 形式のようになる。
     * 「得られた文字列は eval すると元に戻る」とでも言えばいいか。
     *
     * 制御文字をそのまま出力するとまずい状況が稀によくある（特に行指向媒体への改行文字）。
     * この関数を通せば php の文字列の体裁を保ったまま1行化できる。
     * 端的に言えば var_export の文字列特化版。
     *
     * 挙動は $options である程度制御可能。
     * 各 $options は原則的に文字のマップか true を渡す（true の場合はデフォルトが使用される）。
     * 一部、それ以外の値・型に対応しているものもある。
     *
     * - escape-character: 制御文字のうち、明確なエスケープシーケンスが存在する場合はそれを使用する
     *   - control-character にオーバーラップするがこちらが優先される
     * - control-character: 00 ～ 1F+7F の制御文字を \code 形式にする
     *   - 文字列で "oct", "hex", "HEX" も指定できる。その場合それぞれ \oct, \xhex, \xHEX 形式になる
     * - special-character: ダブルクオート内の文字列が文字列であるための変換を行う
     *   - 原則的にデフォルトに任せて指定すべきではない
     *
     * Example:
     * ```php
     * // （非常に分かりにくいが）下記のように変換される
     * that(str_quote("\$a\nb\rc\x00"))->isSame("\"\\\$a\\nb\\rc\\0\"");
     * // 文字としての意味は一緒であり要するに表現形式の違いなので、php の世界で eval すれば元の文字列に戻る
     * that(eval('return ' . str_quote("\$a\nb\rc\x00") . ';'))->isSame("\$a\nb\rc\x00");
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $options オプション配列
     * @return string クォート文字列
     */
    function str_quote(string $string, array $options = []): string
    {
        $options += [
            'escape-character'  => true,
            'control-character' => true,
            'special-character' => true,
            'heredoc'           => '',
            'nowdoc'            => '',
            'indent'            => 0,
        ];

        assert(!($options['heredoc'] && $options['nowdoc']));

        // nowdoc にエスケープは存在しないのでそのまま埋め込む（その結果壊れてもこの関数の責務ではない）
        if (strlen($options['nowdoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<'{$options['nowdoc']}'\n{$indent}{$string}\n{$indent}{$options['nowdoc']}";
        }

        // @see https://www.php.net/manual/ja/language.types.string.php#language.types.string.syntax.double
        $special_chars = [
            '\\' => '\\\\', // バックスラッシュ
            '"'  => '\\"',  // 二重引用符
            '$'  => '\\$',  // ドル記号
        ];
        $escape_chars = [
            "\11" => '\\t', // 水平タブ (HT またはアスキーの 0x09 (9))
            "\12" => '\\n', // ラインフィード (LF またはアスキーの 0x0A (10))
            "\13" => '\\v', // 垂直タブ (VT またはアスキーの 0x0B (11))
            "\14" => '\\f', // フォームフィード (FF またはアスキーの 0x0C (12))
            "\15" => '\\r', // キャリッジリターン (CR またはアスキーの 0x0D (13))
            "\33" => '\\e', // エスケープ (ESC あるいはアスキーの 0x1B (27))
        ];
        $control_chars = [
            "\0"   => "\\0",
            "\1"   => "\\1",
            "\2"   => "\\2",
            "\3"   => "\\3",
            "\4"   => "\\4",
            "\5"   => "\\5",
            "\6"   => "\\6",
            "\7"   => "\\7",
            "\10"  => "\\10",
            "\11"  => "\\11",
            "\12"  => "\\12",
            "\13"  => "\\13",
            "\14"  => "\\14",
            "\15"  => "\\15",
            "\16"  => "\\16",
            "\17"  => "\\17",
            "\20"  => "\\20",
            "\21"  => "\\21",
            "\22"  => "\\22",
            "\23"  => "\\23",
            "\24"  => "\\24",
            "\25"  => "\\25",
            "\26"  => "\\26",
            "\27"  => "\\27",
            "\30"  => "\\30",
            "\31"  => "\\31",
            "\32"  => "\\32",
            "\33"  => "\\33",
            "\34"  => "\\34",
            "\35"  => "\\35",
            "\36"  => "\\36",
            "\37"  => "\\37",
            "\177" => "\\177",
        ];

        // heredoc 用の特殊処理（タイプ可能な文字はエスケープしなくてもよいだろう）
        if (strlen($options['heredoc'])) {
            $control_chars = array_diff_key($control_chars, $escape_chars);
            $escape_chars = [];
            unset($special_chars['"']);
        }

        $charmap = [];
        if ($options['special-character']) {
            $charmap += is_array($options['special-character']) ? $options['special-character'] : $special_chars;
        }
        if ($options['escape-character']) {
            $charmap += is_array($options['escape-character']) ? $options['escape-character'] : $escape_chars;
        }
        if ($options['control-character']) {
            if ($options['control-character'] === 'oct') {
                // デフォで oct にしてあるので変換不要
                assert(end($control_chars) === "\\177");
            }
            if ($options['control-character'] === 'hex') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02x', octdec(trim($v, '\\'))), $control_chars);
            }
            if ($options['control-character'] === 'HEX') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02X', octdec(trim($v, '\\'))), $control_chars);
            }
            $charmap += is_array($options['control-character']) ? $options['control-character'] : $control_chars;
        }

        $string = strtr($string, $charmap);

        if (strlen($options['heredoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<{$options['heredoc']}\n{$indent}{$string}\n{$indent}{$options['heredoc']}";
        }

        return '"' . $string . '"';
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strpos_quoted') || (new \ReflectionFunction('ryunosuke\\ltsv\\strpos_quoted'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strpos_quoted')) {
    /**
     * クオートを考慮して strpos する
     *
     * Example:
     * ```php
     * // クオート中は除外される
     * that(strpos_quoted('hello "this" is world', 'is'))->isSame(13);
     * // 開始位置やクオート文字は指定できる（5文字目以降の \* に囲まれていない hoge の位置を返す）
     * that(strpos_quoted('1:hoge, 2:*hoge*, 3:hoge', 'hoge', 5, '*'))->isSame(20);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|iterable $needle 位置を取得したい文字列
     * @param int $offset 開始位置
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @param ?string $found $needle の内、見つかった文字列が格納される
     * @return ?int $needle の位置
     */
    function strpos_quoted(?string $haystack, $needle, $offset = 0, $enclosure = "'\"", $escape = '\\', &$found = null)
    {
        if (is_string($enclosure)) {
            if (strlen($enclosure)) {
                $chars = str_split($enclosure);
                $enclosure = array_combine($chars, $chars);
            }
            else {
                $enclosure = [];
            }
        }
        $needles = arrayval($needle, false);

        $strlen = strlen($haystack);

        if ($offset < 0) {
            $offset += $strlen;
        }

        $found = null;
        $enclosing = [];
        for ($i = $offset; $i < $strlen; $i++) {
            if ($i !== 0 && $haystack[$i - 1] === $escape) {
                continue;
            }
            foreach ($enclosure as $start => $end) {
                if (substr_compare($haystack, $end, $i, strlen($end)) === 0) {
                    if ($enclosing && $enclosing[count($enclosing) - 1] === $end) {
                        array_pop($enclosing);
                        $i += strlen($end) - 1;
                        continue 2;
                    }
                }
                if (substr_compare($haystack, $start, $i, strlen($start)) === 0) {
                    $enclosing[] = $end;
                    $i += strlen($start) - 1;
                    continue 2;
                }
            }

            if (empty($enclosing)) {
                foreach ($needles as $needle) {
                    if (substr_compare($haystack, $needle, $i, strlen($needle)) === 0) {
                        $found = $needle;
                        return $i;
                    }
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\base64url_encode') || (new \ReflectionFunction('ryunosuke\\ltsv\\base64url_encode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\base64url_encode')) {
    /**
     * url safe な base64_encode
     *
     * れっきとした RFC があるのかは分からないが '+' => '-', '/' => '_' がデファクトだと思うのでそのようにしてある。
     * パディングの = も外す。
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $string 変換元文字列
     * @return string base64url 文字列
     */
    function base64url_encode($string)
    {
        return rtrim(strtr(base64_encode($string), ['+' => '-', '/' => '_']), '=');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\query_build') || (new \ReflectionFunction('ryunosuke\\ltsv\\query_build'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\query_build')) {
    /**
     * 数値キーを削除する http_build_query
     *
     * php の世界において配列のクエリ表現は `var[]=1&var[]=2` で事足りる。
     * しかし http_build_query では数値キーでも必ず `var[0]=1&var[1]=2` になる。
     * それはそれで正しいし、他言語との連携が必要な場合はそうせざるを得ない状況もあるが、単純に php だけで配列を表したい場合は邪魔だし文字長が長くなる。
     * この関数を使うと数値キーを削除し、`var[]=1&var[]=2` のようなクエリ文字列を生成できる。
     *
     * シグネチャは http_build_query と同じで、 $numeric_prefix に数値的文字列を与えたときのみ動作が変化する。
     * （$numeric_prefix の意味を考えればこの引数に数値的文字列を与える意味は皆無だろうので流用している）。
     *
     * - 1 を与えると最前列を残して [] (%5B%5D) が置換される
     * - 2 を与えると最前列とその右を残して [] (%5B%5D) が置換される
     * - 要するに正数を与えると「abs(n) 個を残して [] (%5B%5D) を置換する」という指定になる
     * - -1 を与えると最後尾の [] (%5B%5D) が置換される
     * - -2 を与えると最後尾とその左の [] (%5B%5D) が置換される
     * - 要するに負数を与えると「右から abs(n) 個の [] (%5B%5D) を置換する」という指定になる
     *
     * この仕様は `v[][]=1&v[][]=2` のようなときにおいしくないためである。
     * これは `$v=[[1], [2]]` のような値になるが、この場合 `$v=[[1, 2]]` という値が欲しい、という事が多い。
     * そのためには `v[0][]=1&v[0][]=2` のようにする必要があるための数値指定である。
     *
     * $brackets で配列ブラケット文字を指定できるが、現実的には下記の3択だろう。
     * - ['%5B','%5D']: デフォルトのパーセントエンコーディング文字
     * - ['[', ']']: [] のままにする（ブラケットは必ずしもパーセントエンコーディングが必須ではない）
     * - ['', '']: ブラケットを削除する（他言語のために配列パラメータを抑止したいことがある）
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param array|object $data クエリデータ
     * @param string|int|null $numeric_prefix 数値キープレフィックス
     * @param string|null $arg_separator クエリセパレータ
     * @param int $encoding_type エンコードタイプ
     * @param string[]|string|null $brackets 配列ブラケット文字
     * @return string クエリ文字列
     */
    function query_build($data, $numeric_prefix = null, $arg_separator = null, $encoding_type = \PHP_QUERY_RFC1738, $brackets = null)
    {
        $data = arrayval($data, false);
        if (!$data) {
            return '';
        }

        $arg_separator ??= ini_get('arg_separator.output');
        $brackets ??= ['%5B', '%5D'];

        if (!is_array($brackets)) {
            $brackets = [$brackets, ''];
        }
        $brackets = array_values($brackets);

        $REGEX = '%5B\d+%5D';
        $NOSEQ = implode('', $brackets);
        if ($numeric_prefix === null || ctype_digit(trim($numeric_prefix, '-+'))) {
            $queries = explode($arg_separator, http_build_query($data, '', $arg_separator, $encoding_type));
        }
        else {
            $queries = explode($arg_separator, http_build_query($data, $numeric_prefix, $arg_separator, $encoding_type));
        }
        foreach ($queries as &$q) {
            [$k, $v] = explode('=', $q, 2);

            // 0は置換しないを意味する
            if ($numeric_prefix === 0) {
                // do nothing
                assert($numeric_prefix === 0);
            }
            // null は無制限置換
            elseif ($numeric_prefix === null) {
                $k = preg_replace("#$REGEX#u", $NOSEQ, $k);
            }
            else {
                $count = $numeric_prefix > 0 ? 0 : -preg_match_all("#$REGEX#u", $k);
                $k = preg_replace_callback("#$REGEX#u", function ($m) use (&$count, $numeric_prefix, $NOSEQ) {
                    return $count++ >= $numeric_prefix ? $NOSEQ : $m[0];
                }, $k);
            }

            $k = str_replace(['%5B', '%5D'], $brackets, $k);

            $q = "$k=$v";
        }

        return implode($arg_separator, $queries);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\uri_build') || (new \ReflectionFunction('ryunosuke\\ltsv\\uri_build'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\uri_build')) {
    /**
     * parse_uri の逆
     *
     * URI のパーツを与えると URI として構築する。
     * パーツは不完全でも良い。例えば scheme を省略すると "://" すら付かない URI が生成される。
     *
     * "query" パートだけは配列が許容される。その場合クエリ文字列に変換される。
     *
     * Example:
     * ```php
     * // 完全指定
     * that(uri_build([
     *     'scheme'   => 'http',
     *     'user'     => 'user',
     *     'pass'     => 'pass',
     *     'host'     => 'localhost',
     *     'port'     => '80',
     *     'path'     => '/path/to/file',
     *     'query'    => ['id' => 1],
     *     'fragment' => 'hash',
     * ]))->isSame('http://user:pass@localhost:80/path/to/file?id=1#hash');
     * // 一部だけ指定
     * that(uri_build([
     *     'scheme'   => 'http',
     *     'host'     => 'localhost',
     *     'path'     => '/path/to/file',
     *     'fragment' => 'hash',
     * ]))->isSame('http://localhost/path/to/file#hash');
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param array $parts URI の各パーツ配列
     * @param array $options オプション
     * @return string URI 文字列
     */
    function uri_build($parts, $options = [])
    {
        $parts += [
            'scheme'   => '',
            'user'     => '',
            'pass'     => '',
            'host'     => '',
            'port'     => '',
            'path'     => '',
            'query'    => '',
            'fragment' => '',
        ];
        $options = array_replace_recursive([
            'query' => [
                'index'     => 0,
                'bracket'   => null,
                'separator' => ini_get('arg_separator.output'),
            ],
        ], $options);

        $parts['user'] = rawurlencode($parts['user']);
        $parts['pass'] = rawurlencode($parts['pass']);
        $parts['host'] = filter_var($parts['host'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? "[{$parts['host']}]" : $parts['host'];
        $parts['path'] = ltrim($parts['path'], '/');
        if (is_array($parts['query'])) {
            $parts['query'] = query_build(
                $parts['query'],
                $options['query']['index'],
                $options['query']['separator'],
                \PHP_QUERY_RFC1738,
                $options['query']['bracket'],
            );
        }

        $uri = '';
        $uri .= concat($parts['scheme'], '://');
        $uri .= concat($parts['user'] . concat(':', $parts['pass']), '@');
        $uri .= concat($parts['host']);
        $uri .= concat(':', $parts['port']);
        $uri .= concat('/', $parts['path']);
        $uri .= concat('?', $parts['query']);
        $uri .= concat('#', rawurlencode($parts['fragment']));
        return $uri;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\uri_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\uri_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\uri_parse')) {
    /**
     * parse_url の仕様を少しいじったもの
     *
     * parse_url とは下記が異なる。
     *
     * - "単一文字列" はホスト名とみなされる（parse_url はパスとみなされる）
     * - パートがなくてもキー自体は生成される（そしてその値は $default で指定したもの）
     * - query は配列で返す（parse_str される）
     * - パート値をスカラー値で返すことはできない（必ず8要素の配列を返す）
     *
     * Example:
     * ```php
     * // 完全指定
     * that(uri_parse('http://user:pass@localhost:80/path/to/file?id=1#hash'))->is([
     *     'scheme'   => 'http',
     *     'user'     => 'user',
     *     'pass'     => 'pass',
     *     'host'     => 'localhost',
     *     'port'     => '80',
     *     'path'     => '/path/to/file',
     *     'query'    => ['id' => 1],
     *     'fragment' => 'hash',
     * ]);
     * // デフォルト値つき
     * that(uri_parse('localhost/path/to/file', [
     *     'scheme'   => 'http', // scheme のデフォルト値
     *     'user'     => 'user', // user のデフォルト値
     *     'port'     => '8080', // port のデフォルト値
     *     'host'     => 'hoge', // host のデフォルト値
     * ]))->is([
     *     'scheme'   => 'http',      // scheme はないのでデフォルト値が使われている
     *     'user'     => 'user',      // user はないのでデフォルト値が使われている
     *     'pass'     => '',
     *     'host'     => 'localhost', // host はあるのでデフォルト値が使われていない
     *     'port'     => '8080',      // port はないのでデフォルト値が使われている
     *     'path'     => '/path/to/file',
     *     'query'    => [],
     *     'fragment' => '',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $uri パースする URI
     * @param array|string $default $uri に足りないパーツがあった場合のデフォルト値。文字列を与えた場合はそのパース結果がデフォルト値になる
     * @return array URI の各パーツ配列
     */
    function uri_parse($uri, $default = [])
    {
        /** @noinspection RequiredAttributes */
        $regex = "
            (?:(?<scheme>[a-z][-+.0-9a-z]*)://)?
            (?:
              (?: (?<user>(?:[-.~\\w]|%[0-9a-f][0-9a-f]|[!$&-,;=])*)?
              (?::(?<pass>(?:[-.~\\w]|%[0-9a-f][0-9a-f]|[!$&-,;=])*))?@)?
            )?
            (?<host>((?:\\[[0-9a-f:]+\\]) | (?:[-.~\\w]|%[0-9a-f][0-9a-f]|[!$&-,;=]))*)
            (?::(?<port>\d{0,5}))?
            (?<path>(?:/(?: [-.~\\w!$&'()*+,;=:@] | %[0-9a-f]{2} )* )*)?
            (?:\\?(?<query>[^\\#]*))?
            (?:\\#(?<fragment>.*))?
        ";

        $default_default = [
            'scheme'   => '',
            'user'     => '',
            'pass'     => '',
            'host'     => '',
            'port'     => '',
            'path'     => '',
            'query'    => '',
            'fragment' => '',
        ];

        // 配列以外はパースしてそれをデフォルトとする
        if (!is_array($default)) {
            $default = preg_capture("#^$regex\$#ix", (string) $default, $default_default);
        }

        // パース。先頭の // はスキーム省略とみなすので除去する
        $uri = preg_splice('#^//#', '', $uri);
        $parts = preg_capture("#^$regex\$#ix", $uri, $default + $default_default);

        // 諸々調整（認証エンコード、IPv6、パス / の正規化、クエリ配列化）
        $parts['user'] = $parts['user'] === null ? null : rawurldecode($parts['user']);
        $parts['pass'] = $parts['pass'] === null ? null : rawurldecode($parts['pass']);
        $parts['host'] = $parts['host'] === null ? null : preg_splice('#^\\[(.+)]$#', '$1', $parts['host']);
        $parts['path'] = $parts['path'] === null ? null : rawurldecode(concat('/', ltrim($parts['path'], '/')));
        $parts['fragment'] = $parts['fragment'] === null ? null : rawurldecode($parts['fragment']);

        if (is_string($parts['query'])) {
            parse_str($parts['query'], $parts['query']);
        }

        return $parts;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cache') || (new \ReflectionFunction('ryunosuke\\ltsv\\cache'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cache')) {
    /**
     * シンプルにキャッシュする
     *
     * この関数は get/set/delete を兼ねる。
     * キャッシュがある場合はそれを返し、ない場合は $provider を呼び出してその結果をキャッシュしつつそれを返す。
     *
     * $provider に null を与えるとキャッシュの削除となる。
     *
     * Example:
     * ```php
     * $provider = fn() => rand();
     * // 乱数を返す処理だが、キャッシュされるので同じ値になる
     * $rand1 = cache('rand', $provider);
     * $rand2 = cache('rand', $provider);
     * that($rand1)->isSame($rand2);
     * // $provider に null を与えると削除される
     * cache('rand', null);
     * $rand3 = cache('rand', $provider);
     * that($rand1)->isNotSame($rand3);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param string $key キャッシュのキー
     * @param ?callable $provider キャッシュがない場合にコールされる callable
     * @param ?string $namespace 名前空間
     * @return mixed キャッシュ
     */
    function cache($key, $provider, $namespace = null)
    {
        static $cacheobject;
        $cacheobject ??= new class(function_configure('cachedir')) {
            const CACHE_EXT = '.php-cache';

            /** @var string キャッシュディレクトリ */
            private $cachedir;

            /** @var array 内部キャッシュ */
            private $cache;

            /** @var array 変更感知配列 */
            private $changed;

            public function __construct($cachedir)
            {
                $this->cachedir = $cachedir;
                $this->cache = [];
                $this->changed = [];
            }

            public function __destruct()
            {
                // 変更されているもののみ保存
                foreach ($this->changed as $namespace => $dummy) {
                    $filepath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    $content = "<?php\nreturn " . var_export($this->cache[$namespace], true) . ";\n";

                    $temppath = tempnam(sys_get_temp_dir(), 'cache');
                    if (file_put_contents($temppath, $content) !== false) {
                        @chmod($temppath, 0644);
                        if (!@rename($temppath, $filepath)) {
                            @unlink($temppath); // @codeCoverageIgnore
                        }
                    }
                }
            }

            public function has($namespace, $key)
            {
                // ファイルから読み込む必要があるので get しておく
                $this->get($namespace, $key);
                return array_key_exists($key, $this->cache[$namespace]);
            }

            public function get($namespace, $key)
            {
                // 名前空間自体がないなら作る or 読む
                if (!isset($this->cache[$namespace])) {
                    $nsarray = [];
                    $cachpath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    if (file_exists($cachpath)) {
                        $nsarray = require $cachpath;
                    }
                    $this->cache[$namespace] = $nsarray;
                }

                return $this->cache[$namespace][$key] ?? null;
            }

            public function set($namespace, $key, $value)
            {
                // 新しい値が来たら変更フラグを立てる
                if (!isset($this->cache[$namespace]) || !array_key_exists($key, $this->cache[$namespace]) || $this->cache[$namespace][$key] !== $value) {
                    $this->changed[$namespace] = true;
                }

                $this->cache[$namespace][$key] = $value;
            }

            public function delete($namespace, $key)
            {
                $this->changed[$namespace] = true;
                unset($this->cache[$namespace][$key]);
            }

            public function clear()
            {
                // インメモリ情報をクリアして・・・
                $this->cache = [];
                $this->changed = [];

                // ファイルも消す
                foreach (glob($this->cachedir . '/*' . self::CACHE_EXT) as $file) {
                    unlink($file);
                }
            }
        };

        // flush (for test)
        if ($key === null) {
            if ($provider === null) {
                $cacheobject->clear();
            }
            $cacheobject = null;
            return;
        }

        $namespace ??= __FILE__;

        $exist = $cacheobject->has($namespace, $key);
        if ($provider === null) {
            $cacheobject->delete($namespace, $key);
            return $exist;
        }
        if (!$exist) {
            $cacheobject->set($namespace, $key, $provider());
        }
        return $cacheobject->get($namespace, $key);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\function_configure') || (new \ReflectionFunction('ryunosuke\\ltsv\\function_configure'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\function_configure')) {
    /**
     * 本ライブラリの設定を行う
     *
     * 各関数の挙動を変えたり、デフォルトオプションを設定できる。
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param array|?string $option 設定。文字列指定時はその値を返す
     * @return array|string 設定値
     */
    function function_configure($option)
    {
        static $config = [];

        // default
        $config['cachedir'] ??= sys_get_temp_dir() . DIRECTORY_SEPARATOR . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['storagedir'] ??= DIRECTORY_SEPARATOR === '/' ? '/var/tmp/rf' : (getenv('ALLUSERSPROFILE') ?: sys_get_temp_dir()) . '\\rf';
        $config['placeholder'] ??= '';
        $config['var_stream'] ??= 'VarStreamV010000';
        $config['memory_stream'] ??= 'MemoryStreamV010000';
        $config['array.variant'] ??= false;
        $config['chain.version'] ??= 2;
        $config['chain.nullsafe'] ??= false;
        $config['process.autoload'] ??= [];

        // setting
        if (is_array($option)) {
            foreach ($option as $name => $entry) {
                $option[$name] = $config[$name] ?? null;
                switch ($name) {
                    default:
                        $config[$name] = $entry;
                        break;
                    case 'cachedir':
                    case 'storagedir':
                        $entry ??= $config[$name];
                        if (!file_exists($entry)) {
                            @mkdir($entry, 0777 & (~umask()), true);
                        }
                        $config[$name] = realpath($entry);
                        break;
                    case 'placeholder':
                        if (strlen($entry)) {
                            $entry = ltrim($entry[0] === '\\' ? $entry : __NAMESPACE__ . '\\' . $entry, '\\');
                            if (!defined($entry)) {
                                define($entry, tmpfile() ?: [] ?: '' ?: 0.0 ?: null ?: false);
                            }
                            if (!is_resourcable(constant($entry))) {
                                // もしリソースじゃないと一意性が保てず致命的になるので例外を投げる
                                throw new \RuntimeException('placeholder is not resource'); // @codeCoverageIgnore
                            }
                            $config[$name] = $entry;
                        }
                        break;
                }
            }
            return $option;
        }

        // getting
        if ($option === null) {
            return $config;
        }
        if (is_string($option)) {
            switch ($option) {
                default:
                    return $config[$option] ?? null;
                case 'cachedir':
                case 'storagedir':
                    $dirname = $config[$option];
                    if (!file_exists($dirname)) {
                        @mkdir($dirname, 0777 & (~umask()), true); // @codeCoverageIgnore
                    }
                    return realpath($dirname);
            }
        }

        throw new \InvalidArgumentException(sprintf('$option is unknown type(%s)', gettype($option)));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arrayval') || (new \ReflectionFunction('ryunosuke\\ltsv\\arrayval'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arrayval')) {
    /**
     * array キャストの関数版
     *
     * intval とか strval とかの array 版。
     * ただキャストするだけだが、関数なのでコールバックとして使える。
     *
     * $recursive を true にすると再帰的に適用する（デフォルト）。
     * 入れ子オブジェクトを配列化するときなどに使える。
     *
     * Example:
     * ```php
     * // キャストなので基本的には配列化される
     * that(arrayval(123))->isSame([123]);
     * that(arrayval('str'))->isSame(['str']);
     * that(arrayval([123]))->isSame([123]); // 配列は配列のまま
     *
     * // $recursive = false にしない限り再帰的に適用される
     * $stdclass = (object) ['key' => 'val'];
     * that(arrayval([$stdclass], true))->isSame([['key' => 'val']]); // true なので中身も配列化される
     * that(arrayval([$stdclass], false))->isSame([$stdclass]);       // false なので中身は変わらない
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var array 化する値
     * @param bool $recursive 再帰的に行うなら true
     * @return array array 化した配列
     */
    function arrayval($var, $recursive = true)
    {
        // return json_decode(json_encode($var), true);

        // 無駄なループを回したくないので非再帰で配列の場合はそのまま返す
        if (!$recursive && is_array($var)) {
            return $var;
        }

        if (is_primitive($var)) {
            return (array) $var;
        }

        $result = [];
        foreach ($var as $k => $v) {
            if ($recursive && !is_primitive($v)) {
                $v = arrayval($v, $recursive);
            }
            $result[$k] = $v;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_empty') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_empty'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_empty')) {
    /**
     * 値が空か検査する
     *
     * `empty` とほぼ同じ。ただし
     *
     * - string: "0"
     * - countable でない object
     * - countable である object で count() > 0
     *
     * は false 判定する。
     * ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。
     * これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。
     * （例えば `json_decode('{}')` は stdClass を返すが、このような状況は空判定したいことが多いだろう）。
     *
     * なお、関数の仕様上、未定義変数を true 判定することはできない。
     * 未定義変数をチェックしたい状況は大抵の場合コードが悪いが `$array['key1']['key2']` を調べたいことはある。
     * そういう時には使えない（?? する必要がある）。
     *
     * 「 `if ($var) {}` で十分なんだけど "0" が…」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // この辺は empty と全く同じ
     * that(is_empty(null))->isTrue();
     * that(is_empty(false))->isTrue();
     * that(is_empty(0))->isTrue();
     * that(is_empty(''))->isTrue();
     * // この辺だけが異なる
     * that(is_empty('0'))->isFalse();
     * // 第2引数に true を渡すと空の stdClass も empty 判定される
     * $stdclass = new \stdClass();
     * that(is_empty($stdclass, true))->isTrue();
     * // フィールドがあれば empty ではない
     * $stdclass->hoge = 123;
     * that(is_empty($stdclass, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 判定する値
     * @param bool $empty_stdClass 空の stdClass を空とみなすか
     * @return bool 空なら true
     */
    function is_empty($var, $empty_stdClass = false)
    {
        // object は is_countable 次第
        if (is_object($var)) {
            // が、 stdClass だけは特別扱い（stdClass は継承もできるので、クラス名で判定する（継承していたらそれはもう stdClass ではないと思う））
            if ($empty_stdClass && get_class($var) === 'stdClass') {
                return !(array) $var;
            }
            if (is_countable($var)) {
                return !count($var);
            }
            return false;
        }

        // "0" は false
        if ($var === '0') {
            return false;
        }

        // 上記以外は empty に任せる
        return empty($var);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_primitive') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_primitive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_primitive')) {
    /**
     * 値が複合型でないか検査する
     *
     * 「複合型」とはオブジェクトと配列のこと。
     * つまり
     *
     * - is_scalar($var) || is_null($var) || is_resource($var)
     *
     * と同義（!is_array($var) && !is_object($var) とも言える）。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 複合型なら false
     */
    function is_primitive($var)
    {
        return is_scalar($var) || is_null($var) || is_resourcable($var);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_resourcable') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_resourcable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_resourcable')) {
    /**
     * 閉じたリソースでも true を返す is_resource
     *
     * マニュアル（ https://www.php.net/manual/ja/function.is-resource.php ）に記載の通り、 isresource は閉じたリソースで false を返す。
     * リソースはリソースであり、それでは不便なこともあるので、閉じていようとリソースなら true を返す関数。
     *
     * Example:
     * ```php
     * // 閉じたリソースを用意
     * $resource = tmpfile();
     * fclose($resource);
     * // is_resource は false を返すが・・・
     * that(is_resource($resource))->isFalse();
     * // is_resourcable は true を返す
     * that(is_resourcable($resource))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool リソースなら true
     */
    function is_resourcable($var)
    {
        if (is_resource($var)) {
            return true;
        }
        // もっといい方法があるかもしれないが、簡単に調査したところ gettype するしか術がないような気がする
        if (strpos(gettype($var), 'resource') === 0) {
            return true;
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_stringable') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_stringable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_stringable')) {
    /**
     * 変数が文字列化できるか調べる
     *
     * 「配列」「__toString を持たないオブジェクト」が false になる。
     * （厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。
     *
     * Example:
     * ```php
     * // こいつらは true
     * that(is_stringable(null))->isTrue();
     * that(is_stringable(true))->isTrue();
     * that(is_stringable(3.14))->isTrue();
     * that(is_stringable(STDOUT))->isTrue();
     * that(is_stringable(new \Exception()))->isTrue();
     * // こいつらは false
     * that(is_stringable(new \ArrayObject()))->isFalse();
     * that(is_stringable([1, 2, 3]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 文字列化できるなら true
     */
    function is_stringable($var)
    {
        if (is_array($var)) {
            return false;
        }
        if (is_object($var) && !method_exists($var, '__toString')) {
            return false;
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_export2') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_export2'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_export2')) {
    /**
     * 組み込みの var_export をいい感じにしたもの
     *
     * 下記の点が異なる。
     *
     * - 配列は 5.4 以降のショートシンタックス（[]）で出力
     * - ただの配列は1行（[1, 2, 3]）でケツカンマなし、連想配列は桁合わせインデントでケツカンマあり
     * - 文字列はダブルクオート
     * - null は null（小文字）
     * - 再帰構造を渡しても警告がでない（さらに NULL ではなく `'*RECURSION*'` という文字列になる）
     * - 配列の再帰構造の出力が異なる（Example参照）
     *
     * Example:
     * ```php
     * // 単純なエクスポート
     * that(var_export2(['array' => [1, 2, 3], 'hash' => ['a' => 'A', 'b' => 'B', 'c' => 'C']], true))->isSame('[
     *     "array" => [1, 2, 3],
     *     "hash"  => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     * ]');
     * // 再帰構造を含むエクスポート（標準の var_export は形式が異なる。 var_export すれば分かる）
     * $rarray = [];
     * $rarray['a']['b']['c'] = &$rarray;
     * $robject = new \stdClass();
     * $robject->a = new \stdClass();
     * $robject->a->b = new \stdClass();
     * $robject->a->b->c = $robject;
     * that(var_export2(compact('rarray', 'robject'), true))->isSame('[
     *     "rarray"  => [
     *         "a" => [
     *             "b" => [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     *     "robject" => (object) [
     *         "a" => (object) [
     *             "b" => (object) [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     * ]');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     * @param bool|array $options オプション配列（var_export に寄せるため bool も受け付ける）
     * @return string|null $return=true の場合は出力せず結果を返す
     */
    function var_export2($value, $options = [])
    {
        if (!is_array($options)) {
            $options = [
                'return' => !!$options,
            ];
        }

        $options += [
            'minify' => false, // 短縮形で返す（実質的には情報を減らして1行で返す）
            'indent' => 4,     // インデントの空白数
            'return' => false, // 値を戻すか出力するか
        ];

        // 再帰用クロージャ
        $export = function ($value, $context, $nest = 0, $parents = []) use (&$export, $options) {
            // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
            foreach ($parents as $parent) {
                if ($parent === $value) {
                    return $export('*RECURSION*', 'recursion');
                }
            }

            $space = $options['minify'] ? "" : " ";
            $break = $options['minify'] ? "" : "\n";

            // 配列は連想判定したり再帰したり色々
            if (is_array($value)) {
                $spacer1 = str_repeat($space, ($nest + 1) * $options['indent']);
                $spacer2 = str_repeat($space, $nest * $options['indent']);

                $hashed = is_hasharray($value);

                // スカラー値のみで構成されているならシンプルな再帰
                if (!$hashed && array_all($value, fn(...$args) => is_primitive(...$args))) {
                    return '[' . implode(",$space", array_map(fn($v) => $export($v, 'array-value'), $value)) . ']';
                }

                // 連想配列はキーを含めて桁あわせ
                if ($hashed) {
                    $keys = array_map(fn($v) => $export($v, 'array-key'), array_combine($keys = array_keys($value), $keys));
                    $maxlen = max(array_map('strlen', $keys));
                }
                $kvl = '';
                $lastkey = array_key_last($value);
                $parents[] = $value;
                foreach ($value as $k => $v) {
                    $keystr = $hashed ? $keys[$k] . str_repeat($space, $maxlen - strlen($keys[$k])) . "$space=>$space" : '';
                    $kvl .= $spacer1 . $keystr . $export($v, 'array-value', $nest + 1, $parents) . ($k === $lastkey && $options['minify'] ? "" : ",") . "$break";
                }
                return "[$break{$kvl}{$spacer2}]";
            }
            // オブジェクトは単にプロパティを __set_state する文字列を出力する
            elseif (is_object($value)) {
                $parents[] = $value;
                $classname = get_class($value);
                if ($classname === \stdClass::class) {
                    return "(object)$space" . $export((array) $value, 'object', $nest, $parents);
                }
                return $classname . '::__set_state(' . $export(object_properties($value), 'object', $nest, $parents) . ')';
            }
            // 文字列はダブルクオート（場合によってはヒアドキュメント）
            elseif (is_string($value)) {
                // 列揃えのため配列のキーは常にダブルクォート
                if ($context === 'array-key') {
                    return str_quote($value);
                }
                // 改行を含むならヒアドキュメント
                if (!$options['minify'] && str_exists($value, ["\r", "\n"])) {
                    // ただし、改行文字だけの場合は除く（何らかの引数で改行文字だけを渡すシチュエーションはそれなりにあるのでヒアドキュメントだと冗長）
                    if (trim($value, "\r\n") !== '') {
                        return str_quote($value, [
                            'heredoc' => unique_string($value, 'TEXT', '_'),
                            'indent'  => $nest * $options['indent'],
                        ]);
                    }
                }
                return str_quote($value);
            }
            // null は小文字で居て欲しい
            elseif (is_null($value)) {
                return 'null';
            }
            // それ以外は標準に従う
            else {
                return var_export($value, true);
            }
        };

        // 結果を返したり出力したり
        $result = $export($value, null);
        if ($options['return']) {
            return $result;
        }
        echo $result, "\n";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_hash') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_hash'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_hash')) {
    /**
     * 値に複数のハッシュアルゴリズムを適用させて結合して返す
     *
     * $data は何らかの方法で文字列化される（この「何らかの方法」は互換性を担保しない）。
     * 文字長がかなり増えるため、 $base64 に true を与えるとバイナリ変換してその結果を base64（url セーフ）して返す。
     * さらに false を与えると 16進数文字列で返し、 null を与えるとバイナリ文字列で返す。
     *
     * Example:
     * ```php
     * // 配列をハッシュ化する
     * that(var_hash(['a', 'b', 'c']))->isSame('7BDgx6NE2hkXAKtKzhpeJm6-mheMOQWNgrCe7768OiFeoWgA');
     * // オブジェクトをハッシュ化する
     * that(var_hash(new \ArrayObject(['a', 'b', 'c'])))->isSame('-zR2rZ58CzuYhhdHn1Oq90zkYSaxMS-dHUbmb0MTRM4gBpj2');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var ハッシュ化する値
     * @param string[] $algos ハッシュアルゴリズム
     * @param ?bool $base64 結果を base64 化するか
     * @return string ハッシュ文字列
     */
    function var_hash($var, $algos = ['md5', 'sha1'], $base64 = true)
    {
        if (!is_string($var)) {
            $var = serialize($var);
        }

        $algos = arrayize($algos);
        assert($algos);

        $hash = '';
        foreach ($algos as $algo) {
            $hash .= hash($algo, "$var", $base64 !== false);
        }

        if ($base64 !== true) {
            return $hash;
        }

        return base64url_encode($hash);
    }
}
