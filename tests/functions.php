<?php
# Don't touch this code. This is auto generated.
namespace ryunosuke\ltsv;

if (!defined('ryunosuke\\ltsv\\IS_OWNSELF')) {
    define('ryunosuke\\ltsv\\IS_OWNSELF', 2);
}

if (!defined('ryunosuke\\ltsv\\IS_PUBLIC')) {
    define('ryunosuke\\ltsv\\IS_PUBLIC', 4);
}

if (!defined('ryunosuke\\ltsv\\IS_PROTECTED')) {
    define('ryunosuke\\ltsv\\IS_PROTECTED', 8);
}

if (!defined('ryunosuke\\ltsv\\IS_PRIVATE')) {
    define('ryunosuke\\ltsv\\IS_PRIVATE', 16);
}

if (!defined('ryunosuke\\ltsv\\EN_MONTH_SHORT')) {
    define('ryunosuke\\ltsv\\EN_MONTH_SHORT', [
        1  => "jan",
        2  => "feb",
        3  => "mar",
        4  => "apr",
        5  => "may",
        6  => "jun",
        7  => "jul",
        8  => "aug",
        9  => "sep",
        10 => "oct",
        11 => "nov",
        12 => "dec",
    ]);
}

if (!defined('ryunosuke\\ltsv\\EN_MONTH_LONG')) {
    define('ryunosuke\\ltsv\\EN_MONTH_LONG', [
        1  => "january",
        2  => "february",
        3  => "march",
        4  => "april",
        5  => "may",
        6  => "june",
        7  => "july",
        8  => "august",
        9  => "september",
        10 => "october",
        11 => "november",
        12 => "december",
    ]);
}

if (!defined('ryunosuke\\ltsv\\JP_ERA')) {
    define('ryunosuke\\ltsv\\JP_ERA', [
        [
            "name"  => "令和",
            "abbr"  => "R",
            "since" => 1556636400,
        ],
        [
            "name"  => "平成",
            "abbr"  => "H",
            "since" => 600188400,
        ],
        [
            "name"  => "昭和",
            "abbr"  => "S",
            "since" => -1357635600,
        ],
        [
            "name"  => "大正",
            "abbr"  => "T",
            "since" => -1812186000,
        ],
        [
            "name"  => "明治",
            "abbr"  => "M",
            "since" => -3216790800,
        ],
    ]);
}

if (!defined('ryunosuke\\ltsv\\GENERAL_MIMETYPE')) {
    define('ryunosuke\\ltsv\\GENERAL_MIMETYPE', [
        "csv"   => "text/csv",
        "dcm"   => "application/dicom",
        "dvc"   => "application/dvcs",
        "finf"  => "application/fastinfoset",
        "stk"   => "application/hyperstudio",
        "ipfix" => "application/ipfix",
        "json"  => "application/json",
        "mrc"   => "application/marc",
        "nb"    => "application/mathematica",
        "ma"    => "application/mathematica",
        "mb"    => "application/mathematica",
        "mbox"  => "application/mbox",
        "m21"   => "application/mp21",
        "mp21"  => "application/mp21",
        "xls"   => "application/vnd.ms-excel",
        "doc"   => "application/vnd.ms-word",
        "mxf"   => "application/mxf",
        "oda"   => "application/oda",
        "ogx"   => "application/ogg",
        "pdf"   => "application/pdf",
        "p10"   => "application/pkcs10",
        "ai"    => "application/postscript",
        "eps"   => "application/postscript",
        "ps"    => "application/postscript",
        "rtf"   => "application/rtf",
        "sdp"   => "application/sdp",
        "siv"   => "application/sieve",
        "sieve" => "application/sieve",
        "smil"  => "application/smil",
        "smi"   => "application/smil",
        "sml"   => "application/smil",
        "gram"  => "application/srgs",
        "xml"   => "text/xml",
        "zip"   => "application/x-zip-compressed",
        "xlsx"  => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "docx"  => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        726     => "audio/32kadpcm",
        "amr"   => "audio/AMR",
        "at3"   => "audio/ATRAC3",
        "aa3"   => "audio/ATRAC3",
        "omg"   => "audio/ATRAC3",
        "evc"   => "audio/EVRC",
        "evb"   => "audio/EVRCB",
        "evw"   => "audio/EVRCWB",
        "l16"   => "audio/L16",
        "smv"   => "audio/SMV",
        "ac3"   => "audio/ac3",
        "au"    => "audio/basic",
        "snd"   => "audio/basic",
        "dls"   => "audio/dls",
        "lbc"   => "audio/iLBC",
        "mid"   => "audio/midi",
        "midi"  => "audio/midi",
        "kar"   => "audio/midi",
        "mpga"  => "audio/mpeg",
        "mp1"   => "audio/mpeg",
        "mp2"   => "audio/mpeg",
        "mp3"   => "audio/mpeg",
        "oga"   => "audio/ogg",
        "ogg"   => "audio/ogg",
        "spx"   => "audio/ogg",
        "qcp"   => "audio/qcelp",
        "bmp"   => "image/bmp",
        "fits"  => "image/fits",
        "fit"   => "image/fits",
        "fts"   => "image/fits",
        "gif"   => "image/gif",
        "ief"   => "image/ief",
        "jp2"   => "image/jp2",
        "jpg2"  => "image/jp2",
        "jpeg"  => "image/jpeg",
        "jpg"   => "image/jpeg",
        "jpe"   => "image/jpeg",
        "jfif"  => "image/jpeg",
        "jpm"   => "image/jpm",
        "jpgm"  => "image/jpm",
        "jpx"   => "image/jpx",
        "jpf"   => "image/jpx",
        "svg"   => "image/svg+xml",
        "png"   => "image/png",
        "t38"   => "image/t38",
        "tiff"  => "image/tiff",
        "tif"   => "image/tiff",
        "u8msg" => "message/global",
        "eml"   => "message/rfc822",
        "mail"  => "message/rfc822",
        "art"   => "message/rfc822",
        "igs"   => "model/iges",
        "iges"  => "model/iges",
        "msh"   => "model/mesh",
        "mesh"  => "model/mesh",
        "silo"  => "model/mesh",
        "wrl"   => "model/vrml",
        "vrml"  => "model/vrml",
        "ics"   => "text/calendar",
        "ifb"   => "text/calendar",
        "css"   => "text/css",
        "soa"   => "text/dns",
        "zone"  => "text/dns",
        "html"  => "text/html",
        "htm"   => "text/html",
        "js"    => "text/javascript",
        "asc"   => "text/plain",
        "txt"   => "text/plain",
        "text"  => "text/plain",
        "pm"    => "text/plain",
        "el"    => "text/plain",
        "c"     => "text/plain",
        "h"     => "text/plain",
        "cc"    => "text/plain",
        "hh"    => "text/plain",
        "cxx"   => "text/plain",
        "hxx"   => "text/plain",
        "f90"   => "text/plain",
        "rtx"   => "text/richtext",
        "sgml"  => "text/sgml",
        "sgm"   => "text/sgml",
        "3gp"   => "video/3gpp",
        "3gpp"  => "video/3gpp",
        "3g2"   => "video/3gpp2",
        "3gpp2" => "video/3gpp2",
        "mj2"   => "video/mj2",
        "mjp2"  => "video/mj2",
        "mp4"   => "video/mp4",
        "mpg4"  => "video/mp4",
        "mpeg"  => "video/mpeg",
        "mpg"   => "video/mpeg",
        "mpe"   => "video/mpeg",
        "ogv"   => "video/ogg",
        "qt"    => "video/quicktime",
        "mov"   => "video/quicktime",
        "webm"  => "video/webm",
    ]);
}

if (!defined('ryunosuke\\ltsv\\GLOB_RECURSIVE')) {
    define('ryunosuke\\ltsv\\GLOB_RECURSIVE', 65536);
}

if (!defined('ryunosuke\\ltsv\\JSON_MAX_DEPTH')) {
    define('ryunosuke\\ltsv\\JSON_MAX_DEPTH', -1);
}

if (!defined('ryunosuke\\ltsv\\JSON_INDENT')) {
    define('ryunosuke\\ltsv\\JSON_INDENT', -71);
}

if (!defined('ryunosuke\\ltsv\\JSON_CLOSURE')) {
    define('ryunosuke\\ltsv\\JSON_CLOSURE', -72);
}

if (!defined('ryunosuke\\ltsv\\JSON_NEST_LEVEL')) {
    define('ryunosuke\\ltsv\\JSON_NEST_LEVEL', -73);
}

if (!defined('ryunosuke\\ltsv\\JSON_INLINE_LEVEL')) {
    define('ryunosuke\\ltsv\\JSON_INLINE_LEVEL', -74);
}

if (!defined('ryunosuke\\ltsv\\JSON_INLINE_SCALARLIST')) {
    define('ryunosuke\\ltsv\\JSON_INLINE_SCALARLIST', -75);
}

if (!defined('ryunosuke\\ltsv\\JSON_ES5')) {
    define('ryunosuke\\ltsv\\JSON_ES5', -100);
}

if (!defined('ryunosuke\\ltsv\\JSON_INT_AS_STRING')) {
    define('ryunosuke\\ltsv\\JSON_INT_AS_STRING', -101);
}

if (!defined('ryunosuke\\ltsv\\JSON_FLOAT_AS_STRING')) {
    define('ryunosuke\\ltsv\\JSON_FLOAT_AS_STRING', -102);
}

if (!defined('ryunosuke\\ltsv\\JSON_TRAILING_COMMA')) {
    define('ryunosuke\\ltsv\\JSON_TRAILING_COMMA', -103);
}

if (!defined('ryunosuke\\ltsv\\JSON_COMMENT_PREFIX')) {
    define('ryunosuke\\ltsv\\JSON_COMMENT_PREFIX', -104);
}

if (!defined('ryunosuke\\ltsv\\JSON_TEMPLATE_LITERAL')) {
    define('ryunosuke\\ltsv\\JSON_TEMPLATE_LITERAL', -105);
}

if (!defined('ryunosuke\\ltsv\\JSON_BARE_AS_STRING')) {
    define('ryunosuke\\ltsv\\JSON_BARE_AS_STRING', -106);
}

if (!defined('ryunosuke\\ltsv\\SI_UNITS')) {
    define('ryunosuke\\ltsv\\SI_UNITS', [
        -8 => ["y"],
        -7 => ["z"],
        -6 => ["a"],
        -5 => ["f"],
        -4 => ["p"],
        -3 => ["n"],
        -2 => ["u", "μ", "µ"],
        -1 => ["m"],
        0  => [],
        1  => ["k", "K"],
        2  => ["M"],
        3  => ["G"],
        4  => ["T"],
        5  => ["P"],
        6  => ["E"],
        7  => ["Z"],
        8  => ["Y"],
    ]);
}

if (!defined('ryunosuke\\ltsv\\SORT_STRICT')) {
    define('ryunosuke\\ltsv\\SORT_STRICT', 256);
}

assert(!function_exists('ryunosuke\\ltsv\\array_add') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_add'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_add')) {
    /**
     * 配列の+演算子の関数版
     *
     * Example:
     * ```php
     * // ただの加算の関数版なので同じキーは上書きされない
     * that(array_add(['a', 'b', 'c'], ['X']))->isSame(['a', 'b', 'c']);
     * // 異なるキーは生える
     * that(array_add(['a', 'b', 'c'], ['x' => 'X']))->isSame(['a', 'b', 'c', 'x' => 'X']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array ...$variadic 足す配列（可変引数）
     * @return array 足された配列
     */
    function array_add(...$variadic)
    {
        $array = [];
        foreach ($variadic as $arg) {
            $array += $arg;
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_aggregate') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_aggregate'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_aggregate')) {
    /**
     * 配列をコールバックの返り値で集計する
     *
     * $columns で集計列を指定する。
     * 単一の callable を渡すと結果も単一になる。
     * 複数の callable 連想配列を渡すと [キー => 集系列] の連想配列になる。
     * いずれにせよ引数としてそのグループの配列が渡ってくるので返り値がその列の値になる。
     * 第2引数には「今までの結果が詰まった配列」が渡ってくる（count, avg, sum など何度もでてくる集計で便利）。
     *
     * $key で集約列を指定する。
     * 指定しなければ引数の配列そのままで集計される。
     * 複数要素の配列を与えるとその数分潜って集計される。
     * クロージャを与えると返り値がキーになる。
     *
     * Example:
     * ```php
     * // 単純な配列の集計
     * that(array_aggregate([1, 2, 3], [
     *     'min' => fn($elems) => min($elems),
     *     'max' => fn($elems) => max($elems),
     *     'avg' => fn($elems) => array_sum($elems) / count($elems),
     * ]))->isSame([
     *     'min' => 1, // 最小値
     *     'max' => 3, // 最大値
     *     'avg' => 2, // 平均値
     * ]);
     *
     * $row1 = ['user_id' => 'hoge', 'group' => 'A', 'score' => 4];
     * $row2 = ['user_id' => 'fuga', 'group' => 'B', 'score' => 6];
     * $row3 = ['user_id' => 'fuga', 'group' => 'A', 'score' => 5];
     * $row4 = ['user_id' => 'hoge', 'group' => 'A', 'score' => 8];
     *
     * // user_id, group ごとの score を集計して階層配列で返す（第2引数 $current を利用している）
     * that(array_aggregate([$row1, $row2, $row3, $row4], [
     *     'scores' => fn($rows) => array_column($rows, 'score'),
     *     'score'  => fn($rows, $current) => array_sum($current['scores']),
     * ], ['user_id', 'group']))->isSame([
     *     'hoge' => [
     *         'A' => [
     *             'scores' => [4, 8],
     *             'score'  => 12,
     *         ],
     *     ],
     *     'fuga' => [
     *         'B' => [
     *             'scores' => [6],
     *             'score'  => 6,
     *         ],
     *         'A' => [
     *             'scores' => [5],
     *             'score'  => 5,
     *         ],
     *     ],
     * ]);
     *
     * // user_id ごとの score を集計して単一列で返す（キーのクロージャも利用している）
     * that(array_aggregate([$row1, $row2, $row3, $row4],
     *     fn($rows) => array_sum(array_column($rows, 'score')),
     *     fn($row) => strtoupper($row['user_id'])))->isSame([
     *     'HOGE' => 12,
     *     'FUGA' => 11,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable|callable[] $columns 集計関数
     * @param string|array|null $key 集約列。クロージャを与えると返り値がキーになる
     * @return array 集約配列
     */
    function array_aggregate($array, $columns, $key = null)
    {
        if ($key === null) {
            $nest_level = 0;
        }
        elseif ($key instanceof \Closure) {
            $nest_level = 1;
        }
        elseif (is_string($key)) {
            $nest_level = 1;
            $key = array_of($key);
        }
        else {
            $nest_level = count($key);
            $key = array_of($key);
        }

        if ($key === null) {
            $group = arrayval($array);
        }
        else {
            $group = [];
            $n = 0;
            foreach ($array as $k => $v) {
                $vv = $key($v, $k, $n++);

                if (is_array($vv)) {
                    $tmp = &$group;
                    foreach ($vv as $vvv) {
                        $tmp = &$tmp[$vvv];
                    }
                    $tmp[] = $v;
                    unset($tmp);
                }
                else {
                    $group[$vv][$k] = $v;
                }
            }
        }

        if (!is_callable($columns)) {
            $columns = array_map(fn(...$args) => func_user_func_array(...$args), $columns);
        }

        $dive = function ($array, $level) use (&$dive, $columns) {
            $result = [];
            if ($level === 0) {
                if (is_callable($columns)) {
                    return $columns($array);
                }
                foreach ($columns as $name => $column) {
                    $result[$name] = $column($array, $result);
                }
            }
            else {
                foreach ($array as $k => $v) {
                    $result[$k] = $dive($v, $level - 1);
                }
            }
            return $result;
        };
        return $dive($group, $nest_level);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_all') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_all'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_all')) {
    /**
     * 全要素が true になるなら true を返す（1つでも false なら false を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_all([true, true]))->isTrue();
     * that(array_all([true, false]))->isFalse();
     * that(array_all([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が true なら true
     */
    function array_all($array, $callback = null, $default = true)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if (!$callback($v, $k, $n++)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_any') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_any'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_any')) {
    /**
     * 全要素が false になるなら false を返す（1つでも true なら true を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_any([true, true]))->isTrue();
     * that(array_any([true, false]))->isTrue();
     * that(array_any([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が false なら false
     */
    function array_any($array, $callback = null, $default = false)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if ($callback($v, $k, $n++)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_append') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_append'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_append')) {
    /**
     * 配列の末尾に要素を追加する
     *
     * array_push のキーが指定できる参照渡しでない版と言える。
     * キー指定でかつそのキーが存在するとき、値を変えつつ末尾に移動する動作となる。
     *
     * Example:
     * ```php
     * // キー未指定は言語機構を利用して末尾に追加される
     * that(array_append([1, 2, 3], 99))->is([1, 2, 3, 99]);
     * // キーを指定すればそのキーで生える
     * that(array_append([1, 2, 3], 99, 'newkey'))->is([1, 2, 3, 'newkey' => 99]);
     * // 存在する場合は値が変わって末尾に移動する
     * that(array_append([1, 2, 3], 99, 1))->is([0 => 1, 2 => 3, 1 => 99]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @return array 要素が追加された配列
     */
    function array_append($array, $value, $key = null)
    {
        if ($key === null) {
            $array[] = $value;
        }
        else {
            unset($array[$key]);
            $array[$key] = $value;
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_assort') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_assort'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_assort')) {
    /**
     * 配列をコールバックに従って分類する
     *
     * コールバックは配列で複数与える。そのキーが結果配列のキーになるが、一切マッチしなくてもキー自体は作られる。
     * 複数のコールバックにマッチしたらその分代入されるし、どれにもマッチしなければ代入されない。
     * つまり5個の配列を分類したからと言って、全要素数が5個になるとは限らない（多い場合も少ない場合もある）。
     *
     * $rule が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * // lt2(2より小さい)で分類
     * $lt2 = fn($v) => $v < 2;
     * that(array_assort([1, 2, 3], [
     *     'lt2' => $lt2,
     * ]))->isSame([
     *     'lt2' => [1],
     * ]);
     * // lt3(3より小さい)、ctd(ctype_digit)で分類（両方に属する要素が存在する）
     * $lt3 = fn($v) => $v < 3;
     * that(array_assort(['1', '2', '3'], [
     *     'lt3' => $lt3,
     *     'ctd' => 'ctype_digit',
     * ]))->isSame([
     *     'lt3' => ['1', '2'],
     *     'ctd' => ['1', '2', '3'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable[] $rules 分類ルール。[key => callable] 形式
     * @return array 分類された新しい配列
     */
    function array_assort($array, $rules)
    {
        $result = array_fill_keys(array_keys($rules), []);
        foreach ($rules as $name => $rule) {
            $rule = func_user_func_array($rule);
            $n = 0;
            foreach ($array as $k => $v) {
                if ($rule($v, $k, $n++)) {
                    $result[$name][$k] = $v;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_columns') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_columns'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_columns')) {
    /**
     * 全要素に対して array_column する
     *
     * 行列が逆転するイメージ。
     *
     * Example:
     * ```php
     * $row1 = ['id' => 1, 'name' => 'A'];
     * $row2 = ['id' => 2, 'name' => 'B'];
     * $rows = [$row1, $row2];
     * that(array_columns($rows))->isSame(['id' => [1, 2], 'name' => ['A', 'B']]);
     * that(array_columns($rows, 'id'))->isSame(['id' => [1, 2]]);
     * that(array_columns($rows, 'name', 'id'))->isSame(['name' => [1 => 'A', 2 => 'B']]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param string|array|null $column_keys 引っ張ってくるキー名
     * @param mixed $index_key 新しい配列のキーとなるキー名
     * @return array 新しい配列
     */
    function array_columns($array, $column_keys = null, $index_key = null)
    {
        if (count($array) === 0 && $column_keys === null) {
            throw new \InvalidArgumentException("can't auto detect keys.");
        }

        if ($column_keys === null) {
            $column_keys = array_keys(reset($array));
        }

        $result = [];
        foreach ((array) $column_keys as $key) {
            $result[$key] = array_column($array, $key, $index_key);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_convert') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_convert'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_convert')) {
    /**
     * 配列の各要素に再帰的にコールバックを適用して変換する
     *
     * $callback は下記の仕様。
     *
     * 引数は (キー, 値, 今まで処理したキー配列) で渡ってくる。
     * 返り値は新しいキーを返す。
     *
     * - 文字列や数値を返すとそれがキーとして使われる
     * - null を返すと元のキーがそのまま使われる
     * - true を返すと数値連番が振られる
     * - false を返すとその要素は無かったことになる
     * - 配列を返すとその配列で完全に置換される
     *
     * $apply_array=false で要素が配列の場合は再帰され、コールバックが適用されない（array_walk_recursive と同じ仕様）。
     *
     * $apply_array=true だと配列かは問わず全ての要素にコールバックが適用される。
     * 配列も渡ってきてしまうのでコールバック内部で is_array 判定が必要になる場合がある。
     *
     * 「map も filter も可能でキー変更可能かつ再帰的」というとてもマッチョな関数。
     * 複雑だが実質的には「キーも設定できる array_walk_recursive」のように振る舞う（そしてそのような使い方を想定している）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *        ],
     *        'k23' => 'v23',
     *    ],
     * ];
     * // 全要素に 'prefix-' を付与する。キーには '_' をつける。ただし 'k21' はそのままとする。さらに 'k22' はまるごと伏せる。 'k23' は数値キーになる
     * $callback = function ($k, &$v) {
     *     if ($k === 'k21') return null;
     *     if ($k === 'k22') return false;
     *     if ($k === 'k23') return true;
     *     if (!is_array($v)) $v = "prefix-$v";
     *     return "_$k";
     * };
     * that(array_convert($array, $callback, true))->isSame([
     *     '_k1' => 'prefix-v1',
     *     '_k2' => [
     *         'k21' => 'v21',
     *         0     => 'v23',
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param callable $callback 適用するコールバック
     * @param bool $apply_array 配列要素にもコールバックを適用するか
     * @return array 変換された配列
     */
    function array_convert($array, $callback, $apply_array = false)
    {
        $recursive = function (&$result, $array, $history, $callback) use (&$recursive, $apply_array) {
            $sequences = [];
            foreach ($array as $key => $value) {
                $is_array = is_array($value);
                $newkey = $key;
                // 配列で $apply_array あるいは非配列の場合にコールバック適用
                if (($is_array && $apply_array) || !$is_array) {
                    $newkey = $callback($key, $value, $history);
                }
                // 配列は置換
                if (is_array($newkey)) {
                    foreach ($newkey as $k => $v) {
                        $result[$k] = $v;
                    }
                    continue;
                }
                // false はスルー
                if ($newkey === false) {
                    continue;
                }
                // true は数値連番
                if ($newkey === true) {
                    if ($is_array) {
                        $sequences["_$key"] = $value;
                    }
                    else {
                        $sequences[] = $value;
                    }
                    continue;
                }
                // null は元のキー
                if ($newkey === null) {
                    $newkey = $key;
                }
                // 配列と非配列で代入の仕方が異なる
                if ($is_array) {
                    $history[] = $key;
                    $result[$newkey] = [];
                    $recursive($result[$newkey], $value, $history, $callback);
                    array_pop($history);
                }
                else {
                    $result[$newkey] = $value;
                }
            }
            // 数値連番は上書きを防ぐためにあとでやる
            foreach ($sequences as $key => $value) {
                if (is_string($key)) {
                    $history[] = substr($key, 1);
                    $v = [];
                    $result[] = &$v;
                    $recursive($v, $value, $history, $callback);
                    array_pop($history);
                    unset($v);
                }
                else {
                    $result[] = $value;
                }
            }
        };

        $result = [];
        $recursive($result, $array, [], $callback);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_count') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_count'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_count')) {
    /**
     * 配列をコールバックに従ってカウントする
     *
     * コールバックが true 相当を返した要素をカウントして返す。
     * 普通に使う分には `count(array_filter($array, $callback))` とほとんど同じだが、下記の点が微妙に異なる。
     *
     * - $callback が要求するならキーも渡ってくる
     * - $callback には配列が渡せる。配列を渡した場合は件数を配列で返す（Example 参照）
     *
     * $recursive に true を渡すと再帰的に動作する。
     * 末端・配列を問わずに呼び出されるので場合によっては is_array などの判定が必要になる。
     *
     * Example:
     * ```php
     * $array = ['hoge', 'fuga', 'piyo'];
     * // 'o' を含むものの数（2個）
     * that(array_count($array, fn($s) => strpos($s, 'o') !== false))->isSame(2);
     * // 'a' と 'o' を含むものをそれぞれ（1個と2個）
     * that(array_count($array, [
     *     'a' => fn($s) => strpos($s, 'a') !== false,
     *     'o' => fn($s) => strpos($s, 'o') !== false,
     * ]))->isSame([
     *     'a' => 1,
     *     'o' => 2,
     * ]);
     *
     * // 再帰版
     * $array = [
     *     ['1', '2', '3'],
     *     ['a', 'b', 'c'],
     *     ['X', 'Y', 'Z'],
     *     [[[['a', 'M', 'Z']]]],
     * ];
     * that(array_count($array, [
     *     'lower' => fn($v) => !is_array($v) && ctype_lower($v),
     *     'upper' => fn($v) => !is_array($v) && ctype_upper($v),
     *     'array' => fn($v) => is_array($v),
     * ], true))->is([
     *     'lower' => 4, // 小文字の数
     *     'upper' => 5, // 大文字の数
     *     'array' => 7, // 配列の数
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback カウントルール。配列も渡せる
     * @param bool $recursive 再帰フラグ
     * @return int|array 条件一致した件数
     */
    function array_count($array, $callback, $recursive = false)
    {
        // 配列が来た場合はまるで動作が異なる（再帰でもいいがそれだと旨味がない。複数欲しいなら呼び出し元で複数回呼べば良い。ワンループに閉じ込めるからこそメリットがある））
        if (is_array($callback) && !is_callable($callback)) {
            $result = array_fill_keys(array_keys($callback), 0);
            foreach ($callback as $name => $rule) {
                $rule = func_user_func_array($rule);
                $n = 0;
                foreach ($array as $k => $v) {
                    if ($rule($v, $k, $n++)) {
                        $result[$name]++;
                    }
                    if ($recursive && is_iterable($v)) {
                        $result[$name] += array_count($v, $rule, $recursive);
                    }
                }
            }
            return $result;
        }

        $callback = func_user_func_array($callback);
        $result = 0;
        $n = 0;
        foreach ($array as $k => $v) {
            if ($callback($v, $k, $n++)) {
                $result++;
            }
            if ($recursive && is_iterable($v)) {
                $result += array_count($v, $callback, $recursive);
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_cross') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_cross'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_cross')) {
    /**
     * 配列の直積を返す
     *
     * 文字キーは保存されるが数値キーは再割り振りされる。
     * ただし、文字キーが重複すると例外を投げる。
     *
     * Example:
     * ```php
     * // 普通の直積
     * that(array_cross(
     *     [1, 2],
     *     [3, 4]
     * ))->isSame([[1, 3], [1, 4], [2, 3], [2, 4]]);
     * // キーが維持される
     * that(array_cross(
     *     ['a' => 1, 2],
     *     ['b' => 3, 4]
     * ))->isSame([['a' => 1, 'b' => 3], ['a' => 1, 4], [2, 'b' => 3], [2, 4]]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array ...$arrays 対象配列（可変引数）
     * @return array 各配列値の直積
     */
    function array_cross(...$arrays)
    {
        if (!$arrays) {
            return [];
        }

        $result = [[]];
        foreach ($arrays as $array) {
            $tmp = [];
            foreach ($result as $x) {
                foreach ($array as $k => $v) {
                    if (is_string($k) && array_key_exists($k, $x)) {
                        throw new \InvalidArgumentException("duplicated key '$k'.");
                    }
                    $tmp[] = array_merge($x, [$k => $v]);
                }
            }
            $result = $tmp;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_depth') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_depth'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_depth')) {
    /**
     * 配列の次元数を返す
     *
     * フラット配列は 1 と定義する。
     * つまり、配列を与える限りは 0 以下を返すことはない。
     *
     * 第2引数 $max_depth を与えるとその階層になった時点で走査を打ち切る。
     * 「1階層のみか？」などを調べるときは指定したほうが高速に動作する。
     *
     * Example:
     * ```php
     * that(array_depth([]))->isSame(1);
     * that(array_depth(['hoge']))->isSame(1);
     * that(array_depth([['nest1' => ['nest2']]]))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @param int|null $max_depth 最大階層数
     * @return int 次元数。素のフラット配列は 1
     */
    function array_depth($array, $max_depth = null)
    {
        assert((is_null($max_depth)) || $max_depth > 0);

        $main = function ($array, $depth) use (&$main, $max_depth) {
            // $max_depth を超えているなら打ち切る
            if ($max_depth !== null && $depth >= $max_depth) {
                return 1;
            }

            // 配列以外に興味はない
            $arrays = array_filter($array, 'is_array');

            // ネストしない配列は 1 と定義
            if (!$arrays) {
                return 1;
            }

            // 配下の内で最大を返す
            return 1 + max(array_map(fn($v) => $main($v, $depth + 1), $arrays));
        };

        return $main($array, 1);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_difference') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_difference'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_difference')) {
    /**
     * 配列の差分を取り配列で返す
     *
     * 返り値の配列は構造化されたデータではない。
     * 主に文字列化して出力することを想定している。
     *
     * ユースケースとしては「スキーマデータ」「各環境の設定ファイル」などの差分。
     *
     * - '+' はキーが追加されたことを表す
     * - '-' はキーが削除されたことを表す
     * - 両方が含まれている場合、値の変更を表す
     *
     * 数値キーはキーの比較は行われない。値の差分のみ返す。
     *
     * Example:
     * ```php
     * // common は 中身に差分がある。 1 に key1 はあるが、 2 にはない。2 に key2 はあるが、 1 にはない。
     * that(array_difference([
     *     'common' => [
     *         'sub' => [
     *             'x' => 'val',
     *         ]
     *     ],
     *     'key1'   => 'hoge',
     *     'array'  => ['a', 'b', 'c'],
     * ], [
     *     'common' => [
     *         'sub' => [
     *             'x' => 'VAL',
     *         ]
     *     ],
     *     'key2'   => 'fuga',
     *     'array'  => ['c', 'd', 'e'],
     * ]))->isSame([
     *     'common.sub.x' => ['-' => 'val', '+' => 'VAL'],
     *     'key1'         => ['-' => 'hoge'],
     *     'array'        => ['-' => ['a', 'b'], '+' => ['d', 'e']],
     *     'key2'         => ['+' => 'fuga'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array1 対象配列1
     * @param iterable $array2 対象配列2
     * @param string $delimiter 差分配列のキー区切り文字
     * @return array 差分を表す配列
     */
    function array_difference($array1, $array2, $delimiter = '.')
    {
        $rule = [
            'list' => static fn($v, $k) => is_int($k),
            'hash' => static fn($v, $k) => !is_int($k),
        ];

        $udiff = static fn($a, $b) => $a <=> $b;

        return call_user_func($f = static function ($array1, $array2, $key = null) use (&$f, $rule, $udiff, $delimiter) {
            $result = [];

            $array1 = array_assort($array1, $rule);
            $array2 = array_assort($array2, $rule);

            $list1 = array_values(array_udiff($array1['list'], $array2['list'], $udiff));
            $list2 = array_values(array_udiff($array2['list'], $array1['list'], $udiff));
            for ($k = 0, $l = max(count($list1), count($list2)); $k < $l; $k++) {
                $exists1 = array_key_exists($k, $list1);
                $exists2 = array_key_exists($k, $list2);

                $v1 = $exists1 ? $list1[$k] : null;
                $v2 = $exists2 ? $list2[$k] : null;

                $prefix = $key === null ? count($result) : $key;
                if ($exists1) {
                    $result[$prefix]['-'][] = $v1;
                }
                if ($exists2) {
                    $result[$prefix]['+'][] = $v2;
                }
            }

            $hash1 = array_udiff_assoc($array1['hash'], $array2['hash'], $udiff);
            $hash2 = array_udiff_assoc($array2['hash'], $array1['hash'], $udiff);
            foreach (array_keys($hash1 + $hash2) as $k) {
                $exists1 = array_key_exists($k, $hash1);
                $exists2 = array_key_exists($k, $hash2);

                $v1 = $exists1 ? $hash1[$k] : null;
                $v2 = $exists2 ? $hash2[$k] : null;

                $prefix = $key === null ? $k : $key . $delimiter . $k;
                if (is_array($v1) && is_array($v2)) {
                    $result += $f($v1, $v2, $prefix);
                    continue;
                }
                if ($exists1) {
                    $result[$prefix]['-'] = $v1;
                }
                if ($exists2) {
                    $result[$prefix]['+'] = $v2;
                }
            }

            return $result;
        }, $array1, $array2);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_distinct') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_distinct'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_distinct')) {
    /**
     * 比較関数が渡せる array_unique
     *
     * array_unique は微妙に癖があるのでシンプルに使いやすくしたもの。
     *
     * - SORT_STRING|SORT_FLAG_CASE のような指定が使える（大文字小文字を無視した重複除去）
     *   - 厳密に言えば array_unique も指定すれば動く（が、ドキュメントに記載がない）
     * - 配列を渡すと下記の動作になる
     *   - 数値キーは配列アクセス
     *   - 文字キーはメソッドコール（値は引数）
     * - もちろん（$a, $b を受け取る）クロージャも渡せる
     * - 引数1つのクロージャを渡すとシュワルツ的動作になる（Example 参照）
     *
     * Example:
     * ```php
     * // シンプルな重複除去
     * that(array_distinct([1, 2, 3, '3']))->isSame([1, 2, 3]);
     * // 大文字小文字を無視した重複除去
     * that(array_distinct(['a', 'b', 'A', 'B'], SORT_STRING|SORT_FLAG_CASE))->isSame(['a', 'b']);
     *
     * $v1 = new \ArrayObject(['id' => '1', 'group' => 'aaa']);
     * $v2 = new \ArrayObject(['id' => '2', 'group' => 'bbb', 'dummy' => 123]);
     * $v3 = new \ArrayObject(['id' => '3', 'group' => 'aaa', 'dummy' => 456]);
     * $v4 = new \ArrayObject(['id' => '4', 'group' => 'bbb', 'dummy' => 789]);
     * // クロージャを指定して重複除去
     * that(array_distinct([$v1, $v2, $v3, $v4], fn($a, $b) => $a['group'] <=> $b['group']))->isSame([$v1, $v2]);
     * // 単純な配列アクセスなら文字列や配列でよい（上記と同じ結果になる）
     * that(array_distinct([$v1, $v2, $v3, $v4], 'group'))->isSame([$v1, $v2]);
     * // 文字キーの配列はメソッドコールになる（ArrayObject::count で重複検出）
     * that(array_distinct([$v1, $v2, $v3, $v4], ['count' => []]))->isSame([$v1, $v2]);
     * // 上記2つは混在できる（group キー + count メソッドで重複検出。端的に言えば "aaa+2", "bbb+3", "aaa+3", "bbb+3" で除去）
     * that(array_distinct([$v1, $v2, $v3, $v4], ['group', 'count' => []]))->isSame([$v1, $v2, 2 => $v3]);
     * // 引数1つのクロージャ
     * that(array_distinct([$v1, $v2, $v3, $v4], fn($ao) => $ao['group']))->isSame([$v1, $v2]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable|int|string|null $comparator 比較関数
     * @return array 重複が除去された配列
     */
    function array_distinct($array, $comparator = null)
    {
        // 配列化と個数チェック（1以下は重複のしようがないので不要）
        $array = arrayval($array, false);
        if (count($array) <= 1) {
            return $array;
        }

        // 省略時は宇宙船
        if ($comparator === null) {
            $comparator = static fn($a, $b) => $a <=> $b;
        }
        // 数字が来たら varcmp とする
        elseif (is_int($comparator)) {
            $comparator = static fn($a, $b) => varcmp($a, $b, $comparator);
        }
        // 文字列・配列が来たらキーアクセス/メソッドコールとする
        elseif (is_string($comparator) || is_array($comparator)) {
            $comparator = static function ($a, $b) use ($comparator) {
                foreach (arrayize($comparator) as $method => $args) {
                    if (is_int($method)) {
                        $delta = $a[$args] <=> $b[$args];
                    }
                    else {
                        $args = arrayize($args);
                        $delta = $a->$method(...$args) <=> $b->$method(...$args);
                    }
                    if ($delta !== 0) {
                        return $delta;
                    }
                }
                return 0;
            };
        }
        // 引数1つのコールバックはシュワルツ関数とみなす
        elseif (is_callable($comparator) && parameter_length($comparator) === 1) {
            return array_intersect_key($array, array_unique(array_map($comparator, $array)));
        }

        // 2重ループで探すよりは1度ソートしてしまったほうがマシ…だと思う（php の実装もそうだし）
        $backup = $array;
        uasort($array, $comparator);
        $keys = array_keys($array);

        // できるだけ元の順番は維持したいので、詰めて返すのではなくキーを導出して共通項を返す（ただし、この仕様は変えるかもしれない）
        $current = $keys[0];
        $keepkeys = [$current => null];
        for ($i = 1, $l = count($keys); $i < $l; $i++) {
            if ($comparator($array[$current], $array[$keys[$i]]) !== 0) {
                $current = $keys[$i];
                $keepkeys[$current] = null;
            }
        }
        return array_intersect_key($backup, $keepkeys);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_dive') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_dive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_dive')) {
    /**
     * パス形式で配列値を取得
     *
     * 存在しない場合は $default を返す。
     *
     * Example:
     * ```php
     * $array = [
     *     'a' => [
     *         'b' => [
     *             'c' => 'vvv'
     *         ]
     *     ]
     * ];
     * that(array_dive($array, 'a.b.c'))->isSame('vvv');
     * that(array_dive($array, 'a.b.x', 9))->isSame(9);
     * // 配列を与えても良い。その場合 $delimiter 引数は意味をなさない
     * that(array_dive($array, ['a', 'b', 'c']))->isSame('vvv');
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\ArrayAccess $array 調べる配列
     * @param string|array $path パス文字列。配列も与えられる
     * @param mixed $default 無かった場合のデフォルト値
     * @param string $delimiter パスの区切り文字。大抵は '.' か '/'
     * @return mixed パスが示す配列の値
     */
    function array_dive($array, $path, $default = null, $delimiter = '.')
    {
        $keys = is_array($path) ? $path : explode($delimiter, $path);
        foreach ($keys as $key) {
            if (!is_arrayable($array)) {
                return $default;
            }
            if (!array_keys_exist($key, $array)) {
                return $default;
            }
            $array = $array[$key];
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_each') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_each'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_each')) {
    /**
     * array_reduce の参照版（のようなもの）
     *
     * 配列をループで回し、その途中経過、値、キー、連番をコールバック引数で渡して最終的な結果を返り値として返す。
     * array_reduce と少し似てるが、下記の点が異なる。
     *
     * - いわゆる $carry は返り値で表すのではなく、参照引数で表す
     * - 値だけでなくキー、連番も渡ってくる
     * - 巨大配列の場合でも速度劣化が少ない（array_reduce に巨大配列を渡すと実用にならないレベルで遅くなる）
     *
     * $callback の引数は `($value, $key, $n)` （$n はキーとは関係がない 0 ～ 要素数-1 の通し連番）。
     *
     * 返り値ではなく参照引数なので return する必要はない（ワンライナーが書きやすくなる）。
     * 返り値が空くのでループ制御に用いる。
     * 今のところ $callback が false を返すとそこで break するのみ。
     *
     * 第3引数を省略した場合、**クロージャの第1引数のデフォルト値が使われる**。
     * これは特筆すべき動作で、不格好な第3引数を完全に省略することができる（サンプルコードを参照）。
     * ただし「php の文法違反（今のところエラーにはならないし、全てにデフォルト値をつければ一応回避可能）」「リフレクションを使う（ほんの少し遅くなる）」などの弊害が有るので推奨はしない。
     * （ただ、「意図していることをコードで表す」といった観点ではこの記法の方が正しいとも思う）。
     *
     * Example:
     * ```php
     * // 全要素を文字列的に足し合わせる
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry .= $v;}, ''))->isSame('12345');
     * // 値をキーにして要素を2乗値にする
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry[$v] = $v * $v;}, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     *     4 => 16,
     *     5 => 25,
     * ]);
     * // 上記と同じ。ただし、3 で break する
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v, $k){
     *     if ($k === 3) return false;
     *     $carry[$v] = $v * $v;
     * }, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     * ]);
     *
     * // 下記は完全に同じ（第3引数の代わりにデフォルト引数を使っている）
     * that(array_each([1, 2, 3], function (&$carry = [], $v = null) {
     *         $carry[$v] = $v * $v;
     *     }))->isSame(array_each([1, 2, 3], function (&$carry, $v) {
     *         $carry[$v] = $v * $v;
     *     }, [])
     *     // 個人的に↑のようなぶら下がり引数があまり好きではない（クロージャを最後の引数にしたい）
     * );
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ。(&$carry, $key, $value) を受ける
     * @param mixed $default ループの最初や空の場合に適用される値
     * @return mixed each した結果
     */
    function array_each($array, $callback, $default = null)
    {
        if (func_num_args() === 2) {
            /** @var \ReflectionFunction $ref */
            $ref = reflect_callable($callback);
            $params = $ref->getParameters();
            if ($params[0]->isDefaultValueAvailable()) {
                $default = $params[0]->getDefaultValue();
            }
        }

        $n = 0;
        foreach ($array as $k => $v) {
            $return = $callback($default, $v, $k, $n++);
            if ($return === false) {
                break;
            }
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_explode') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_explode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_explode')) {
    /**
     * 配列を指定条件で分割する
     *
     * 文字列の explode を更に一階層掘り下げたイメージ。
     * $condition で指定された要素は結果配列に含まれない。
     *
     * $condition にはクロージャが指定できる。クロージャの場合は true 相当を返した場合に分割要素とみなされる。
     * 引数は (値, キー)の順番。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // null 要素で分割
     * that(array_explode(['a', null, 'b', 'c'], null))->isSame([['a'], [2 => 'b', 3 => 'c']]);
     * // クロージャで分割（大文字で分割）
     * that(array_explode(['a', 'B', 'c', 'D', 'e'], fn($v) => ctype_upper($v)))->isSame([['a'], [2 => 'c'], [4 => 'e']]);
     * // 負数指定
     * that(array_explode(['a', null, 'b', null, 'c'], null, -2))->isSame([[0 => 'a', 1 => null, 2 => 'b'], [4 => 'c']]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $condition 分割条件
     * @param int $limit 最大分割数
     * @return array 分割された配列
     */
    function array_explode($array, $condition, $limit = \PHP_INT_MAX)
    {
        $array = arrayval($array, false);

        $limit = (int) $limit;
        if ($limit < 0) {
            // キーまで考慮するとかなりややこしくなるので富豪的にやる
            $reverse = array_explode(array_reverse($array, true), $condition, -$limit);
            $reverse = array_map(fn($v) => array_reverse($v, true), $reverse);
            return array_reverse($reverse);
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }

        $result = [];
        $chunk = [];
        $n = -1;
        foreach ($array as $k => $v) {
            $n++;

            if ($limit === 1) {
                $chunk = array_slice($array, $n, null, true);
                break;
            }

            if ($condition instanceof \Closure) {
                $match = $condition($v, $k, $n);
            }
            else {
                $match = $condition === $v;
            }

            if ($match) {
                $limit--;
                $result[] = $chunk;
                $chunk = [];
            }
            else {
                $chunk[$k] = $v;
            }
        }
        $result[] = $chunk;
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_extend') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_extend'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_extend')) {
    /**
     * 独自拡張した array_replace_recursive
     *
     * 下記の点で array_replace_recursive と異なる。
     *
     * - 元配列のキーのみでフィルタされる
     * - 対象配列にクロージャを渡すと現在の状態を引数にしてコールバックされる
     * - 値に Generator や Generator 関数を渡すと最後にまとめて値化される
     *     - つまり、上書きされた値は実質的にコールされない
     * - recursive かどうかは 最初の引数で分岐する（jQuery の extend と同じ）
     * - recursive の場合、元配列の値が配列の場合のみ対象となる。配列でない場合は単純に上書きされる
     *     - 次の値が非配列の場合、末尾に追加される
     *     - 次の値がクロージャの場合、元の値を引数にしてコールバックされる
     *     - 次の値が配列の場合
     *         - 元配列が数値配列なら完全にマージされる
     *         - 元配列が連想配列なら再帰される
     *
     * この仕様上、Generator を値とする配列を対象にすることはできないが、そのような状況は稀だろう。
     * その代わり、使われるかどうか分からない状態でもとりあえず Generator にしておけば無駄な処理を省くことができる。
     *
     * Example:
     * ```php
     * # $deep ではない単純呼び出し
     * that(array_extend([
     *     'overwrite' => 'hoge',            // 後段で指定されているので上書きされる
     *     'through'   => 'fuga',            // 後段で指定されていないので生き残る
     *     'array'     => ['a', 'b', 'c'],   // $deep ではないし後段で指定されているので完全に上書きされる
     *     'yield1'    => fn() => yield 123, // 後段で指定されているのでコールすらされない
     *     'yield2'    => fn() => yield 456, // 後段で指定されていないのでコールされる
     * ], [
     *     'ignore'    => null,              // 元配列に存在しないのでスルーされる
     *     'overwrite' => 'HOGE',
     *     'array'     => ['x', 'y', 'z'],
     *     'yield1'    => fn() => yield 234,
     * ]))->is([
     *     'overwrite' => 'HOGE',
     *     'through'   => 'fuga',
     *     'array'     => ['x', 'y', 'z'],
     *     'yield1'    => 234,
     *     'yield2'    => 456,
     * ]);
     * # $deep の場合のマージ呼び出し
     * that(array_extend(true, [
     *     'array'    => ['hoge'],            // 後段がスカラーなので末尾に追加される
     *     'callback' => ['fuga'],            // 後段がクロージャなのでコールバックされる
     *     'list'     => ['a', 'b', 'c'],     // 数値配列なのでマージされる
     *     'hash'     => ['a' => null],       // 連想配列なので再帰される
     *     'yield'    => [fn() => yield 123], // generator は解決される
     * ], [
     *     'array'    => 'HOGE',
     *     'callback' => fn($v) => $v + [1 => 'FUGA'],
     *     'list'     => ['x', 'y', 'z'],
     *     'hash'     => ['a' => ['x' => ['y' => ['z' => 'xyz']]]],
     *     'yield'    => [fn() => yield 456],
     * ]))->is([
     *     'array'    => ['hoge', 'HOGE'],
     *     'callback' => ['fuga', 'FUGA'],
     *     'list'     => ['a', 'b', 'c', 'x', 'y', 'z'],
     *     'hash'     => ['a' => ['x' => ['y' => ['z' => 'xyz']]]],
     *     'yield'    => [123, 456],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|bool $default 基準となる配列
     * @param iterable|\Closure ...$arrays マージする配列
     * @return array 新しい配列
     */
    function array_extend($default = [], ...$arrays)
    {
        $deep = false;
        if (is_bool($default)) {
            if (!$arrays) {
                throw new \InvalidArgumentException('target is empry');
            }
            $deep = $default;
            $default = array_shift($arrays);
        }

        $result = $default;

        foreach ($arrays as $array) {
            if ($array instanceof \Closure) {
                $array = $array($result);
            }
            if (!is_iterable($array)) {
                throw new \InvalidArgumentException('target is not array');
            }

            foreach ($array as $k => $v) {
                if (!array_key_exists($k, $result)) {
                    continue;
                }
                $current = $result[$k];
                if ($deep && is_array($current)) {
                    if (is_array($v)) {
                        if (is_indexarray($current)) {
                            $v = array_merge($current, $v);
                            $current = array_fill_keys(array_keys($v), null);
                        }
                        $v = array_extend($deep, $current, $v);
                    }
                    elseif ($v instanceof \Closure) {
                        $v = $v($current);
                    }
                    else {
                        $current[] = $v;
                        $v = $current;
                    }
                }
                $result[$k] = $v;
            }
        }

        foreach ($result as $k => $v) {
            if ($v instanceof \Closure && (new \ReflectionFunction($v))->isGenerator()) {
                $v = $v();
            }
            if ($v instanceof \Generator) {
                $result[$k] = is_array($default[$k]) ? iterator_to_array($v) : $v->current();
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_fill_callback') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_fill_callback'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_fill_callback')) {
    /**
     * array_fill_keys のコールバック版のようなもの
     *
     * 指定したキー配列をそれらのマップしたもので配列を生成する。
     * `array_combine($keys, array_map($callback, $keys))` とほぼ等価。
     *
     * Example:
     * ```php
     * $abc = ['a', 'b', 'c'];
     * // [a, b, c] から [a => A, b => B, c => C] を作る
     * that(array_fill_callback($abc, 'strtoupper'))->isSame([
     *     'a' => 'A',
     *     'b' => 'B',
     *     'c' => 'C',
     * ]);
     * // [a, b, c] からその sha1 配列を作って大文字化する
     * that(array_fill_callback($abc, fn($v) => strtoupper(sha1($v))))->isSame([
     *     'a' => '86F7E437FAA5A7FCE15D1DDCB9EAEAEA377667B8',
     *     'b' => 'E9D71F5EE7C92D6DC9E92FFDAD17B8BD49418F98',
     *     'c' => '84A516841BA77A5B4648DE2CD0DFCB30EA46DBB4',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $keys キーとなる配列
     * @param callable $callback 要素のコールバック（引数でキーが渡ってくる）
     * @return array 新しい配列
     */
    function array_fill_callback($keys, $callback)
    {
        $keys = arrayval($keys, false);
        return array_combine($keys, array_map(func_user_func_array($callback), $keys));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_fill_gap') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_fill_gap'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_fill_gap')) {
    /**
     * 配列の隙間を埋める
     *
     * 「隙間」とは数値キーの隙間のこと。文字キーには関与しない。
     * 連番の抜けている箇所に $values の値を順次詰めていく動作となる。
     *
     * 値が足りなくてもエラーにはならない。つまり、この関数を通したとしても隙間が無くなるわけではない。
     * また、隙間を埋めても値が余る場合（隙間より与えられた値が多い場合）は末尾に全て追加される。
     *
     * 負数キーは考慮しない。
     *
     * Example:
     * ```php
     * // ところどころキーが抜け落ちている配列の・・・
     * $array = [
     *     1 => 'b',
     *     2 => 'c',
     *     5 => 'f',
     *     7 => 'h',
     * ];
     * // 抜けているところを可変引数で順次埋める（'i', 'j' は隙間というより末尾追加）
     * that(array_fill_gap($array, 'a', 'd', 'e', 'g', 'i', 'j'))->isSame([
     *     0 => 'a',
     *     1 => 'b',
     *     2 => 'c',
     *     3 => 'd',
     *     4 => 'e',
     *     5 => 'f',
     *     6 => 'g',
     *     7 => 'h',
     *     8 => 'i',
     *     9 => 'j',
     * ]);
     *
     * // 文字キーには関与しないし、値は足りなくても良い
     * $array = [
     *     1   => 'b',
     *     'x' => 'noize',
     *     4   => 'e',
     *     'y' => 'noize',
     *     7   => 'h',
     *     'z' => 'noize',
     * ];
     * // 文字キーはそのまま保持され、値が足りないので 6 キーはない
     * that(array_fill_gap($array, 'a', 'c', 'd', 'f'))->isSame([
     *     0   => 'a',
     *     1   => 'b',
     *     'x' => 'noize',
     *     2   => 'c',
     *     3   => 'd',
     *     4   => 'e',
     *     'y' => 'noize',
     *     5   => 'f',
     *     7   => 'h',
     *     'z' => 'noize',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param mixed ...$values 詰める値（可変引数）
     * @return array 隙間が詰められた配列
     */
    function array_fill_gap($array, ...$values)
    {
        $n = 0;
        $keys = array_keys($array);

        $result = [];
        for ($i = 0, $l = count($keys); $i < $l; $i++) {
            $key = $keys[$i];
            if (is_string($key)) {
                $result[$key] = $array[$key];
                continue;
            }

            if (array_key_exists($n, $array)) {
                $result[] = $array[$n];
            }
            elseif ($values) {
                $result[] = array_shift($values);
                $i--;
            }
            else {
                $result[$key] = $array[$key];
            }
            $n++;
        }
        if ($values) {
            $result = array_merge($result, $values);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_filter_map') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_filter_map'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_filter_map')) {
    /**
     * array_filter + array_map する
     *
     * コールバックを適用して、結果が !false 要素のみ取り出す。
     * コールバックの第1引数を参照にして書き換えると結果にも反映される。
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_filter_map([' a ', ' b ', ''], fn(&$v) => strlen($v) ? $v = trim($v) : false))->isSame(['a', 'b']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @return iterable $callback が !false を返し map された配列
     */
    function array_filter_map($array, $callback)
    {
        // Iterator だが ArrayAccess ではないオブジェクト（Generator とか）は unset できないので配列として扱わざるを得ない
        if (!(function_configure('array.variant') && is_arrayable($array))) {
            $array = arrayval($array, false);
        }

        $callback = func_user_func_array($callback);
        $n = 0;
        foreach (arrayval($array, false) as $k => $v) {
            $map = $callback($v, $k, $n++);
            if ($map === false) {
                unset($array[$k]);
            }
            else {
                $array[$k] = $v;
            }
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_filter_recursive') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_filter_recursive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_filter_recursive')) {
    /**
     * 再帰的に array_filter する
     *
     * 要素が配列だった場合に再帰する点とコールバックの引数以外は array_filter とほとんど変わらない。
     * $callback が要求するならキーも渡ってくる。
     *
     * $unset_empty:true だと再帰で伏せられた結果が空になった場合、そのキーも伏せられる。
     *
     * Example:
     * ```php
     * $array = [
     *     'a'  => 'A', // 生き残る
     *     'e'  => '',  // 生き残らない
     *     'a1' => [    // A がいるため $unset_empty は無関係に a1 自体も生き残る
     *         'A', // 生き残る
     *         '',  // 生き残らない
     *     ],
     *     'a2' => [    // 生き残りが居ないため $unset_empty:true だと a2 自体も生き残らない
     *         '',  // 生き残らない
     *         '',  // 生き残らない
     *     ],
     *     'b1' => [    // a1 のネスト版
     *         'a' => [
     *             'a' => 'A',
     *             'e' => '',
     *         ],
     *     ],
     *     'b2' => [    // a2 のネスト版
     *         'a' => [
     *             'a' => '',
     *             'e' => '',
     *         ],
     *     ],
     * ];
     * // 親を伏せない版
     * that(array_filter_recursive($array, fn($v) => strlen($v), false))->isSame([
     *     "a"  => "A",
     *     "a1" => ["A"],
     *     "a2" => [],
     *     "b1" => [
     *         "a" => [
     *             "a" => "A",
     *         ],
     *     ],
     *     "b2" => [
     *         "a" => [],
     *     ],
     * ]);
     * // 親を伏せる版
     * that(array_filter_recursive($array, fn($v) => strlen($v), true))->isSame([
     *     "a"  => "A",
     *     "a1" => ["A"],
     *     "b1" => [
     *         "a" => [
     *             "a" => "A",
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @template T as iterable&\ArrayAccess
     */
    function array_filter_recursive(
        /** @var T 対象配列 */ iterable $array,
        /** 評価クロージャ（値, キー, 親キー配列） */ callable $callback,
        /** 再帰の際に空になった要素も伏せるか */ bool $unset_empty = true,
    ): /** フィルタされた配列 */ iterable
    {
        $callback = func_user_func_array($callback);

        $main = function ($array, $parents) use (&$main, $callback, $unset_empty) {
            // オブジェクトによっては活きたイテレータなのでループ内で unset することはできず、あらかじめ集めておく必要がある（ArrayObject 等）
            $keys = [];
            foreach ($array as $k => $v) {
                $keys[] = $k;
            }

            foreach ($keys as $k) {
                if (is_iterable($array[$k]) && is_arrayable($array[$k])) {
                    $array[$k] = $main($array[$k], array_merge($parents, [$k]));
                    if ($unset_empty && is_empty($array[$k])) {
                        unset($array[$k]);
                    }
                }
                else {
                    if (!$callback($array[$k], $k, $parents)) {
                        unset($array[$k]);
                    }
                }
            }
            return $array;
        };
        return $main($array, []);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_filters') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_filters'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_filters')) {
    /**
     * 複数コールバックを指定できる array_filter
     *
     * 指定したコールバックで複数回回してフィルタする。
     * `array_filter($array, $f, $g)` は `array_filter(array_filter($array, $f), $g)` とほぼ等しい。
     * コールバックが要求するならキーも渡ってくる。
     * さらに文字列関数で "..." から始まっているなら可変引数としてコールする。
     *
     * 少し変わった仕様として、コールバックに [$method => $args] を付けるとそれはメソッド呼び出しになる。
     * つまり各要素 $v に対して `$v->$method(...$args)` がフィルタ結果になる。
     * さらに引数が不要なら `@method` とするだけで良い。
     *
     * Example:
     * ```php
     * // 非 null かつ小文字かつ16進数
     * that(array_filters(['abc', 'XYZ', null, 'ABC', 'ff', '3e7'],
     *     fn($v) => $v !== null,
     *     fn($v) => ctype_lower("$v"),
     *     fn($v) => ctype_xdigit("$v"),
     * ))->isSame([0 => 'abc', 4 => 'ff']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable ...$callbacks 評価クロージャ配列
     * @return array 評価クロージャでフィルタした新しい配列
     */
    function array_filters($array, ...$callbacks)
    {
        // Iterator だが ArrayAccess ではないオブジェクト（Generator とか）は unset できないので配列として扱わざるを得ない
        if (!(function_configure('array.variant') && is_arrayable($array))) {
            $array = arrayval($array, false);
        }

        foreach ($callbacks as $callback) {
            if (is_string($callback) && $callback[0] === '@') {
                $margs = [];
                $vargs = false;
                $callback = substr($callback, 1);
            }
            elseif (is_array($callback) && count($callback) === 1) {
                $margs = reset($callback);
                $vargs = false;
                $callback = key($callback);
            }
            elseif (is_string($callback) && substr($callback, 0, 3) === '...') {
                $margs = null;
                $vargs = true;
                $callback = substr($callback, 3);
            }
            else {
                $margs = null;
                $vargs = false;
                $callback = func_user_func_array($callback);
            }
            $n = 0;
            foreach (arrayval($array, false) as $k => $v) {
                if (isset($margs)) {
                    $flag = ([$v, $callback])(...$margs);
                }
                elseif ($vargs) {
                    $flag = $callback(...$v);
                }
                else {
                    $flag = $callback($v, $k, $n++);
                }

                if (!$flag) {
                    unset($array[$k]);
                }
            }
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_find') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_find'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_find')) {
    /**
     * array_search のクロージャ版のようなもの
     *
     * コールバックの返り値が true 相当のものを返す。
     * $is_key に true を与えるとそのキーを返す（デフォルトの動作）。
     * $is_key に false を与えるとコールバックの結果を返す。
     *
     * この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。
     *
     * Example:
     * ```php
     * // 最初に見つかったキーを返す
     * that(array_find(['a', '8', '9'], 'ctype_digit'))->isSame(1);
     * that(array_find(['a', 'b', 'b'], fn($v) => $v === 'b'))->isSame(1);
     * // 最初に見つかったコールバック結果を返す（最初の数字の2乗を返す）
     * $ifnumeric2power = fn($v) => ctype_digit($v) ? $v * $v : false;
     * that(array_find(['a', '8', '9'], $ifnumeric2power, false))->isSame(64);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 調べる配列
     * @param callable $callback 評価コールバック
     * @param bool $is_key キーを返すか否か
     * @return mixed コールバックが true を返した最初のキー。存在しなかったら null
     */
    function array_find($array, $callback, $is_key = true)
    {
        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            $result = $callback($v, $k, $n++);
            if ($result) {
                if ($is_key) {
                    return $k;
                }
                return $result;
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_find_last') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_find_last'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_find_last')) {
    /**
     * array_find の後ろから探す版
     *
     * コールバックの返り値が true 相当のものを返す。
     * $is_key に true を与えるとそのキーを返す（デフォルトの動作）。
     * $is_key に false を与えるとコールバックの結果を返す。
     *
     * この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。
     *
     * Example:
     * ```php
     * // 最後に見つかったキーを返す
     * that(array_find_last(['a', '8', '9'], 'ctype_digit'))->isSame(2);
     * that(array_find_last(['a', 'b', 'b'], fn($v) => $v === 'b'))->isSame(2);
     * // 最後に見つかったコールバック結果を返す（最初の数字の2乗を返す）
     * $ifnumeric2power = fn($v) => ctype_digit($v) ? $v * $v : false;
     * that(array_find_last(['a', '8', '9'], $ifnumeric2power, false))->isSame(81);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 調べる配列
     * @param callable $callback 評価コールバック
     * @param bool $is_key キーを返すか否か
     * @return mixed コールバックが true を返した最初のキー。存在しなかったら false
     */
    function array_find_last($array, $callback, $is_key = true)
    {
        // 配列なら reverse すればよい
        if (is_array($array)) {
            return array_find(array_reverse($array, true), $callback, $is_key);
        }

        $callback = func_user_func_array($callback);

        // イテレータは全ループするしかない
        $return = $notfound = new \stdClass();
        $n = 0;
        foreach ($array as $k => $v) {
            $result = $callback($v, $k, $n++);
            if ($result) {
                $return = $is_key ? $k : $result;
            }
        }
        return $return === $notfound ? false : $return;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_find_recursive') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_find_recursive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_find_recursive')) {
    /**
     * array_find の再帰版
     *
     * コールバックの返り値が true 相当のものを返す。
     * $is_key に true を与えるとそのキー配列を返す（デフォルトの動作）。
     * $is_key に false を与えるとコールバックの結果を返す。
     *
     * この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。
     *
     * Example:
     * ```php
     * // 最初に見つかったキーを配列で返す
     * that(array_find_recursive([
     *     'a' => [
     *         'b' => [
     *             'c' => [1, 2, 3],
     *         ],
     *     ],
     * ], fn($v) => $v === 2))->isSame(['a', 'b', 'c', 1]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 調べる配列
     * @param callable $callback 評価コールバック
     * @param bool $is_key キーを返すか否か
     * @return mixed コールバックが true を返した最初のキー。存在しなかったら false
     */
    function array_find_recursive($array, $callback, $is_key = true)
    {
        $callback = func_user_func_array($callback);

        $notfound = new \stdClass();
        $main = function ($array, $keys, $parents) use (&$main, $notfound, $callback, $is_key) {
            $parents[] = $array;
            foreach ($array as $k => $v) {
                $result = $callback($v, $k, $keys);
                if ($result) {
                    if ($is_key) {
                        return [...$keys, $k];
                    }
                    return $result;
                }

                if (is_iterable($v)) {
                    if (in_array($v, $parents, true)) {
                        continue;
                    }

                    $return = $main($v, [...$keys, $k], $parents);
                    if ($return !== $notfound) {
                        return $return;
                    }
                }
            }
            return $notfound;
        };

        $return = $main($array, [], []);
        return $return === $notfound ? false : $return;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_flatten') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_flatten'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_flatten')) {
    /**
     * 多階層配列をフラットに展開する
     *
     * 巷にあふれている実装と違って、 ["$pkey.$ckey" => $value] 形式の配列でも返せる。
     * $delimiter で区切り文字を指定した場合にそのようになる。
     * $delimiter = null の場合に本当の配列で返す（巷の実装と同じ）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *            'k223' => [1, 2, 3],
     *        ],
     *    ],
     * ];
     * // 区切り文字指定なし
     * that(array_flatten($array))->isSame([
     *    0 => 'v1',
     *    1 => 'v21',
     *    2 => 'v221',
     *    3 => 'v222',
     *    4 => 1,
     *    5 => 2,
     *    6 => 3,
     * ]);
     * // 区切り文字指定
     * that(array_flatten($array, '.'))->isSame([
     *    'k1'            => 'v1',
     *    'k2.k21'        => 'v21',
     *    'k2.k22.k221'   => 'v221',
     *    'k2.k22.k222'   => 'v222',
     *    'k2.k22.k223.0' => 1,
     *    'k2.k22.k223.1' => 2,
     *    'k2.k22.k223.2' => 3,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|\Closure|null $delimiter キーの区切り文字。 null を与えると連番になる
     * @return array フラット化された配列
     */
    function array_flatten($array, $delimiter = null)
    {
        $result = [];
        $core = function ($array, $delimiter, $parents) use (&$core, &$result) {
            foreach ($array as $k => $v) {
                $keys = $parents;
                $keys[] = $k;
                if (is_iterable($v)) {
                    $core($v, $delimiter, $keys);
                }
                else {
                    if ($delimiter === null) {
                        $result[] = $v;
                    }
                    elseif ($delimiter instanceof \Closure) {
                        $result[$delimiter($keys)] = $v;
                    }
                    else {
                        $result[implode($delimiter, $keys)] = $v;
                    }
                }
            }
        };

        $core($array, $delimiter, []);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_get') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_get'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_get')) {
    /**
     * デフォルト値付きの配列値取得
     *
     * 存在しない場合は $default を返す。
     *
     * $key に配列を与えるとそれらの値の配列を返す（lookup 的な動作）。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを返す。
     * その際、 $default が配列なら一致するものを配列で返し、配列でないなら単値で返す。
     *
     * Example:
     * ```php
     * // 単純取得
     * that(array_get(['a', 'b', 'c'], 1))->isSame('b');
     * // 単純デフォルト
     * that(array_get(['a', 'b', 'c'], 9, 999))->isSame(999);
     * // 配列取得
     * that(array_get(['a', 'b', 'c'], [0, 2]))->isSame([0 => 'a', 2 => 'c']);
     * // 配列部分取得
     * that(array_get(['a', 'b', 'c'], [0, 9]))->isSame([0 => 'a']);
     * // 配列デフォルト（null ではなく [] を返す）
     * that(array_get(['a', 'b', 'c'], [9]))->isSame([]);
     * // クロージャ指定＆単値（コールバックが true を返す最初の要素）
     * that(array_get(['a', 'b', 'c'], fn($v) => in_array($v, ['b', 'c'])))->isSame('b');
     * // クロージャ指定＆配列（コールバックが true を返すもの）
     * that(array_get(['a', 'b', 'c'], fn($v) => in_array($v, ['b', 'c']), []))->isSame([1 => 'b', 2 => 'c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\ArrayAccess $array 配列
     * @param string|int|array|\Closure $key 取得したいキー。配列を与えると全て返す。クロージャの場合は true 相当を返す
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_get($array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $k) {
                if (array_keys_exist($k, $array)) {
                    $result[$k] = $array[$k];
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    if (func_num_args() === 2) {
                        return $v;
                    }
                    $result[$k] = $v;
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            return $array[$key];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_grep_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_grep_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_grep_key')) {
    /**
     * キーを正規表現でフィルタする
     *
     * Example:
     * ```php
     * that(array_grep_key(['a' => 'A', 'aa' => 'AA', 'b' => 'B'], '#^a#'))->isSame(['a' => 'A', 'aa' => 'AA']);
     * that(array_grep_key(['a' => 'A', 'aa' => 'AA', 'b' => 'B'], '#^a#', true))->isSame(['b' => 'B']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string $regex 正規表現
     * @param bool $not true にすると「マッチしない」でフィルタする
     * @return array 正規表現でフィルタされた配列
     */
    function array_grep_key($array, $regex, $not = false)
    {
        $array = is_array($array) ? $array : iterator_to_array($array);
        $keys = array_keys($array);
        $greped = preg_grep($regex, $keys, $not ? PREG_GREP_INVERT : 0);
        $flipped = array_flip($greped);
        return array_intersect_key($array, $flipped);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_group') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_group'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_group')) {
    /**
     * 配列をコールバックの返り値でグループ化する
     *
     * コールバックを省略すると値そのもので評価する。
     * コールバックに配列・文字列を与えるとキーでグループ化する。
     * コールバックが配列を返すと入れ子としてグループ化する。
     *
     * Example:
     * ```php
     * that(array_group([1, 1, 1]))->isSame([
     *     1 => [1, 1, 1],
     * ]);
     * that(array_group([1, 2, 3], fn($v) => $v % 2))->isSame([
     *     1 => [1, 3],
     *     0 => [2],
     * ]);
     * // group -> id で入れ子グループにする
     * $row1 = ['id' => 1, 'group' => 'hoge'];
     * $row2 = ['id' => 2, 'group' => 'fuga'];
     * $row3 = ['id' => 3, 'group' => 'hoge'];
     * that(array_group([$row1, $row2, $row3], fn($row) => [$row['group'], $row['id']]))->isSame([
     *     'hoge' => [
     *         1 => $row1,
     *         3 => $row3,
     *     ],
     *     'fuga' => [
     *         2 => $row2,
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable|string|array $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool $preserve_keys キーを保存するか。 false の場合数値キーは振り直される
     * @return array グルーピングされた配列
     */
    function array_group($array, $callback = null, $preserve_keys = false)
    {
        if ($callback !== null && !is_callable($callback)) {
            $callback = array_of($callback);
        }
        $callback = func_user_func_array($callback);

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $vv = $callback($v, $k, $n++);
            // 配列は潜る
            if (is_array($vv)) {
                $tmp = &$result;
                foreach ($vv as $vvv) {
                    $tmp = &$tmp[$vvv];
                }
                $tmp = $v;
                unset($tmp);
            }
            elseif (!$preserve_keys && is_int($k)) {
                $result[$vv][] = $v;
            }
            else {
                $result[$vv][$k] = $v;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_implode') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_implode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_implode')) {
    /**
     * 配列の各要素の間に要素を差し込む
     *
     * 歴史的な理由はないが、引数をどちらの順番でも受けつけることが可能。
     * ただし、$glue を先に渡すパターンの場合は配列指定が可変引数渡しになる。
     *
     * 文字キーは保存されるが数値キーは再割り振りされる。
     *
     * Example:
     * ```php
     * // (配列, 要素) の呼び出し
     * that(array_implode(['a', 'b', 'c'], 'X'))->isSame(['a', 'X', 'b', 'X', 'c']);
     * // (要素, ...配列) の呼び出し
     * that(array_implode('X', 'a', 'b', 'c'))->isSame(['a', 'X', 'b', 'X', 'c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|string $array 対象配列
     * @param string $glue 差し込む要素
     * @return array 差し込まれた配列
     */
    function array_implode($array, $glue)
    {
        // 第1引数が回せない場合は引数を入れ替えて可変引数パターン
        if (!is_array($array) && !$array instanceof \Traversable) {
            return array_implode(array_slice(func_get_args(), 1), $array);
        }

        $result = [];
        foreach ($array as $k => $v) {
            if (is_int($k)) {
                $result[] = $v;
            }
            else {
                $result[$k] = $v;
            }
            $result[] = $glue;
        }
        array_pop($result);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_insert') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_insert'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_insert')) {
    /**
     * 配列・連想配列を問わず任意の位置に値を挿入する
     *
     * $position を省略すると最後に挿入される（≒ array_push）。
     * $position に負数を与えると後ろから数えられる。
     * $value には配列も与えられるが、その場合数値キーは振り直される
     *
     * Example:
     * ```php
     * that(array_insert([1, 2, 3], 'x'))->isSame([1, 2, 3, 'x']);
     * that(array_insert([1, 2, 3], 'x', 1))->isSame([1, 'x', 2, 3]);
     * that(array_insert([1, 2, 3], 'x', -1))->isSame([1, 2, 'x', 3]);
     * that(array_insert([1, 2, 3], ['a' => 'A', 'b' => 'B'], 1))->isSame([1, 'a' => 'A', 'b' => 'B', 2, 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param mixed $value 挿入値
     * @param int|null $position 挿入位置
     * @return array 挿入された新しい配列
     */
    function array_insert($array, $value, $position = null)
    {
        if (!is_array($value)) {
            $value = [$value];
        }

        $position = is_null($position) ? count($array) : intval($position);

        $sarray = array_splice($array, 0, $position);
        return array_merge($sarray, $value, $array);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_join') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_join'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_join')) {
    /**
     * 配列の SQL 的な JOIN を行う
     *
     * $from に対して $on を満たす $join の行を結合する。
     * $from,$join は共にいわゆる「配列の配列」でなければならない。
     *
     * $on は各レコードが渡ってくるので、true を返せば結合、false を返せば結合されない。
     * $on には配列も渡すことができ、配列を渡した場合は USING 的な動作になる。
     * - キーが駆動表のカラム名、値が結合表のカラム名を表す
     * - キーの値同士を json で判定する（厳密に言えば値を json キーにした一時配列で逆引きされる）
     * - 複数指定時は AND になる
     * 上記の前提・制約が許容できるなら配列指定の方が高速に動作する。
     *
     * join 後のキーは各キーを "+" で連結したものになるが、このキーは暫定的なもの。
     *
     * Example:
     * ```php
     * // t_article と t_comment の JOIN（のイメージ）
     * $articles = [
     *     2 => ['article_id' => 2, 'article_name' => 'hoge'],
     *     4 => ['article_id' => 4, 'article_name' => 'fuga'],
     *     5 => ['article_id' => 5, 'article_name' => 'piyo'],
     * ];
     * $comments = [
     *     4 => ['comment_id' => 4, 'article_id' => 2, 'comment' => 'foo'],
     *     6 => ['comment_id' => 6, 'article_id' => 4, 'comment' => 'bar'],
     *     7 => ['comment_id' => 7, 'article_id' => 4, 'comment' => 'baz'],
     *     9 => ['comment_id' => 9, 'article_id' => 9, 'comment' => 'dmy'],
     * ];
     * // INNER っぽい動き
     * that(array_join($articles, $comments, fn($article, $comment) => $article['article_id'] === $comment['article_id'], false))->isSame([
     *     '2+4' => ['article_id' => 2, 'article_name' => 'hoge', 'comment_id' => 4, 'comment' => 'foo'],
     *     '4+6' => ['article_id' => 4, 'article_name' => 'fuga', 'comment_id' => 6, 'comment' => 'bar'],
     *     '4+7' => ['article_id' => 4, 'article_name' => 'fuga', 'comment_id' => 7, 'comment' => 'baz'],
     * ]);
     * // LEFT っぽい動き
     * that(array_join($articles, $comments, fn($article, $comment) => $article['article_id'] === $comment['article_id'], true))->isSame([
     *     '2+4'    => ['article_id' => 2, 'article_name' => 'hoge', 'comment_id' => 4, 'comment' => 'foo'],
     *     '4+6'    => ['article_id' => 4, 'article_name' => 'fuga', 'comment_id' => 6, 'comment' => 'bar'],
     *     '4+7'    => ['article_id' => 4, 'article_name' => 'fuga', 'comment_id' => 7, 'comment' => 'baz'],
     *     '5+null' => ['article_id' => 5, 'article_name' => 'piyo', 'comment_id' => null, 'comment' => null],
     * ]);
     * // ↑のような単純比較クロージャなら配列でも指定できる（そしてこの方がはるかに速い）
     * that(array_join($articles, $comments, ['article_id' => 'article_id'], false))->isSame([
     *     '2+4' => ['article_id' => 2, 'article_name' => 'hoge', 'comment_id' => 4, 'comment' => 'foo'],
     *     '4+6' => ['article_id' => 4, 'article_name' => 'fuga', 'comment_id' => 6, 'comment' => 'bar'],
     *     '4+7' => ['article_id' => 4, 'article_name' => 'fuga', 'comment_id' => 7, 'comment' => 'baz'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|iterable&\ArrayAccess<\ArrayAccess> $from 駆動表
     * @param array|iterable&\ArrayAccess<\ArrayAccess> $join 結合表
     * @param array|callable $on 結合条件。原則として callable で、ある程度の前提制約が置けるときのみ配列を指定する
     * @param bool $outer true だと OUTER, false だと INNER 的挙動になる
     * @return array JOIN された配列
     */
    function array_join($from, $join, $on, bool $outer = false): array
    {
        $arraymode = $on && is_array($on) && !is_callable($on);

        if ($arraymode) {
            // なぜ json でキーにするのか？ 個別インデックスや文字結合ではダメなのか？
            // ダメ。null と空文字が区別できない

            $left_cols = array_flip(array_keys($on));
            $right_cols = array_flip(array_values($on));

            // カラム値をキー、元キーを値としたいわゆるインデックスを作成しておく
            $index = [];
            foreach ($join as $j => $right) {
                $rcols = array_pickup($right, $right_cols);
                // 一つでも存在しないならマッチさせない
                if (count($rcols) === count($right_cols)) {
                    $index[json_encode($rcols)][] = $j;
                }
            }
        }
        else {
            // 空配列（無条件結合）はこっちに流れてくる
            $on = $on ?: fn() => true;
        }

        // $outer で未結合の時のデフォルト行をあらかじめ作っておく
        if ($outer) {
            $cols = [];
            foreach ($join as $right) {
                $cols += $right;
            }
            $nullrow = array_map(fn() => null, $cols);
        }

        $result = [];
        foreach ($from as $i => $left) {
            $matched_rows = [];

            if ($arraymode) {
                foreach ($index[json_encode(array_pickup($left, $left_cols))] ?? [] as $j) {
                    $matched_rows["$i+$j"] = $left + $join[$j];
                }
            }
            else {
                foreach ($join as $j => $right) {
                    if ($on($left, $right)) {
                        $matched_rows["$i+$j"] = $left + $right;
                    }
                }
            }

            if ($outer && !$matched_rows) {
                $matched_rows["$i+null"] = $left + $nullrow;
            }
            $result += $matched_rows;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_keys_exist') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_keys_exist'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_keys_exist')) {
    /**
     * array_key_exists の複数版
     *
     * 指定キーが全て存在するなら true を返す。
     * 配列ではなく単一文字列を与えても動作する（array_key_exists と全く同じ動作になる）。
     *
     * $keys に空を与えると例外を投げる。
     * $keys に配列を与えるとキーで潜ってチェックする（Example 参照）。
     *
     * Example:
     * ```php
     * // すべて含むので true
     * that(array_keys_exist(['a', 'b', 'c'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isTrue();
     * // N は含まないので false
     * that(array_keys_exist(['a', 'b', 'N'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isFalse();
     * // 配列を与えると潜る（日本語で言えば「a というキーと、x というキーとその中に x1, x2 というキーがあるか？」）
     * that(array_keys_exist(['a', 'x' => ['x1', 'x2']], ['a' => 'A', 'x' => ['x1' => 'X1', 'x2' => 'X2']]))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|string $keys 調べるキー
     * @param array|\ArrayAccess $array 調べる配列
     * @return bool 指定キーが全て存在するなら true
     */
    function array_keys_exist($keys, $array)
    {
        $keys = is_iterable($keys) ? $keys : [$keys];
        if (is_empty($keys)) {
            throw new \InvalidArgumentException('$keys is empty.');
        }

        $is_arrayaccess = $array instanceof \ArrayAccess;

        foreach ($keys as $k => $key) {
            if (is_array($key)) {
                // まずそのキーをチェックして
                if (!array_keys_exist($k, $array)) {
                    return false;
                }
                // あるなら再帰する
                if (!array_keys_exist($key, $array[$k])) {
                    return false;
                }
            }
            elseif ($is_arrayaccess) {
                if (!$array->offsetExists($key)) {
                    return false;
                }
            }
            elseif (!array_key_exists($key, $array)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_kvmap') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_kvmap'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_kvmap')) {
    /**
     * 配列の各キー・値にコールバックを適用する
     *
     * $callback は (キー, 値, $callback) が渡ってくるので 「その位置に配置したい配列」を返せばそこに置換される。
     * つまり、空配列を返せばそのキー・値は消えることになるし、複数の配列を返せば要素が増えることになる。
     * ただし、数値キーは新しく採番される。
     * null を返すと特別扱いで、そのキー・値をそのまま維持する。
     * iterable を返す必要があるが、もし iterable でない場合は配列キャストされる。
     *
     * 「map も filter も可能でキー変更可能」というとてもマッチョな関数。
     * 実質的には「数値キーが再採番される再帰的でない array_convert」のように振る舞う。
     * ただし、再帰処理はないので自前で管理する必要がある。
     *
     * Example:
     * ```php
     * $array = [
     *    'a' => 'A',
     *    'b' => 'B',
     *    'c' => 'C',
     *    'd' => 'D',
     * ];
     * // キーに '_' 、値に 'prefix-' を付与。'b' は一切何もしない。'c' は値のみ。'd' はそれ自体伏せる
     * that(array_kvmap($array, function ($k, $v) {
     *     if ($k === 'b') return null;
     *     if ($k === 'd') return [];
     *     if ($k !== 'c') $k = "_$k";
     *     return [$k => "prefix-$v"];
     * }))->isSame([
     *     '_a' => 'prefix-A',
     *     'b'  => 'B',
     *     'c'  => 'prefix-C',
     * ]);
     *
     * // 複数返せばその分増える（要素の水増し）
     * that(array_kvmap($array, fn($k, $v) => [
     *     "{$k}1" => "{$v}1",
     *     "{$k}2" => "{$v}2",
     * ]))->isSame([
     *    'a1' => 'A1',
     *    'a2' => 'A2',
     *    'b1' => 'B1',
     *    'b2' => 'B2',
     *    'c1' => 'C1',
     *    'c2' => 'C2',
     *    'd1' => 'D1',
     *    'd2' => 'D2',
     * ]);
     *
     * // $callback には $callback 自体も渡ってくるので再帰も比較的楽に書ける
     * that(array_kvmap([
     *     'x' => [
     *         'X',
     *         'y' => [
     *             'Y',
     *             'z' => ['Z'],
     *         ],
     *     ],
     * ], function ($k, $v, $callback) {
     *     // 配列だったら再帰する
     *     return ["_$k" => is_array($v) ? array_kvmap($v, $callback) : "prefix-$v"];
     * }))->isSame([
     *     "_x" => [
     *         "_0" => "prefix-X",
     *         "_y" => [
     *             "_0" => "prefix-Y",
     *             "_z" => [
     *                 "_0" => "prefix-Z",
     *             ],
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 適用するコールバック
     * @return array 変換された配列
     */
    function array_kvmap($array, $callback)
    {
        $result = [];
        foreach ($array as $k => $v) {
            $kv = $callback($k, $v, $callback) ?? [$k => $v];
            if (!is_iterable($kv)) {
                $kv = [$kv];
            }
            // $result = array_merge($result, $kv); // 遅すぎる
            foreach ($kv as $k2 => $v2) {
                if (is_int($k2)) {
                    $result[] = $v2;
                }
                else {
                    $result[$k2] = $v2;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_limit') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_limit'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_limit')) {
    /**
     * limit を主体とした array_slice
     *
     * 「配列の上から/下からN件取りたい」というユースケースがそれなりに多いが、毎回迷う上に1文で書けないので関数化した。
     *
     * $limit が負数の場合は戻って読む。
     * $offset 省略時は $limit の符号で自動で先頭か末尾になる。
     * $offset を指定することは少なく、端的に言えば「$limit が整数なら先頭から、負数なら末尾から $limit 件返す」と考えてもよい。
     * 配列を無限数直線にマッピングし、位置範囲指定で切り取るイメージ。
     * 文章で書くと複雑なので Example を参照。
     *
     * また、「array_slice しても結果が変わらないケース」でコールせずに結果を返すようにしてある。
     * （結果が変わらなくても無駄に呼ばれて速度低下があるため）。
     * 例えば `array_slice($array, 0, 0)` は必ず空配列を返すし `array_slice($array, 0, null)` は必ず元の配列を返すはず。
     * にも関わらず array_slice は愚直に切り取り処理をしているようで、その分岐の有る無しで速度がだいぶ違う。
     *
     * $preserve_keys は array_slice と同じだが、 null を渡すと「通常配列時に true, 連想配列時に false」が動的に決まるようになる。
     * ユースケースとしてはそのような使い方が多いはず。
     * あくまで null 指定の場合のみなのでこの動作が嫌なら明示的に bool を渡せばよい。
     *
     * Example:
     * ```php
     * $array = ['a', 'b', 'c', 'd', 'e'];
     *
     * that(array_limit($array, 3))->isSame(['a', 'b', 'c']);     // シンプルに先頭から3件
     * that(array_limit($array, -3))->isSame(['c', 'd', 'e']);    // シンプルに末尾から3件
     *
     * that(array_limit($array, 3, 1))->isSame(['b', 'c', 'd']);  // 1番目（'b'）から正順に3件
     * that(array_limit($array, -3, 1))->isSame(['a', 'b']);      // 1番目（'b'）から逆順に3件（足りないので結果は2件）
     *
     * that(array_limit($array, 3, 3))->isSame(['d', 'e']);       // 3番目（'d'）から正順に3件（足りないので結果は2件）
     * that(array_limit($array, -3, 3))->isSame(['b', 'c', 'd']); // 3番目（'d'）から逆順に3件
     *
     * that(array_limit($array, 3, -2))->isSame(['a']);           // -2番目（範囲外）から正順に3件（'a'だけがギリギリ範囲に入る）
     * that(array_limit($array, -3, 6))->isSame(['e']);           // 6番目（範囲外）から逆順に3件（'e'だけがギリギリ範囲に入る）
     *
     * that(array_limit($array, 3, -100))->isSame([]);            // -100番目（範囲外）から正順に3件（完全に範囲外なので空）
     * that(array_limit($array, -3, 100))->isSame([]);            // 100番目（範囲外）から逆順に3件（完全に範囲外なので空）
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param int $limit 切り詰めるサイズ
     * @param ?int $offset 開始位置
     * @param ?bool $preserve_keys キーの保存フラグ（null にすると連想配列の時のみ保存される）
     * @return array slice した配列
     */
    function array_limit($array, $limit, $offset = null, $preserve_keys = null)
    {
        $array = arrayval($array, false);
        $count = count($array);

        // $offset 省略時は $limit の符号に応じて最初か最後
        $offset ??= $limit >= 0 ? 0 : $count - 1;

        // 負から負方向は必ず空
        if ($offset < 0 && $limit < 0) {
            return [];
        }

        // 負数 $limit は戻る方向
        if ($limit < 0) {
            $offset += $limit + 1;
            $limit = -$limit;
        }

        // 負数 $offset は0補正
        if ($offset < 0) {
            $limit += $offset;
            $offset = 0;
        }

        // 完全に範囲外なら slice するまでもなく空
        if ($offset + $limit <= 0 || $count <= $offset) {
            return [];
        }

        // 完全に範囲一致なら slice するまでもなく元の配列
        if ($offset <= 0 && $count <= $limit) {
            return $array;
        }

        return array_slice($array, $offset, $limit, $preserve_keys ?? is_hasharray($array));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_lookup') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_lookup'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_lookup')) {
    /**
     * キー保存可能な array_column
     *
     * array_column は キーを保存することが出来ないが、この関数は引数を2つだけ与えるとキーはそのままで array_column 相当の配列を返す。
     * 逆に第3引数にクロージャを与えるとその結果をキーにすることが出来る。
     *
     * Example:
     * ```php
     * $array = [
     *     11 => ['id' => 1, 'name' => 'name1'],
     *     12 => ['id' => 2, 'name' => 'name2'],
     *     13 => ['id' => 3, 'name' => 'name3'],
     * ];
     * // 第3引数を渡せば array_column と全く同じ
     * that(array_lookup($array, 'name', 'id'))->isSame(array_column($array, 'name', 'id'));
     * that(array_lookup($array, 'name', null))->isSame(array_column($array, 'name', null));
     * // 省略すればキーが保存される
     * that(array_lookup($array, 'name'))->isSame([
     *     11 => 'name1',
     *     12 => 'name2',
     *     13 => 'name3',
     * ]);
     * // クロージャを指定すればキーが生成される
     * that(array_lookup($array, 'name', fn($v, $k) => $k * 2))->isSame([
     *     22 => 'name1',
     *     24 => 'name2',
     *     26 => 'name3',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|null $column_key 値となるキー
     * @param string|\Closure|null $index_key キーとなるキー
     * @return array 新しい配列
     */
    function array_lookup($array, $column_key = null, $index_key = null)
    {
        $array = arrayval($array, false);

        if ($index_key instanceof \Closure) {
            return array_combine(array_maps($array, $index_key), array_column($array, $column_key));
        }
        if (func_num_args() === 3) {
            return array_column($array, $column_key, $index_key);
        }
        return array_combine(array_keys($array), array_column($array, $column_key));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_map_filter') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_map_filter'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_map_filter')) {
    /**
     * array_map + array_filter する
     *
     * コールバックを適用して、結果が true 相当の要素のみ取り出す。
     * $strict に true を与えると「null でない」要素のみ返される。
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_map_filter([' a ', ' b ', ''], 'trim'))->isSame(['a', 'b']);
     * that(array_map_filter([' a ', ' b ', ''], 'trim', true))->isSame(['a', 'b', '']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @param bool $strict 厳密比較フラグ。 true だと null のみが偽とみなされる
     * @return iterable $callback が真を返した新しい配列
     */
    function array_map_filter($array, $callback, $strict = false)
    {
        // Iterator だが ArrayAccess ではないオブジェクト（Generator とか）は unset できないので配列として扱わざるを得ない
        if (!(function_configure('array.variant') && is_arrayable($array))) {
            $array = arrayval($array, false);
        }

        $callback = func_user_func_array($callback);
        $n = 0;
        foreach (arrayval($array, false) as $k => $v) {
            $vv = $callback($v, $k, $n++);
            if (($strict && $vv !== null) || (!$strict && $vv)) {
                $array[$k] = $vv;
            }
            else {
                unset($array[$k]);
            }
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_map_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_map_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_map_key')) {
    /**
     * キーをマップして変換する
     *
     * $callback が null を返すとその要素は取り除かれる。
     *
     * Example:
     * ```php
     * that(array_map_key(['a' => 'A', 'b' => 'B'], 'strtoupper'))->isSame(['A' => 'A', 'B' => 'B']);
     * that(array_map_key(['a' => 'A', 'b' => 'B'], function () { }))->isSame([]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @return array キーが変換された新しい配列
     */
    function array_map_key($array, $callback)
    {
        $callback = func_user_func_array($callback);
        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $k2 = $callback($k, $v, $n++);
            if ($k2 !== null) {
                $result[$k2] = $v;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_map_recursive') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_map_recursive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_map_recursive')) {
    /**
     * array_map の再帰版
     *
     * 下記の点で少し array_map とは挙動が異なる。
     *
     * - 配列だけでなく iterable も対象になる（引数で指定可能。デフォルト true）
     *     - つまりオブジェクト構造は維持されず、結果はすべて配列になる
     * - 値だけでなくキーも渡ってくる
     *
     * Example:
     * ```php
     * // デフォルトでは array_walk 等と同様に葉のみが渡ってくる（iterable も対象になる）
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => new \ArrayObject([
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ]),
     * ], 'strtoupper'))->isSame([
     *     'k' => 'V',
     *     'c' => [
     *         'k1' => 'V1',
     *         'k2' => 'V2',
     *     ],
     * ]);
     *
     * // ただし、その挙動は引数で変更可能
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => new \ArrayObject([
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ]),
     * ], 'gettype', false))->isSame([
     *     'k' => 'string',
     *     'c' => 'object',
     * ]);
     *
     * // さらに、自身にも適用できる（呼び出しは子が先で、本当の意味で「すべての要素」で呼び出される）
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => [
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ],
     * ], function ($v) {
     *     // 配列は stdclass 化、それ以外は大文字化
     *     return is_array($v) ? (object) $v : strtoupper($v);
     * }, true, true))->is((object) [
     *     'k' => 'V',
     *     'c' => (object) [
     *         'k1' => 'V1',
     *         'k2' => 'V2',
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @param bool $iterable is_iterable で判定するか
     * @param bool $apply_array 配列要素にもコールバックを適用するか
     * @return array map された新しい配列
     */
    function array_map_recursive($array, $callback, $iterable = true, $apply_array = false)
    {
        $callback = func_user_func_array($callback);

        // ↑の変換を再帰ごとにやるのは現実的ではないのでクロージャに閉じ込めて再帰する
        $main = static function ($array, $parent) use (&$main, $callback, $iterable, $apply_array) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if (($iterable && is_iterable($v)) || (!$iterable && is_array($v))) {
                    $result[$k] = $main($v, $k);
                }
                else {
                    $result[$k] = $callback($v, $k, $n++);
                }
            }
            if ($apply_array) {
                return $callback($result, $parent, null);
            }
            return $result;
        };

        return $main($array, null);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_maps') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_maps'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_maps')) {
    /**
     * 複数コールバックを指定できる array_map
     *
     * 指定したコールバックで複数回回してマップする。
     * `array_maps($array, $f, $g)` は `array_map($g, array_map($f, $array))` とほぼ等しい。
     * ただし、引数は順番が違う（可変引数のため）し、コールバックが要求するならキーも渡ってくる。
     * さらに文字列関数で "..." から始まっているなら可変引数としてコールする。
     *
     * 少し変わった仕様として、コールバックに [$method => $args] を付けるとそれはメソッド呼び出しになる。
     * つまり各要素 $v に対して `$v->$method(...$args)` がマップ結果になる。
     * さらに引数が不要なら `@method` とするだけで良い。
     *
     * Example:
     * ```php
     * // 値を3乗したあと16進表記にして大文字化する
     * that(array_maps([1, 2, 3, 4, 5], fn($v) => pow($v, 3), 'dechex', 'strtoupper'))->isSame(['1', '8', '1B', '40', '7D']);
     * // キーも渡ってくる
     * that(array_maps(['a' => 'A', 'b' => 'B'], fn($v, $k) => "$k:$v"))->isSame(['a' => 'a:A', 'b' => 'b:B']);
     * // ... で可変引数コール
     * that(array_maps([[1, 3], [1, 5, 2]], '...range'))->isSame([[1, 2, 3], [1, 3, 5]]);
     * // メソッドコールもできる（引数不要なら `@method` でも同じ）
     * that(array_maps([new \Exception('a'), new \Exception('b')], ['getMessage' => []]))->isSame(['a', 'b']);
     * that(array_maps([new \Exception('a'), new \Exception('b')], '@getMessage'))->isSame(['a', 'b']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable ...$callbacks 評価クロージャ配列
     * @return iterable 評価クロージャを通した新しい配列
     */
    function array_maps($array, ...$callbacks)
    {
        // Iterator だが ArrayAccess ではないオブジェクト（Generator とか）は unset できないので配列として扱わざるを得ない
        if (!(function_configure('array.variant') && is_arrayable($array))) {
            $array = arrayval($array, false);
        }

        foreach ($callbacks as $callback) {
            if (is_string($callback) && $callback[0] === '@') {
                $margs = [];
                $vargs = false;
                $callback = substr($callback, 1);
            }
            elseif (is_array($callback) && count($callback) === 1) {
                $margs = reset($callback);
                $vargs = false;
                $callback = key($callback);
            }
            elseif (is_string($callback) && substr($callback, 0, 3) === '...') {
                $margs = null;
                $vargs = true;
                $callback = substr($callback, 3);
            }
            else {
                $margs = null;
                $vargs = false;
                $callback = func_user_func_array($callback);
            }
            $n = 0;
            foreach (arrayval($array, false) as $k => $v) {
                if (isset($margs)) {
                    $array[$k] = ([$v, $callback])(...$margs);
                }
                elseif ($vargs) {
                    $array[$k] = $callback(...$v);
                }
                else {
                    $array[$k] = $callback($v, $k, $n++);
                }
            }
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_merge2') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_merge2'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_merge2')) {
    /**
     * 配列をマージして通常配列＋αで返す
     *
     * キー・値が維持される点で array_merge とは異なる（振り直しをせず数値配列で返す）。
     * きちんと0からの連番で構成される点で配列の加算とは異なる。
     * 要するに「できるだけキーが自然数（の並び）になるように」マージする。
     *
     * 歯抜けはそのまま維持され、文字キーは後ろに追加される（負数キーも同様）。
     *
     * Example:
     * ```php
     * // キーが入り乱れているがよく見ると通し番号が振られている配列をマージ
     * that(array_merge2([4 => 4, 1 => 1], [0 => 0], [5 => 5, 2 => 2, 3 => 3]))->isSame([0, 1, 2, 3, 4, 5]);
     * // 歯抜けの配列をマージ
     * that(array_merge2([4 => 4, 1 => 1], [0 => 0], [5 => 5, 3 => 3]))->isSame([0, 1, 3 => 3, 4 => 4, 5 => 5]);
     * // 負数や文字キーは後ろに追いやられる
     * that(array_merge2(['a' => 'A', 1 => 1], [0 => 0], [-1 => 'X', 2 => 2, 3 => 3]))->isSame([0, 1, 2, 3, -1 => 'X', 'a' => 'A']);
     * // 同じキーは後ろ優先
     * that(array_merge2([0, 'a' => 'A0'], [1, 'a' => 'A1'], [2, 'a' => 'A2']))->isSame([2, 'a' => 'A2']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array ...$arrays マージする配列
     * @return array マージされた配列
     */
    function array_merge2(...$arrays)
    {
        // array_merge を模倣するため前方優先
        $arrays = array_reverse($arrays);

        // 最大値の導出（負数は考慮せず文字キーとして扱う）
        $max = -1;
        foreach ($arrays as $array) {
            foreach ($array as $k => $v) {
                if (is_int($k) && $k > $max) {
                    $max = $k;
                }
            }
        }

        // 最大値までを埋める
        $result = [];
        for ($i = 0; $i <= $max; $i++) {
            foreach ($arrays as $array) {
                if (isset($array[$i]) || array_key_exists($i, $array)) {
                    $result[$i] = $array[$i];
                    break;
                }
            }
        }

        // 上記は数値キーだけなので負数や文字キーを補完する
        foreach ($arrays as $arg) {
            $result += $arg;
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_mix') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_mix'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_mix')) {
    /**
     * 配列を交互に追加する
     *
     * 引数の配列を横断的に追加して返す。
     * 数値キーは振り直される。文字キーはそのまま追加される（同じキーは後方上書き）。
     *
     * 配列の長さが異なる場合、短い方に対しては何もしない。そのまま追加される。
     *
     * Example:
     * ```php
     * // 奇数配列と偶数配列をミックスして自然数配列を生成
     * that(array_mix([1, 3, 5], [2, 4, 6]))->isSame([1, 2, 3, 4, 5, 6]);
     * // 長さが異なる場合はそのまま追加される（短い方の足りない分は無視される）
     * that(array_mix([1], [2, 3, 4]))->isSame([1, 2, 3, 4]);
     * that(array_mix([1, 3, 4], [2]))->isSame([1, 2, 3, 4]);
     * // 可変引数なので3配列以上も可
     * that(array_mix([1], [2, 4], [3, 5, 6]))->isSame([1, 2, 3, 4, 5, 6]);
     * that(array_mix([1, 4, 6], [2, 5], [3]))->isSame([1, 2, 3, 4, 5, 6]);
     * // 文字キーは維持される
     * that(array_mix(['a' => 'A', 1, 3], ['b' => 'B', 2]))->isSame(['a' => 'A', 'b' => 'B', 1, 2, 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array ...$variadic 対象配列（可変引数）
     * @return array 引数配列が交互に追加された配列
     */
    function array_mix(...$variadic)
    {
        assert(count(array_filter($variadic, fn($v) => !is_array($v))) === 0);

        if (!$variadic) {
            return [];
        }

        $keyses = array_map('array_keys', $variadic);
        $limit = max(array_map('count', $keyses));

        $result = [];
        for ($i = 0; $i < $limit; $i++) {
            foreach ($keyses as $n => $keys) {
                if (isset($keys[$i])) {
                    $key = $keys[$i];
                    $val = $variadic[$n][$key];
                    if (is_int($key)) {
                        $result[] = $val;
                    }
                    else {
                        $result[$key] = $val;
                    }
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_nest') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_nest'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_nest')) {
    /**
     * シンプルな [キー => 値] な配列から階層配列を生成する
     *
     * 定義的に array_flatten の逆関数のような扱いになる。
     * $delimiter で階層を表現する。
     *
     * 同名とみなされるキーは上書きされるか例外が飛ぶ。具体的には Example を参照。
     *
     * Example:
     * ```php
     * // 単純な階層展開
     * $array = [
     *    'k1'            => 'v1',
     *    'k2.k21'        => 'v21',
     *    'k2.k22.k221'   => 'v221',
     *    'k2.k22.k222'   => 'v222',
     *    'k2.k22.k223.0' => 1,
     *    'k2.k22.k223.1' => 2,
     *    'k2.k22.k223.2' => 3,
     * ];
     * that(array_nest($array))->isSame([
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *            'k223' => [1, 2, 3],
     *        ],
     *    ],
     * ]);
     * // 同名になるようなキーは上書きされる
     * $array = [
     *    'k1.k2' => 'v1', // この時点で 'k1' は配列になるが・・・
     *    'k1'    => 'v2', // この時点で 'k1' は文字列として上書きされる
     * ];
     * that(array_nest($array))->isSame([
     *    'k1' => 'v2',
     * ]);
     * // 上書きすら出来ない場合は例外が飛ぶ
     * $array = [
     *    'k1'    => 'v1', // この時点で 'k1' は文字列になるが・・・
     *    'k1.k2' => 'v2', // この時点で 'k1' にインデックスアクセスすることになるので例外が飛ぶ
     * ];
     * try {
     *     array_nest($array);
     * }
     * catch (\Exception $e) {
     *     that($e)->isInstanceOf(\InvalidArgumentException::class);
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string $delimiter キーの区切り文字
     * @return array 階層化された配列
     */
    function array_nest($array, $delimiter = '.')
    {
        $result = [];
        foreach ($array as $k => $v) {
            $keys = explode($delimiter, $k);
            $rkeys = [];
            $tmp = &$result;
            foreach ($keys as $key) {
                $rkeys[] = $key;
                if (isset($tmp[$key]) && !is_array($tmp[$key])) {
                    throw new \InvalidArgumentException("'" . implode($delimiter, $rkeys) . "' of '$k' is already exists.");
                }
                $tmp = &$tmp[$key];
            }
            $tmp = $v;
            unset($tmp);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_of') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_of'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_of')) {
    /**
     * 配列を与えると指定キーの値を返すクロージャを返す
     *
     * 存在しない場合は $default を返す。
     *
     * $key に配列を与えるとそれらの値の配列を返す（lookup 的な動作）。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * Example:
     * ```php
     * $fuga_of_array = array_of('fuga');
     * that($fuga_of_array(['hoge' => 'HOGE', 'fuga' => 'FUGA']))->isSame('FUGA');
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param string|int|array $key 取得したいキー
     * @param mixed $default デフォルト値
     * @return \Closure $key の値を返すクロージャ
     */
    function array_of($key, $default = null)
    {
        $nodefault = func_num_args() === 1;
        return fn(array $array) => $nodefault ? array_get($array, $key) : array_get($array, $key, $default);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_order') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_order'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_order')) {
    /**
     * 配列を $orders に従って並べ替える
     *
     * データベースからフェッチしたような連想配列の配列を想定しているが、スカラー配列(['key' => 'value'])にも対応している。
     * その場合 $orders に配列ではなく直値を渡せば良い。
     *
     * $orders には下記のような配列を渡す。
     * キーに空文字を渡すとそれは「キー自体」を意味する。
     *
     * ```php
     * $orders = [
     *     'col1' => true,                      // true: 昇順, false: 降順。照合は型に依存
     *     'col2' => SORT_NATURAL,              // SORT_NATURAL, SORT_REGULAR などで照合。正数で昇順、負数で降順
     *     'col3' => ['sort', 'this', 'order'], // 指定した配列順で昇順
     *     'col4' => fn($v) => $v,              // クロージャを通した値で昇順。照合は返り値の型に依存
     *     'col5' => fn($a, $b) => $a - $b,     // クロージャで比較して昇順（いわゆる比較関数を渡す）
     * ];
     * ```
     *
     * Example:
     * ```php
     * $v1 = ['id' => '1', 'no' => 'a03', 'name' => 'yyy'];
     * $v2 = ['id' => '2', 'no' => 'a4',  'name' => 'yyy'];
     * $v3 = ['id' => '3', 'no' => 'a12', 'name' => 'xxx'];
     * // name 昇順, no 自然降順
     * that(array_order([$v1, $v2, $v3], ['name' => true, 'no' => -SORT_NATURAL]))->isSame([$v3, $v2, $v1]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param mixed $orders ソート順
     * @param bool $preserve_keys キーを保存するか。 false の場合数値キーは振り直される
     * @return array 並び替えられた配列
     */
    function array_order(array $array, $orders, $preserve_keys = false)
    {
        if (count($array) <= 1) {
            return $array;
        }

        if (!is_array($orders) || !is_hasharray($orders)) {
            $orders = [$orders];
        }

        // 配列内の位置をマップして返すクロージャ
        $position = fn($columns, $order) => array_map(function ($v) use ($order) {
            $ndx = array_search($v, $order, true);
            return $ndx === false ? count($order) : $ndx;
        }, $columns);

        // 全要素は舐めてられないので最初の要素を代表選手としてピックアップ
        $first = reset($array);
        $is_scalar = is_scalar($first) || is_null($first);

        // array_multisort 用の配列を生成
        $args = [];
        foreach ($orders as $key => $order) {
            if ($is_scalar) {
                $firstval = reset($array);
                $columns = $array;
            }
            else {
                if ($key !== '' && !array_key_exists($key, $first)) {
                    throw new \InvalidArgumentException("$key is undefined.");
                }
                if ($key === '') {
                    $columns = array_keys($array);
                    $firstval = reset($columns);
                }
                else {
                    $firstval = $first[$key];
                    $columns = array_column($array, $key);
                }
            }

            // bool は ASC, DESC
            if (is_bool($order)) {
                $args[] = $columns;
                $args[] = $order ? SORT_ASC : SORT_DESC;
                $args[] = is_string($firstval) ? SORT_STRING : SORT_NUMERIC;
            }
            // int は SORT_*****
            elseif (is_int($order)) {
                $args[] = $columns;
                $args[] = $order > 0 ? SORT_ASC : SORT_DESC;
                $args[] = abs($order);
            }
            // 配列はその並び
            elseif (is_array($order)) {
                $args[] = $position($columns, $order);
                $args[] = SORT_ASC;
                $args[] = SORT_NUMERIC;
            }
            // クロージャは色々
            elseif ($order instanceof \Closure) {
                $ref = new \ReflectionFunction($order);
                // 引数2個なら比較関数
                if ($ref->getNumberOfRequiredParameters() === 2) {
                    $map = $columns;
                    usort($map, $order);
                    $args[] = $position($columns, $map);
                    $args[] = SORT_ASC;
                    $args[] = SORT_NUMERIC;
                }
                // でないなら通した値で比較
                else {
                    $arg = array_map($order, $columns);
                    $type = reflect_types($ref->getReturnType())->allows('string') ? 'string' : gettype(reset($arg));
                    $args[] = $arg;
                    $args[] = SORT_ASC;
                    $args[] = $type === 'string' ? SORT_STRING : SORT_NUMERIC;
                }
            }
            else {
                throw new \DomainException('$order is invalid.');
            }
        }

        // array_multisort はキーを保持しないので、ソートされる配列にキー配列を加えて後で combine する
        if ($preserve_keys) {
            $keys = array_keys($array);
            $args[] = &$array;
            $args[] = &$keys;
            array_multisort(...$args);
            return array_combine($keys, $array);
        }
        // キーを保持しないなら単純呼び出しで OK
        else {
            $args[] = &$array;
            array_multisort(...$args);
            return $array;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_pickup') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_pickup'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_pickup')) {
    /**
     * キーを指定してそれだけの配列にする
     *
     * `array_intersect_key($array, array_flip($keys))` とほぼ同義。
     * 違いは Traversable を渡せることと、結果配列の順番が $keys に従うこと。
     *
     * $keys に連想配列を渡すとキーを読み替えて動作する（Example を参照）。
     * さらにその時クロージャを渡すと($key, $value)でコールされた結果が新しいキーになる。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a と c を取り出す
     * that(array_pickup($array, ['a', 'c']))->isSame(['a' => 'A', 'c' => 'C']);
     * // 順番は $keys 基準になる
     * that(array_pickup($array, ['c', 'a']))->isSame(['c' => 'C', 'a' => 'A']);
     * // 連想配列を渡すと読み替えて返す
     * that(array_pickup($array, ['c' => 'cX', 'a' => 'aX']))->isSame(['cX' => 'C', 'aX' => 'A']);
     * // コールバックを渡せる
     * that(array_pickup($array, ['c' => fn($k, $v) => "$k-$v"]))->isSame(['c-C' => 'C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param array $keys 取り出すキー
     * @return array 新しい配列
     */
    function array_pickup($array, $keys)
    {
        $array = arrayval($array, false);

        $result = [];
        foreach (arrayval($keys, false) as $k => $key) {
            if (is_int($k)) {
                if (array_key_exists($key, $array)) {
                    $result[$key] = $array[$key];
                }
            }
            else {
                if (array_key_exists($k, $array)) {
                    if (is_callback($key)) {
                        $key = $key($k, $array[$k]);
                    }
                    $result[$key] = $array[$k];
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_pos') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_pos'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_pos')) {
    /**
     * 配列・連想配列を問わず「N番目(0ベース)」の要素を返す
     *
     * 負数を与えると逆から N 番目となる。
     *
     * Example:
     * ```php
     * that(array_pos([1, 2, 3], 1))->isSame(2);
     * that(array_pos([1, 2, 3], -1))->isSame(3);
     * that(array_pos(['a' => 'A', 'b' => 'B', 'c' => 'C'], 1))->isSame('B');
     * that(array_pos(['a' => 'A', 'b' => 'B', 'c' => 'C'], 1, true))->isSame('b');
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param int $position 取得する位置
     * @param bool $return_key true にすると値ではなくキーを返す
     * @return mixed 指定位置の値
     */
    function array_pos($array, $position, $return_key = false)
    {
        $position = (int) $position;
        $keys = array_keys($array);

        if ($position < 0) {
            $position = abs($position + 1);
            $keys = array_reverse($keys);
        }

        $count = count($keys);
        for ($i = 0; $i < $count; $i++) {
            if ($i === $position) {
                $key = $keys[$i];
                if ($return_key) {
                    return $key;
                }
                return $array[$key];
            }
        }

        throw new \OutOfBoundsException("$position is not found.");
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_pos_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_pos_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_pos_key')) {
    /**
     * 配列の指定キーの位置を返す
     *
     * $key に配列を与えるとその全ての位置を返す。
     *
     * Example:
     * ```php
     * that(array_pos_key(['a' => 'A', 'b' => 'B', 'c' => 'C'], 'c'))->isSame(2);
     * that(array_pos_key(['a' => 'A', 'b' => 'B', 'c' => 'C'], 'x', -1))->isSame(-1);
     *  that(array_pos_key(['a' => 'A', 'b' => 'B', 'c' => 'C'], ['a', 'c']))->isSame(['a' => 0, 'c' => 2]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param string|int|array $key 取得したい位置のキー
     * @param mixed $default 見つからなかったときのデフォルト値。指定しないと例外。$key が配列の場合は見つからなかったキー全てに代入される
     * @return int|int[] 指定キーの位置
     */
    function array_pos_key($array, $key, $default = null)
    {
        // very slow
        // return array_flip(array_keys($array))[$key];

        $is_array = is_array($key);
        $key = array_flip((array) $key);

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            if (isset($key[$k])) {
                if (!$is_array) {
                    return $n;
                }
                else {
                    $result[$k] = $n;
                }
            }
            $n++;
        }

        if (func_num_args() === 2) {
            if (count($result) !== count($key)) {
                throw new \OutOfBoundsException(implode(',', $key) . " is not found.");
            }
        }

        if ($is_array) {
            return $result + array_fill_keys(array_keys($key), $default);
        }

        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_prepend') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_prepend'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_prepend')) {
    /**
     * 配列の先頭に要素を追加する
     *
     * array_unshift のキーが指定できる参照渡しでない版と言える。
     * 配列の数値キーは振り直される。
     * キー指定でかつそのキーが存在するとき、値を変えつつ先頭に移動する動作となる。
     *
     * Example:
     * ```php
     * // キー未指定は0で挿入される
     * that(array_prepend([1, 2, 3], 99))->is([99, 1, 2, 3]);
     * // キーを指定すればそのキーで生える
     * that(array_prepend([1, 2, 3], 99, 'newkey'))->is(['newkey' => 99, 1, 2, 3]);
     * // 存在する場合は値が変わって先頭に移動する
     * that(array_prepend([1, 2, 3], 99, 1))->is([1 => 99, 0 => 1, 2 => 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @return array 要素が追加された配列
     */
    function array_prepend($array, $value, $key = null)
    {
        if ($key === null) {
            $array = array_merge([$value], $array);
        }
        else {
            $array = [$key => $value] + $array;
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_random') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_random'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_random')) {
    /**
     * array_rand の要素版
     *
     * とはいえ多少の差異がある。
     *
     * - 第2引数に null を与えると単一の値として返す
     * - 第2引数に数値を与えると配列で返す（たとえ1でも配列で返す）
     * - 第2引数に 0 を与えてもエラーにはならない（空配列を返す）
     * - 第2引数に負数を与えるとその個数に満たなくても例外にならない
     * - 第3引数に true を与えるとキーを維持して返す
     *
     * Example:
     * ```php
     * mt_srand(4); // テストがコケるので種固定
     * // 配列からランダムに値1件取得（単一で返す）
     * that(array_random(['a' => 'A', 'b' => 'B', 'c' => 'C']))->isSame('B');
     * // 配列からランダムに値2件取得（配列で返す）
     * that(array_random(['a' => 'A', 'b' => 'B', 'c' => 'C'], 2))->isSame(['B', 'C']);
     * // 配列からランダムに値2件取得（キーを維持）
     * that(array_random(['a' => 'A', 'b' => 'B', 'c' => 'C'], 2, true))->isSame(['a' => 'A', 'c' => 'C']);
     * // 配列からランダムに値N件取得（負数指定。配列数を超えた指定は例外になるので負数にする必要がある）
     * that(array_random(['a' => 'A', 'b' => 'B', 'c' => 'C'], -999, true))->isSame(['a' => 'A', 'b' => 'B', 'c' => 'C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param ?int $count 取り出す個数
     * @return mixed ランダムな要素
     */
    function array_random($array, $count = null, $preserve_keys = false)
    {
        if ($count === null) {
            return $array[array_rand($array)];
        }

        if (intval($count) === 0) {
            return [];
        }

        if ($count > 0 && count($array) < $count) {
            throw new \InvalidArgumentException('Argument #2 ($count) must be between 1 and the number of elements in argument #1 ($array)');
        }
        if ($count < 0) {
            $count = min(count($array), -$count);
        }

        if (count($array) === 0) {
            return [];
        }

        $result = [];
        foreach ((array) array_rand($array, $count) as $key) {
            if ($preserve_keys) {
                $result[$key] = $array[$key];
            }
            else {
                $result[] = $array[$key];
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_range') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_range'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_range')) {
    /**
     * range を少し改良したもの
     *
     * - 文字列に対応
     * - 日時に対応
     * - $start, $end から $step の自動算出
     * - $start < $end で $step < 0 の場合、空配列を返す
     * - $start > $end で $step > 0 の場合、空配列を返す
     *
     * 逆に言うと $start, $end の大小を意識しないと正しい値は返らないことになる。
     * 標準 range の下記の挙動が個人的に違和感があるので実装した。
     *
     * - range(1, 3, -1); // [1, 2, 3]
     * - range(3, 1, +1); // [3, 2, 1]
     *
     * Example:
     * ```php
     * // 文字列（具体的にはデクリメント）
     * that(array_range('a', 'c', +1))->isSame(['a', 'b', 'c']);
     * that(array_range('c', 'a', -1))->isSame(['c', 'b', 'a']);
     *
     * // 日時
     * that(array_range('2014/12/24 12:34:56', '2014/12/26 12:34:56', 'P1D', ['format' => 'Y/m/d H:i:s']))->isSame([
     *     '2014/12/24 12:34:56',
     *     '2014/12/25 12:34:56',
     *     '2014/12/26 12:34:56',
     * ]);
     * that(array_range('2014/12/26 12:34:56', '2014/12/24 12:34:56', 'P-1D', ['format' => 'Y/m/d H:i:s']))->isSame([
     *     '2014/12/26 12:34:56',
     *     '2014/12/25 12:34:56',
     *     '2014/12/24 12:34:56',
     * ]);
     *
     * // step は省略可能（+/-1 になる）
     * that(array_range(1, 3))->isSame([1, 2, 3]);
     * that(array_range(3, 1))->isSame([3, 2, 1]);
     * that(array_range('a', 'c'))->isSame(['a', 'b', 'c']);
     * that(array_range('c', 'a'))->isSame(['c', 'b', 'a']);
     *
     * // 範囲外は空配列を返す
     * that(array_range(1, 3, -1))->isSame([]);
     * that(array_range(3, 1, +1))->isSame([]);
     * that(array_range('a', 'c', -1))->isSame([]);
     * that(array_range('c', 'a', +1))->isSame([]);
     * that(array_range('2014/12/24', '2014/12/27', 'P-1D'))->isSame([]);
     * that(array_range('2014/12/27', '2014/12/24', 'P1D'))->isSame([]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param int|float|string|\DateTimeInterface $start 最初の値
     * @param int|float|string|\DateTimeInterface $end 最後の値
     * @param int|float|string|null|\DateInterval $step 増分
     * @return array $start ~ $end の配列
     */
    function array_range($start, $end, $step = null, $options = [])
    {
        $options += [
            'format' => null,
        ];

        // 数値モード
        if (true
            && is_decimal($start)
            && is_decimal($end)
            && ($step === null || is_decimal($step))
        ) {
            if ($step === null) {
                if ($start < $end) {
                    $step = (is_float($start) || is_float($end)) ? +1.0 : +1;
                }
                if ($start >= $end) {
                    $step = (is_float($start) || is_float($end)) ? -1.0 : -1;
                }
            }
            if (empty($step)) {
                throw new \InvalidArgumentException("\$step is empty($step)");
            }

            if (is_float($step)) {
                $start = (float) $start;
                $end = (float) $end;
                $step = (float) $step;
            }
            else {
                $start = (int) $start;
                $end = (int) $end;
                $step = (int) $step;
            }

            $result = [];
            if ($step > 0) {
                for ($i = $start; $i <= $end; $i += $step) {
                    $result[] = $i;
                }
            }
            if ($step < 0) {
                for ($i = $start; $i >= $end; $i += $step) {
                    $result[] = $i;
                }
            }
            return $result;
        }

        // 文字列モード
        if (true
            && (is_string($start) && strlen($start))
            && (is_string($end) && strlen($end))
            && ($step === null || is_decimal($step, false))
        ) {
            if ($step === null) {
                $step = ($start <=> $end) < 0 ? +1 : -1;
            }
            if (empty($step)) {
                throw new \InvalidArgumentException("\$step is empty($step)");
            }

            // 単純な比較ではない（Z <=> aa < 1 のように中身によらず字数が大きい方が常に大きい）
            $compare = function ($a, $b) {
                if (($d = strlen($a) - strlen($b)) !== 0) {
                    return $d;
                }
                for ($i = 0; $i < strlen($a); $i++) {
                    if (($d = ($a[$i] <=> $b[$i])) !== 0) {
                        return $d;
                    }
                }
                return 0;
            };

            // 1以上のインクリメントは対応していない
            $increment = function ($string, $step) {
                for ($i = 0; $i < $step; $i++) {
                    $string++;
                }
                return $string;
            };

            $invert = $step < 0;

            // 文字列デクリメントは出来ないので reverse で対応する
            if ($invert) {
                $step = -$step;
                [$start, $end] = [$end, $start];
            }

            $result = [];
            if ($step > 0) {
                for ($i = $start; $compare($i, $end) <= 0; $i = $increment($i, $step)) {
                    $result[] = $i;
                }
            }

            // 文字列デクリメントは（略）
            if ($invert) {
                if (count($result) === 1) {
                    $result = [$end];
                }
                else {
                    $result = array_reverse($result);
                }
            }

            return $result;
        }

        // 日時モード
        if (true
            && ($start instanceof \DateTimeInterface || (is_string($start) && strlen($start)))
            && ($end instanceof \DateTimeInterface || (is_string($end) && strlen($end)))
            && ($step instanceof \DateInterval || is_string($step))
        ) {
            try {
                if ($options['format'] === 'auto') {
                    $options['format'] = (function (...$dts) {
                        foreach ($dts as $dt) {
                            if (is_string($dt) && ($format = date_parse_format($dt)) !== null) {
                                return $format;
                            }
                        }
                        throw new \InvalidArgumentException("failed to auto detect dateformat");
                    })($start, $end);
                }

                if (is_string($start)) {
                    $start = date_convert(\DateTimeImmutable::class, $start);
                }
                if ($start instanceof \DateTime) {
                    $start = \DateTimeImmutable::createFromMutable($start);
                }
                if (is_string($end)) {
                    $end = date_convert(\DateTimeImmutable::class, $end);
                }
                if ($end instanceof \DateTime) {
                    $end = \DateTimeImmutable::createFromMutable($end);
                }
                if (is_string($step)) {
                    $step = @\DateInterval::createFromDateString($step) ?: date_interval($step);
                }

                $now = new \DateTimeImmutable();
                $new = $now->add($step);

                if ($now == $new) {
                    throw new \InvalidArgumentException("\$step is empty({$step->format('%RP%Y-%M-%DT%H:%I:%S.%F')})");
                }

                // $result = iterator_to_array(new \DatePeriod($start, $step, $end)); // happen too many bugs
                $result = [];
                if ($now > $new) {
                    for ($i = $start; $i >= $end; $i = $i->add($step)) {
                        $result[] = $i;
                    }
                }
                if ($now < $new) {
                    for ($i = $start; $i <= $end; $i = $i->add($step)) {
                        $result[] = $i;
                    }
                }
                if (isset($options['format'])) {
                    $result = array_map(fn($dt) => $dt->format($options['format']), $result);
                }
                return $result;
            }
            catch (\Exception $e) {
                // through
            }
        }

        if (isset($e)) {
            throw $e;
        }
        throw new \InvalidArgumentException("failed to detect mode", 0, $e ?? null);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_rank') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_rank'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_rank')) {
    /**
     * 配列をランク付けしてその順番でN件返す
     *
     * 同ランクはすべて返す。
     * つまり $length=10 でも10件以上を返すこともある。
     *
     * $length が負数の場合、降順ソートして後ろから取り出す。
     * 端的に言えば
     *
     * - 正数: 下位N件
     * - 負数: 上位N件
     *
     * という動作になる。
     *
     * ソートの型は最初の要素で決まる。
     * 文字列なら SORT_STRING で、違うなら SORT_NUMERIC
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param int $length 取り出す件数
     * @param ?callable $rankfunction ランク付けクロージャ
     * @return array 上位N件の配列
     */
    function array_rank($array, $length, $rankfunction = null)
    {
        $array = arrayval($array, false);

        $ranks = $array;
        if ($rankfunction !== null) {
            $n = 0;
            foreach ($ranks as $k => $v) {
                $ranks[$k] = $rankfunction($v, $k, $n++);
            }
        }

        $type = null;
        $buckets = [];
        foreach ($ranks as $k => $v) {
            if (!isset($type)) {
                $type = gettype($v);
            }
            $buckets[(string) $v][$k] = $array[$k];
        }

        if ($length < 0) {
            $length = -$length;
            krsort($buckets, $type === 'string' ? SORT_STRING : SORT_NUMERIC);
        }
        else {
            ksort($buckets, $type === 'string' ? SORT_STRING : SORT_NUMERIC);
        }

        $result = [];
        foreach ($buckets as $bucket) {
            if (count($result) >= $length) {
                break;
            }
            foreach ($bucket as $k => $v) {
                $result[$k] = $v;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_rekey') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_rekey'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_rekey')) {
    /**
     * キーをマップ配列・callable で置換する
     *
     * 変換先・返り値が null だとその要素は取り除かれる。
     * callable 指定時の引数は `(キー, 値, 連番インデックス, 対象配列そのもの)` が渡ってくる。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a は x に c は z に置換される
     * that(array_rekey($array, ['a' => 'x', 'c' => 'z']))->isSame(['x' => 'A', 'b' => 'B', 'z' => 'C']);
     * // b は削除され c は z に置換される
     * that(array_rekey($array, ['b' => null, 'c' => 'z']))->isSame(['a' => 'A', 'z' => 'C']);
     * // キーの交換にも使える（a ⇔ c）
     * that(array_rekey($array, ['a' => 'c', 'c' => 'a']))->isSame(['c' => 'A', 'b' => 'B', 'a' => 'C']);
     * // callable
     * that(array_rekey($array, 'strtoupper'))->isSame(['A' => 'A', 'B' => 'B', 'C' => 'C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param array|callable $keymap マップ配列かキーを返すクロージャ
     * @return array キーが置換された配列
     */
    function array_rekey($array, $keymap)
    {
        // 互換性のため callable は配列以外に限定する
        $callable = ($keymap instanceof \Closure) || (!is_array($keymap) && is_callable($keymap));
        if ($callable) {
            $keymap = func_user_func_array($keymap);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            if ($callable) {
                $k = $keymap($k, $v, $n, $array);
                // null は突っ込まない（除去）
                if ($k !== null) {
                    $result[$k] = $v;
                }
            }
            elseif (array_key_exists($k, $keymap)) {
                // null は突っ込まない（除去）
                if ($keymap[$k] !== null) {
                    $result[$keymap[$k]] = $v;
                }
            }
            else {
                $result[$k] = $v;
            }
            $n++;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_remove') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_remove'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_remove')) {
    /**
     * キーを指定してそれらを除いた配列にする
     *
     * `array_diff_key($array, array_flip($keys))` とほぼ同義。
     * 違いは Traversable を渡せること。
     *
     * array_pickup の逆とも言える。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a と c を伏せる（b を残す）
     * that(array_remove($array, ['a', 'c']))->isSame(['b' => 'B']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\Traversable $array 対象配列
     * @param array|int|string $keys 伏せるキー
     * @return array 新しい配列
     */
    function array_remove($array, $keys)
    {
        foreach (arrayval($keys, false) as $k) {
            unset($array[$k]);
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_revise') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_revise'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_revise')) {
    /**
     * 配列要素の追加・変更・削除を行う
     *
     * $map の当該キー要素が・・・
     *
     * - クロージャの場合: キーの有無に関わらずコールされる
     * - null の場合: キーが削除される
     * - それ以外の場合: キーが追加される（存在しない場合のみ）
     *
     * という処理を行う。
     *
     * Example:
     * ```php
     * that(array_revise([
     *     'id'      => 123,
     *     'name'    => 'hoge',
     *     'age'     => 18,
     *     'delete'  => '',
     * ], [
     *     'name'    => 'ignored',            // 存在するのでスルーされる
     *     'append'  => 'newkey',             // 存在しないので追加される
     *     'age'     => fn($age) => $age + 1, // クロージャは現在の値を引数にしてコールされる
     *     'delete'  => null,                 // null は削除される
     *     'null'    => fn() => null,         // 削除の目印として null を使っているので null を追加したい場合はクロージャで包む必要がある
     * ]))->isSame([
     *     'id'      => 123,
     *     'name'    => 'hoge',
     *     'age'     => 19,
     *     'append'  => 'newkey',
     *     'null'    => null,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array
     * @param array ...$maps
     * @return array 変更された新しい配列
     */
    function array_revise($array, ...$maps)
    {
        $result = arrayval($array, false);
        foreach ($maps as $map) {
            foreach ($map as $k => $v) {
                if ($v instanceof \Closure) {
                    $result[$k] = $v($result[$k] ?? null, $result);
                }
                elseif ($v === null) {
                    unset($result[$k]);
                }
                elseif (!array_key_exists($k, $result)) {
                    $result[$k] = $v;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_schema') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_schema'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_schema')) {
    /**
     * 配列のスキーマを定義して配列を正規化する
     *
     * - type: 値の型を指定する
     *   - is_XXX の XXX 部分: 左記で検証
     *   - number: is_int or is_float で検証
     *   - class 名: instanceof で検証
     *   - list: 値がマージされて通常配列になる
     *     - list@string のようにすると配列の中身の型を指定できる
     *   - hash: 連想配列になる
     *   - string|int: string or int
     *   - ['string', 'int']: 上と同じ
     * - closure: 指定クロージャで検証・フィルタ
     *   - all: 値を引数に取り、返り値が新しい値となる
     * - unique: 重複を除去する
     *   - list: 重複除去（パラメータがソートアルゴリズムになる）
     * - enum: 値が指定値のいずれかであるか検証する
     *   - all: in_array で検証する
     * - min: 値が指定値以上であるか検証する
     *   - string: strlen で検証
     *   - list: count で検証
     *   - all: その値で検証
     * - max: 値が指定値以下であるか検証する
     *   - min の逆
     * - match: 値が正規表現にマッチするか検証する
     *   - all: preg_match で検証する
     * - unmatch: 値が正規表現にマッチしないか検証する
     *   - match の逆
     * - include: 値が指定値を含むか検証する
     *   - string: strpos で検証
     *   - list: in_array で検証
     * - exclude: 値が指定値を含まないか検証する
     *   - include の逆
     *
     * 検証・フィルタは原則として型を見ない（指定されていればすべて実行される）。
     * のでおかしな型におかしな検証・フィルタを与えると型エラーが出ることがある。
     *
     * 検証は途中経過を問わない。
     * 後ろの配列で上書きされた値や unique で減った配列などは以下に違反していても valid と判断される。
     *
     * 素直に json schema を使えという内なる声が聞こえなくもない。
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $schema スキーマ配列
     * @param mixed ...$arrays 検証する配列（可変引数。マージされる）
     * @return array 正規化された配列
     */
    function array_schema($schema, ...$arrays)
    {
        $throw = function ($key, $value, $message) {
            $value = str_ellipsis(stringify($value), 32);
            throw new \DomainException("invalid value $key. $value must be $message");
        };
        // 検証兼フィルタ郡
        $validators = [
            'filter'    => function ($definition, $value, $key) use ($throw) {
                $filter = $definition['filter'];
                if (!is_array($filter)) {
                    $filter = [$filter];
                }
                if (($newvalue = filter_var($value, ...$filter)) === false) {
                    $filter_name = array_combine(array_map('filter_id', filter_list()), filter_list());
                    $throw($key, $value, "filter_var " . $filter_name[$filter[0]] . "(" . json_encode($filter[1] ?? []) . ")");
                }
                return $newvalue;
            },
            'type'      => function ($definition, $value, $key) use ($throw) {
                foreach ($definition['type'] as $type) {
                    if ($type === 'number' && (is_int($value) || is_float($value))) {
                        return $value;
                    }
                    if (function_exists($checker = "is_$type") && $checker($value)) {
                        return $value;
                    }
                    if (in_array($type, ['list', 'hash'], true) && is_array($value)) {
                        return $value;
                    }
                    if ($value instanceof $type) {
                        return $value;
                    }
                }
                $throw($key, $value, implode(' or ', $definition['type']));
            },
            'closure'   => function ($definition, $value, $key) use ($throw) {
                return $definition['closure']($value, $definition);
            },
            'unique'    => function ($definition, $value, $key) use ($throw) {
                return array_values(array_distinct($value, $definition['unique']));
            },
            'min'       => function ($definition, $value, $key) use ($throw) {
                if (is_string($value)) {
                    if (strlen($value) < $definition['min']) {
                        $throw($key, $value, "strlen >= {$definition['min']}");
                    }
                }
                elseif (is_array($value)) {
                    if (count($value) < $definition['min']) {
                        $throw($key, $value, "count >= {$definition['min']}");
                    }
                }
                elseif ($value < $definition['min']) {
                    $throw($key, $value, ">= {$definition['min']}");
                }
                return $value;
            },
            'max'       => function ($definition, $value, $key) use ($throw) {
                if (is_string($value)) {
                    if (strlen($value) > $definition['max']) {
                        $throw($key, $value, "strlen <= {$definition['max']}");
                    }
                }
                elseif (is_array($value)) {
                    if (count($value) > $definition['max']) {
                        $throw($key, $value, "count <= {$definition['max']}");
                    }
                }
                elseif ($value > $definition['max']) {
                    $throw($key, $value, "<= {$definition['max']}");
                }
                return $value;
            },
            'precision' => function ($definition, $value, $key) use ($throw) {
                $precision = $definition['precision'] + 1;
                if (preg_match("#\.\d{{$precision}}$#", $value)) {
                    $throw($key, $value, "precision {$definition['precision']}");
                }
                return $value;
            },
            'enum'      => function ($definition, $value, $key) use ($throw) {
                if (!in_array($value, $definition['enum'], true)) {
                    $throw($key, $value, "any of " . json_encode($definition['enum']));
                }
                return $value;
            },
            'match'     => function ($definition, $value, $key) use ($throw) {
                if (!preg_match($definition['match'], $value)) {
                    $throw($key, $value, "match {$definition['match']}");
                }
                return $value;
            },
            'unmatch'   => function ($definition, $value, $key) use ($throw) {
                if (preg_match($definition['unmatch'], $value)) {
                    $throw($key, $value, "unmatch {$definition['unmatch']}");
                }
                return $value;
            },
            'include'   => function ($definition, $value, $key) use ($throw) {
                if (is_array($value)) {
                    if (!in_array($definition['include'], $value)) {
                        $throw($key, $value, "include {$definition['include']}");
                    }
                }
                elseif (strpos($value, $definition['include']) === false) {
                    $throw($key, $value, "include {$definition['include']}");
                }
                return $value;
            },
            'exclude'   => function ($definition, $value, $key) use ($throw) {
                if (is_array($value)) {
                    if (in_array($definition['exclude'], $value)) {
                        $throw($key, $value, "exclude {$definition['exclude']}");
                    }
                }
                elseif (strpos($value, $definition['exclude']) !== false) {
                    $throw($key, $value, "exclude {$definition['exclude']}");
                }
                return $value;
            },
        ];

        $validate = function ($value, $rule, $path) use ($validators) {
            if (is_string($rule['type'])) {
                $rule['type'] = explode('|', $rule['type']);
            }
            $rule['type'] = array_map(fn($type) => explode('@', $type, 2)[0], $rule['type']);

            foreach ($validators as $name => $validator) {
                if (array_key_exists($name, $rule)) {
                    $value = $validator($rule, $value, "{$path}");
                }
            }
            return $value;
        };

        $main = function ($schema, $path, ...$arrays) use (&$main, $validate) {
            if (is_string($schema)) {
                $schema = paml_import($schema);
            }
            if (!array_key_exists('type', $schema)) {
                throw new \InvalidArgumentException("$path not have type key");
            }
            if (!$arrays) {
                if (!array_key_exists('default', $schema)) {
                    throw new \InvalidArgumentException("$path has no value");
                }
                $arrays[] = $schema['default'];
            }

            [$maintype, $subtype] = explode('@', implode('', (array) $schema['type']), 2) + [1 => null];
            if ($maintype === 'list') {
                $result = array_merge(...array_map(fn($v) => $validate($v, $schema, $path), $arrays));
                if (isset($subtype)) {
                    $subschema = ['type' => $subtype] + array_map_key($schema, fn($k) => $k[0] === '@' ? substr($k, 1) : null);
                    foreach ($result as $k => $v) {
                        $result[$k] = $main($subschema, "$path/$k", $v);
                    }
                }
                return $validate($result, $schema, $path);
            }
            elseif ($maintype === 'hash') {
                $result = [];
                foreach ($schema as $k => $rule) {
                    if ($k[0] === '#') {
                        $name = substr($k, 1);
                        $result[$name] = $main($rule, "$path/$k", ...array_column($arrays, $name));
                    }
                }
                return $validate($result, $schema, $path);
            }
            else {
                return $validate(end($arrays), $schema, $path);
            }
        };

        return $main($schema, '', ...$arrays);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_select') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_select'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_select')) {
    /**
     * 指定キーの要素で抽出する
     *
     * $columns に単純な値を渡すとそのキーの値を選択する。
     * キー付きで値を渡すと読み替えて選択する。
     * キー付きでクロージャを渡すと `(キーの値, 行自体, 現在行のキー)` を引数としてコールバックして選択する。
     * 単一のクロージャを渡すと `(行自体, 現在行のキー)` を引数としてコールバックして選択する（array_map とほぼ同じ）。
     *
     * Example:
     * ```php
     * $array = [
     *     11 => ['id' => 1, 'name' => 'name1'],
     *     12 => ['id' => 2, 'name' => 'name2'],
     *     13 => ['id' => 3, 'name' => 'name3'],
     * ];
     *
     * that(array_select($array, [
     *     'id',              // id を単純取得
     *     'alias' => 'name', // name を alias として取得
     * ]))->isSame([
     *     11 => ['id' => 1, 'alias' => 'name1'],
     *     12 => ['id' => 2, 'alias' => 'name2'],
     *     13 => ['id' => 3, 'alias' => 'name3'],
     * ]);
     *
     * that(array_select($array, [
     *     // id の 10 倍を取得
     *     'id'     => fn($id) => $id * 10,
     *     // id と name の結合を取得
     *     'idname' => fn($null, $row, $index) => $row['id'] . $row['name'],
     * ]))->isSame([
     *     11 => ['id' => 10, 'idname' => '1name1'],
     *     12 => ['id' => 20, 'idname' => '2name2'],
     *     13 => ['id' => 30, 'idname' => '3name3'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|iterable|\Closure $columns 抽出項目
     * @param int|string|null $index キーとなるキー
     * @return array 新しい配列
     */
    function array_select($array, $columns, $index = null)
    {
        if (!is_iterable($columns) && !$columns instanceof \Closure) {
            return array_lookup(...func_get_args());
        }

        if ($columns instanceof \Closure) {
            $callbacks = $columns;
        }
        else {
            $callbacks = [];
            foreach ($columns as $alias => $column) {
                if ($column instanceof \Closure) {
                    $callbacks[$alias] = func_user_func_array($column);
                }
            }
        }

        $argcount = func_num_args();
        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            if ($callbacks instanceof \Closure) {
                $row = $callbacks($v, $k, $n++);
            }
            else {
                $row = [];
                foreach ($columns as $alias => $column) {
                    if (is_int($alias)) {
                        $alias = $column;
                    }

                    if (isset($callbacks[$alias])) {
                        $row[$alias] = $callbacks[$alias](attr_get($alias, $v, null), $v, $k);
                    }
                    elseif (attr_exists($column, $v)) {
                        $row[$alias] = attr_get($column, $v);
                    }
                    else {
                        throw new \InvalidArgumentException("$column is not exists.");
                    }
                }
            }

            if ($argcount === 2) {
                $result[$k] = $row;
            }
            elseif ($index === null) {
                $result[] = $row;
            }
            elseif (array_key_exists($index, $row)) {
                $result[$row[$index]] = $row;
            }
            elseif (attr_exists($index, $v)) {
                $result[attr_get($index, $v)] = $row;
            }
            else {
                throw new \InvalidArgumentException("$index is not exists.");
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_set') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_set'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_set')) {
    /**
     * キー指定の配列値設定
     *
     * 第3引数を省略すると（null を与えると）言語機構を使用して配列の最後に設定する（$array[] = $value）。
     * 第3引数に配列を指定すると潜って設定する。
     *
     * 第4引数で追加する条件クロージャを指定できる。
     * クロージャには `(追加する要素, 追加するキー, 追加される元配列)` が渡ってくる。
     * このクロージャが false 相当を返した時は追加されないようになる。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'B'];
     * // 第3引数省略（最後に連番キーで設定）
     * that(array_set($array, 'Z'))->isSame(1);
     * that($array)->isSame(['a' => 'A', 'B', 'Z']);
     * // 第3引数でキーを指定
     * that(array_set($array, 'Z', 'z'))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'z' => 'Z']);
     * that(array_set($array, 'Z', 'z'))->isSame('z');
     * // 第3引数で配列を指定
     * that(array_set($array, 'Z', ['x', 'y', 'z']))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'z' => 'Z', 'x' => ['y' => ['z' => 'Z']]]);
     * // 第4引数で条件を指定（キーが存在するなら追加しない）
     * that(array_set($array, 'Z', 'z', fn($v, $k, $array) => !isset($array[$k])))->isSame(null);
     * // 第4引数で条件を指定（値が存在するなら追加しない）
     * that(array_set($array, 'Z', null, fn($v, $k, $array) => !in_array($v, $array)))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 配列
     * @param mixed $value 設定する値
     * @param array|string|int|null $key 設定するキー
     * @param callable|null $condition 追加する条件
     * @return string|int|null 設定したキー
     */
    function array_set(&$array, $value, $key = null, $condition = null)
    {
        if (is_array($key)) {
            $k = array_shift($key);
            if ($key) {
                if (is_array($array) && array_key_exists($k, $array) && !is_array($array[$k])) {
                    throw new \InvalidArgumentException('$array[$k] is not array.');
                }
                return array_set(...[&$array[$k], $value, $key, $condition]);
            }
            else {
                return array_set(...[&$array, $value, $k, $condition]);
            }
        }

        if ($condition !== null) {
            if (!$condition($value, $key, $array)) {
                return null;
            }
        }

        if ($key === null) {
            $array[] = $value;
            $key = array_key_last($array);
        }
        else {
            $array[$key] = $value;
        }
        return $key;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_shrink_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_shrink_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_shrink_key')) {
    /**
     * 値の優先順位を逆にした array_intersect_key
     *
     * array_intersect_key は「左優先で共通項を取る」という動作だが、この関数は「右優先で共通項を取る」という動作になる。
     * 「配列の並び順はそのままで値だけ変えたい/削ぎ落としたい」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * $array1 = ['a' => 'A1', 'b' => 'B1', 'c' => 'C1'];
     * $array2 = ['c' => 'C2', 'b' => 'B2', 'a' => 'A2'];
     * $array3 = ['c' => 'C3', 'dummy' => 'DUMMY'];
     * // 全共通項である 'c' キーのみが生き残り、その値は最後の 'C3' になる
     * that(array_shrink_key($array1, $array2, $array3))->isSame(['c' => 'C3']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|array|object ...$variadic 共通項を取る配列（可変引数）
     * @return array 新しい配列
     */
    function array_shrink_key(...$variadic)
    {
        $result = [];
        foreach ($variadic as $n => $array) {
            if (!is_array($array)) {
                $variadic[$n] = arrayval($array, false);
            }
            $result = array_replace($result, $variadic[$n]);
        }
        return array_intersect_key($result, ...$variadic);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_shuffle') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_shuffle'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_shuffle')) {
    /**
     * shuffle のキーが保存される＋参照渡しではない版
     *
     * Example:
     * ```php
     * that(array_shuffle(['a' => 'A', 'b' => 'B', 'c' => 'C']))->is(['b' => 'B', 'a' => 'A', 'c' => 'C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @return array shuffle された配列
     */
    function array_shuffle($array)
    {
        $keys = array_keys($array);
        shuffle($keys);

        $result = [];
        foreach ($keys as $key) {
            $result[$key] = $array[$key];
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_sprintf') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_sprintf'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_sprintf')) {
    /**
     * キーと値で sprintf する
     *
     * 配列の各要素を文字列化して返すイメージ。
     * $glue を与えるとさらに implode して返す（返り値が文字列になる）。
     *
     * $format は書式文字列（$v, $k）。
     * callable を与えると sprintf ではなくコールバック処理になる（$v, $k）。
     * 省略（null）するとキーを format 文字列、値を引数として **vsprintf** する。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // key, value を利用した sprintf
     * that(array_sprintf($array, '%2$s=%1$s'))->isSame(['key1=val1', 'key2=val2']);
     * // 第3引数を与えるとさらに implode される
     * that(array_sprintf($array, '%2$s=%1$s', ' '))->isSame('key1=val1 key2=val2');
     * // クロージャを与えるとコールバック動作になる
     * $closure = fn($v, $k) => "$k=" . strtoupper($v);
     * that(array_sprintf($array, $closure, ' '))->isSame('key1=VAL1 key2=VAL2');
     * // 省略すると vsprintf になる
     * that(array_sprintf([
     *     'str:%s,int:%d' => ['sss', '3.14'],
     *     'single:%s'     => 'str',
     * ], null, '|'))->isSame('str:sss,int:3|single:str');
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|callable|null $format 書式文字列あるいはクロージャ
     * @param ?string $glue 結合文字列。未指定時は implode しない
     * @return array|string sprintf された配列
     */
    function array_sprintf($array, $format = null, $glue = null)
    {
        if (is_callable($format)) {
            $callback = func_user_func_array($format);
        }
        elseif ($format === null) {
            $callback = fn($v, $k, $n) => vsprintf($k, is_array($v) ? $v : [$v]);
        }
        else {
            $callback = fn($v, $k, $n) => sprintf($format, $v, $k);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $result[] = $callback($v, $k, $n++);
        }

        if ($glue !== null) {
            return implode($glue, $result);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_strpad') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_strpad'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_strpad')) {
    /**
     * 配列のキー・要素に文字列を付加する
     *
     * $key_prefix, $val_prefix でそれぞれ「キーに付与する文字列」「値に付与する文字列」が指定できる。
     * 配列を与えると [サフィックス, プレフィックス] という意味になる。
     * デフォルト（ただの文字列）はプレフィックス（値だけに付与したいなら array_map で十分なので）。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // キーにプレフィックス付与
     * that(array_strpad($array, 'prefix-'))->isSame(['prefix-key1' => 'val1', 'prefix-key2' => 'val2']);
     * // 値にサフィックス付与
     * that(array_strpad($array, '', ['-suffix']))->isSame(['key1' => 'val1-suffix', 'key2' => 'val2-suffix']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|array $key_prefix キー側の付加文字列
     * @param string|array $val_prefix 値側の付加文字列
     * @return array 文字列付与された配列
     */
    function array_strpad($array, $key_prefix, $val_prefix = '')
    {
        $key_suffix = '';
        if (is_array($key_prefix)) {
            [$key_suffix, $key_prefix] = $key_prefix + [1 => ''];
        }
        $val_suffix = '';
        if (is_array($val_prefix)) {
            [$val_suffix, $val_prefix] = $val_prefix + [1 => ''];
        }

        $enable_key = strlen($key_prefix) || strlen($key_suffix);
        $enable_val = strlen($val_prefix) || strlen($val_suffix);

        $result = [];
        foreach ($array as $key => $val) {
            if ($enable_key) {
                $key = $key_prefix . $key . $key_suffix;
            }
            if ($enable_val) {
                $val = $val_prefix . $val . $val_suffix;
            }
            $result[$key] = $val;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_uncolumns') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_uncolumns'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_uncolumns')) {
    /**
     * array_columns のほぼ逆で [キー => [要素]] 配列から連想配列の配列を生成する
     *
     * $template を指定すると「それに含まれる配列かつ値がデフォルト」になる（要するに $default みたいなもの）。
     * キーがバラバラな配列を指定する場合は指定したほうが良い。が、null を指定すると最初の要素が使われるので大抵の場合は null で良い。
     *
     * Example:
     * ```php
     * that(array_uncolumns([
     *     'id'   => [1, 2],
     *     'name' => ['A', 'B'],
     * ]))->isSame([
     *     ['id' => 1, 'name' => 'A'],
     *     ['id' => 2, 'name' => 'B'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param ?array $template 抽出要素とそのデフォルト値
     * @return array 新しい配列
     */
    function array_uncolumns($array, $template = null)
    {
        // 指定されていないなら生のまま
        if (func_num_args() === 1) {
            $template = false;
        }
        // null なら最初の要素のキー・null
        if ($template === null) {
            $template = array_fill_keys(array_keys(first_value($array)), null);
        }

        $result = [];
        foreach ($array as $key => $vals) {
            if ($template !== false) {
                $vals = array_intersect_key($vals + $template, $template);
            }
            foreach ($vals as $n => $val) {
                $result[$n][$key] = $val;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_unset') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_unset'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_unset')) {
    /**
     * 伏せると同時にその値を返す
     *
     * $key に配列を与えると全て伏せて配列で返す。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 配列を与えた場合の返り値は与えた配列の順番・キーが活きる。
     * これを利用すると list の展開の利便性が上がったり、連想配列で返すことができる。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを伏せて配列で返す。
     * callable ではなくクロージャのみ対応する。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B'];
     * // ない場合は $default を返す
     * that(array_unset($array, 'x', 'X'))->isSame('X');
     * // 指定したキーを返す。そのキーは伏せられている
     * that(array_unset($array, 'a'))->isSame('A');
     * that($array)->isSame(['b' => 'B']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列を与えるとそれらを返す。そのキーは全て伏せられている
     * that(array_unset($array, ['a', 'b', 'x']))->isSame(['A', 'B']);
     * that($array)->isSame(['c' => 'C']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列のキーは返されるキーを表す。順番も維持される
     * that(array_unset($array, ['x2' => 'b', 'x1' => 'a']))->isSame(['x2' => 'B', 'x1' => 'A']);
     *
     * $array = ['hoge' => 'HOGE', 'fuga' => 'FUGA', 'piyo' => 'PIYO'];
     * // 値に "G" を含むものを返す。その要素は伏せられている
     * that(array_unset($array, fn($v) => strpos($v, 'G') !== false))->isSame(['hoge' => 'HOGE', 'fuga' => 'FUGA']);
     * that($array)->isSame(['piyo' => 'PIYO']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\ArrayAccess $array 配列
     * @param string|int|array|callable $key 伏せたいキー。配列を与えると全て伏せる。クロージャの場合は true 相当を伏せる
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_unset(&$array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $rk => $ak) {
                if (array_keys_exist($ak, $array)) {
                    $result[$rk] = $array[$ak];
                    unset($array[$ak]);
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    $result[$k] = $v;
                    unset($array[$k]);
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            $result = $array[$key];
            unset($array[$key]);
            return $result;
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_walk_recursive2') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_walk_recursive2'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_walk_recursive2')) {
    /**
     * array_walk_recursive の改善版
     *
     * 違いは下記。
     *
     * - 第3引数はなし
     *     - クロージャの use で十分だしそちらの方が優れている
     * - コールバックは ($value, $key, $array, $keys) が渡ってくる
     *     - $value, $array はリファレンスにすることで書き換え可能
     * - 返り値で返す
     *     - 元の array_walk_recursive の返り値はほとんど意味がない
     *     - 返り値が空いてるなら変に参照を使わず返り値の方がシンプル
     *
     * array_walk_recursive で「この要素は伏せたいのに…」「このノードだけ触りたいのに…」ということはままあるが、
     * - $array が渡ってくるので unset したり他のキーを生やしたりすることが可能
     * - $keys が渡ってくるのでツリー構造の特定のノードだけ触ることが可能
     * になっている。
     *
     * 「map も filter も可能」という少しマッチョな関数。
     * 実質的には「再帰的な array_kvmap」のように振る舞う。
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param callable $callback コールバック
     * @return array walk 後の配列
     */
    function array_walk_recursive2($array, $callback)
    {
        $callback = func_user_func_array($callback);

        $main = function (&$array, $keys) use (&$main, $callback) {
            foreach ($array as $k => &$v) {
                if (is_array($v)) {
                    $main($v, array_merge($keys, [$k]));
                }
                else {
                    $callback($v, $k, $array, $keys);
                }
            }
        };
        $main($array, []);
        return $array;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_where') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_where'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_where')) {
    /**
     * 指定キーの要素で array_filter する
     *
     * array_column があるなら array_where があってもいいはず。
     *
     * $column はコールバックに渡ってくる配列のキー名を渡す。null を与えると行全体が渡ってくる。
     * $callback は絞り込み条件を渡す。null を与えると true 相当の値でフィルタする。
     * つまり $column も $callback も省略した場合、実質的に array_filter と同じ動作になる。
     *
     * $column は配列を受け入れる。配列を渡した場合その値の共通項がコールバックに渡る。
     * 連想配列の場合は「キーのカラム == 値」で filter する（それぞれで AND。厳密かどうかは $callback で指定。説明が難しいので Example を参照）。
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * $array = [
     *     0 => ['id' => 1, 'name' => 'hoge', 'flag' => false],
     *     1 => ['id' => 2, 'name' => 'fuga', 'flag' => true],
     *     2 => ['id' => 3, 'name' => 'piyo', 'flag' => false],
     * ];
     * // 'flag' が true 相当のものだけ返す
     * that(array_where($array, 'flag'))->isSame([
     *     1 => ['id' => 2, 'name' => 'fuga', 'flag' => true],
     * ]);
     * // 'name' に 'h' を含むものだけ返す
     * $contain_h = fn($name) => strpos($name, 'h') !== false;
     * that(array_where($array, 'name', $contain_h))->isSame([
     *     0 => ['id' => 1, 'name' => 'hoge', 'flag' => false],
     * ]);
     * // $callback が引数2つならキーも渡ってくる（キーが 2 のものだけ返す）
     * $equal_2 = fn($row, $key) => $key === 2;
     * that(array_where($array, null, $equal_2))->isSame([
     *     2 => ['id' => 3, 'name' => 'piyo', 'flag' => false],
     * ]);
     * // $column に配列を渡すと共通項が渡ってくる
     * $idname_is_2fuga = fn($idname) => ($idname['id'] . $idname['name']) === '2fuga';
     * that(array_where($array, ['id', 'name'], $idname_is_2fuga))->isSame([
     *     1 => ['id' => 2, 'name' => 'fuga', 'flag' => true],
     * ]);
     * // $column に連想配列を渡すと「キーのカラム == 値」で filter する（要するに「name が piyo かつ flag が false」で filter）
     * that(array_where($array, ['name' => 'piyo', 'flag' => false]))->isSame([
     *     2 => ['id' => 3, 'name' => 'piyo', 'flag' => false],
     * ]);
     * // 上記において値に配列を渡すと in_array で判定される
     * that(array_where($array, ['id' => [2, 3]]))->isSame([
     *     1 => ['id' => 2, 'name' => 'fuga', 'flag' => true],
     *     2 => ['id' => 3, 'name' => 'piyo', 'flag' => false],
     * ]);
     * // $column の連想配列の値にはコールバックが渡せる（それぞれで AND）
     * that(array_where($array, [
     *     'id'   => fn($id) => $id >= 3,                       // id が 3 以上
     *     'name' => fn($name) => strpos($name, 'o') !== false, // name に o を含む
     * ]))->isSame([
     *     2 => ['id' => 3, 'name' => 'piyo', 'flag' => false],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|array|null $column キー名
     * @param ?callable $callback 評価クロージャ
     * @return array $where が真を返した新しい配列
     */
    function array_where($array, $column = null, $callback = null)
    {
        if ($column instanceof \Closure) {
            $callback = $column;
            $column = null;
        }

        $is_array = is_array($column);
        if ($is_array) {
            if (is_hasharray($column)) {
                if ($callback !== null && !is_bool($callback)) {
                    throw new \InvalidArgumentException('if hash array $column, $callback must be bool.');
                }
                $callbacks = array_map(function ($c) use ($callback) {
                    if ($c instanceof \Closure) {
                        return $c;
                    }
                    if ($callback) {
                        return fn($v) => $v === $c;
                    }
                    else {
                        return fn($v) => is_array($c) ? in_array($v, $c) : $v == $c;
                    }
                }, $column);
                $callback = function ($vv, $k, $v) use ($callbacks) {
                    foreach ($callbacks as $c => $callback) {
                        if (!$callback($vv[$c], $k)) {
                            return false;
                        }
                    }
                    return true;
                };
            }
            else {
                $column = array_flip($column);
            }
        }

        $callback = func_user_func_array($callback);

        $result = [];
        foreach ($array as $k => $v) {
            if ($column === null) {
                $vv = $v;
            }
            elseif ($is_array) {
                $vv = array_intersect_key($v, $column);
            }
            else {
                $vv = $v[$column];
            }

            if ($callback($vv, $k, $v)) {
                $result[$k] = $v;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\array_zip') || (new \ReflectionFunction('ryunosuke\\ltsv\\array_zip'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\array_zip')) {
    /**
     * 配列の各要素値で順番に配列を作る
     *
     * `array_map(null, ...$arrays)` とほぼ同義。ただし
     *
     * - 文字キーは保存される（数値キーは再割り振りされる）
     * - 一つだけ配列を与えても構造は壊れない（array_map(null) は壊れる）
     *
     * Example:
     * ```php
     * // 普通の zip
     * that(array_zip(
     *     [1, 2, 3],
     *     ['hoge', 'fuga', 'piyo']
     * ))->is([[1, 'hoge'], [2, 'fuga'], [3, 'piyo']]);
     * // キーが維持される
     * that(array_zip(
     *     ['a' => 1, 2, 3],
     *     ['hoge', 'b' => 'fuga', 'piyo']
     * ))->is([['a' => 1, 'hoge'], [2, 'b' => 'fuga'], [3, 'piyo']]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array ...$arrays 対象配列（可変引数）
     * @return array 各要素値の配列
     */
    function array_zip(...$arrays)
    {
        $count = count($arrays);
        if ($count === 0) {
            throw new \InvalidArgumentException('$arrays is empty.');
        }

        // キー保持処理がかなり遅いので純粋な配列しかないのなら array_map(null) の方が（チェックを加味しても）速くなる
        foreach ($arrays as $a) {
            if (is_hasharray($a)) {
                $yielders = array_map(function ($array) { yield from $array; }, $arrays);

                $result = [];
                for ($i = 0, $limit = max(array_map('count', $arrays)); $i < $limit; $i++) {
                    $e = [];
                    foreach ($yielders as $yielder) {
                        array_set($e, $yielder->current(), is_int($yielder->key()) ? null : $yielder->key());
                        $yielder->next();
                    }
                    $result[] = $e;
                }
                return $result;
            }
        }

        // array_map(null) は1つだけ与えると構造がぶっ壊れる
        if ($count === 1) {
            return array_map(fn($v) => [$v], $arrays[0]);
        }
        return array_map(null, ...$arrays);

        /* MultipleIterator を使った実装。かなり遅かったので採用しなかったが、一応コメントとして残す
        $mi = new \MultipleIterator(\MultipleIterator::MIT_NEED_ANY | \MultipleIterator::MIT_KEYS_NUMERIC);
        foreach ($arrays as $array) {
            $mi->attachIterator((function ($array) { yield from $array; })($array));
        }
    
        $result = [];
        foreach ($mi as $k => $v) {
            $e = [];
            for ($i = 0; $i < $count; $i++) {
                Arrays::array_put($e, $v[$i], $k[$i]);
            }
            $result[] = $e;
        }
        return $result;
        */
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arrayize') || (new \ReflectionFunction('ryunosuke\\ltsv\\arrayize'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arrayize')) {
    /**
     * 引数の配列を生成する。
     *
     * 配列以外を渡すと配列化されて追加される。
     * 配列を渡してもそのままだが、連番配列の場合はマージ、連想配列の場合は結合となる。
     * iterable や Traversable は考慮せずあくまで「配列」としてチェックする。
     *
     * Example:
     * ```php
     * // 値は配列化される
     * that(arrayize(1, 2, 3))->isSame([1, 2, 3]);
     * // 配列はそのまま
     * that(arrayize([1], [2], [3]))->isSame([1, 2, 3]);
     * // 連想配列、連番配列の挙動
     * that(arrayize([1, 2, 3], [4, 5, 6], ['a' => 'A1'], ['a' => 'A2']))->isSame([1, 2, 3, 4, 5, 6, 'a' => 'A1']);
     * // stdClass は foreach 可能だがあくまで配列としてチェックする
     * $object = new \stdClass();
     * that(arrayize($object, false, [1, 2, 3]))->isSame([$object, false, 1, 2, 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param mixed ...$variadic 生成する要素（可変引数）
     * @return array 引数を配列化したもの
     */
    function arrayize(...$variadic)
    {
        $result = [];
        foreach ($variadic as $arg) {
            if (!is_array($arg)) {
                $result[] = $arg;
            }
            elseif ($result && !is_hasharray($arg)) {
                $result = array_merge($result, $arg);
            }
            else {
                // array_merge に合わせるなら $result = $arg + $result で後方上書きの方がいいかも
                // 些細な変更だけど後方互換性が完全に壊れるのでいったん保留（可変引数なんてほとんど使ってないと思うけど…）
                $result += $arg; // for compatible
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arrays') || (new \ReflectionFunction('ryunosuke\\ltsv\\arrays'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arrays')) {
    /**
     * 配列をシーケンシャルに走査するジェネレータを返す
     *
     * 「シーケンシャルに」とは要するに数値連番が得られるように走査するということ。
     * 0ベースの連番を作ってインクリメントしながら foreach するのと全く変わらない。
     *
     * キーは連番、値は [$key, $value] で返す。
     * つまり、 Example のように foreach の list 構文を使えば「連番、キー、値」でループを回すことが可能になる。
     * 「foreach で回したいんだけど連番も欲しい」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * $nkv = [];
     * foreach (arrays($array) as $n => [$k, $v]) {
     *     $nkv[] = "$n,$k,$v";
     * }
     * that($nkv)->isSame(['0,a,A', '1,b,B', '2,c,C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @return \Generator [$seq => [$key, $value]] を返すジェネレータ
     */
    function arrays($array)
    {
        $n = 0;
        foreach ($array as $k => $v) {
            yield $n++ => [$k, $v];
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\first_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\first_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\first_key')) {
    /**
     * 配列の最初のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_key(['a', 'b', 'c']))->isSame(0);
     * that(first_key([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最初のキー
     */
    function first_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = first_keyvalue($array);
        return $k;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\first_keyvalue') || (new \ReflectionFunction('ryunosuke\\ltsv\\first_keyvalue'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\first_keyvalue')) {
    /**
     * 配列の最初のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_keyvalue(['a', 'b', 'c']))->isSame([0, 'a']);
     * that(first_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最初のキー, 最初の値]
     */
    function first_keyvalue($array, $default = null)
    {
        foreach ($array as $k => $v) {
            return [$k, $v];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\first_value') || (new \ReflectionFunction('ryunosuke\\ltsv\\first_value'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\first_value')) {
    /**
     * 配列の最初の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_value(['a', 'b', 'c']))->isSame('a');
     * that(first_value([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最初の値
     */
    function first_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = first_keyvalue($array);
        return $v;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\groupsort') || (new \ReflectionFunction('ryunosuke\\ltsv\\groupsort'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\groupsort')) {
    /**
     * 配列を部分的にソートする
     *
     * $grouper でグルーピングされた部分配列を $comparator でソートし、元の位置に埋め込む。
     * 元の配列の並び順は可能な限り維持される。
     *
     * $grouper はグループを決定づける何かを返す。
     * 一意であれば何でも良いが、内部的に配列のキーに格納されるため、文字列であることが望ましい。
     *
     * Example:
     * ```php
     * // 下記のような配列を元の順番を保ちつつ各々の group で部分的にソートする
     * $array = [
     *     ['id' => 1, 'group' => 'A', 'name' => 'q'],
     *     ['id' => 2, 'group' => 'A', 'name' => 'a'],
     *     ['id' => 3, 'group' => 'A', 'name' => 'z'],
     *     ['id' => 4, 'group' => null, 'name' => 'noise'],
     *     ['id' => 5, 'group' => 'B', 'name' => 'w'],
     *     ['id' => 6, 'group' => 'B', 'name' => 's'],
     *     ['id' => 7, 'group' => 'B', 'name' => 'x'],
     *     ['id' => 8, 'group' => 'C', 'name' => 'e'],
     *     ['id' => 9, 'group' => 'C', 'name' => 'd'],
     *     ['id' => 10, 'group' => null, 'name' => 'noise'],
     *     ['id' => 11, 'group' => 'C', 'name' => 'c'],
     * ];
     * that(groupsort($array, fn($v, $k) => $v['group'], fn($a, $b) => $a['name'] <=> $b['name']))->is([
     *     1  => ["id" => 2, "group" => "A", "name" => "a"],
     *     0  => ["id" => 1, "group" => "A", "name" => "q"],
     *     2  => ["id" => 3, "group" => "A", "name" => "z"],
     *     3  => ["id" => 4, "group" => null, "name" => "noise"],
     *     5  => ["id" => 6, "group" => "B", "name" => "s"],
     *     4  => ["id" => 5, "group" => "B", "name" => "w"],
     *     6  => ["id" => 7, "group" => "B", "name" => "x"],
     *     10 => ["id" => 11, "group" => "C", "name" => "c"],
     *     8  => ["id" => 9, "group" => "C", "name" => "d"],
     *     7  => ["id" => 8, "group" => "C", "name" => "e"],
     *     9  => ["id" => 10, "group" => null, "name" => "noise"],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $grouper グループ導出関数
     * @param callable $comparator 部分配列の比較関数
     * @return array 部分ソートされた配列
     */
    function groupsort($array, $grouper, $comparator)
    {
        $tmp = [];
        $mapper = [];
        $placeholders = [];

        $n = 0;
        foreach ($array as $k => $v) {
            $group = $grouper($v, $k, $n++);
            if ($group !== null) {
                if (!isset($placeholders[$group])) {
                    $placeholders[$group] = new \stdClass();
                    $oid = spl_object_id($placeholders[$group]);
                    $mapper[$oid] = $placeholders[$group];
                    $tmp[$oid] = $placeholders[$group];
                }
                $placeholders[$group]->$k = $v;
            }
            else {
                $tmp[$k] = $v;
            }
        }

        $result = [];

        foreach ($tmp as $k => $v) {
            if ($v instanceof \stdClass && isset($mapper[spl_object_id($v)])) {
                $result += kvsort((array) $v, $comparator);
            }
            else {
                $result[$k] = $v;
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\in_array_and') || (new \ReflectionFunction('ryunosuke\\ltsv\\in_array_and'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\in_array_and')) {
    /**
     * in_array の複数版（AND）
     *
     * 配列 $haystack が $needle の「すべてを含む」ときに true を返す。
     *
     * $needle が非配列の場合は配列化される。
     * $needle が空の場合は常に false を返す。
     *
     * Example:
     * ```php
     * that(in_array_and([1], [1, 2, 3]))->isTrue();
     * that(in_array_and([9], [1, 2, 3]))->isFalse();
     * that(in_array_and([1, 9], [1, 2, 3]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|mixed $needle 調べる値
     * @param array $haystack 調べる配列
     * @param bool $strict 厳密フラグ
     * @return bool $needle のすべてが含まれているなら true
     */
    function in_array_and($needle, $haystack, $strict = false)
    {
        $needle = is_iterable($needle) ? $needle : [$needle];
        if (is_empty($needle)) {
            return false;
        }

        foreach ($needle as $v) {
            if (!in_array($v, $haystack, $strict)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\in_array_or') || (new \ReflectionFunction('ryunosuke\\ltsv\\in_array_or'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\in_array_or')) {
    /**
     * in_array の複数版（OR）
     *
     * 配列 $haystack が $needle の「どれかを含む」ときに true を返す。
     *
     * $needle が非配列の場合は配列化される。
     * $needle が空の場合は常に false を返す。
     *
     * Example:
     * ```php
     * that(in_array_or([1], [1, 2, 3]))->isTrue();
     * that(in_array_or([9], [1, 2, 3]))->isFalse();
     * that(in_array_or([1, 9], [1, 2, 3]))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|mixed $needle 調べる値
     * @param array $haystack 調べる配列
     * @param bool $strict 厳密フラグ
     * @return bool $needle のどれかが含まれているなら true
     */
    function in_array_or($needle, $haystack, $strict = false)
    {
        $needle = is_iterable($needle) ? $needle : [$needle];
        if (is_empty($needle)) {
            return false;
        }

        foreach ($needle as $v) {
            if (in_array($v, $haystack, $strict)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_hasharray') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_hasharray'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_hasharray')) {
    /**
     * 配列が連想配列か調べる
     *
     * 空の配列は普通の配列とみなす。
     *
     * Example:
     * ```php
     * that(is_hasharray([]))->isFalse();
     * that(is_hasharray([1, 2, 3]))->isFalse();
     * that(is_hasharray(['x' => 'X']))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @return bool 連想配列なら true
     */
    function is_hasharray(array $array)
    {
        if (function_exists('array_is_list')) {
            return !array_is_list($array); // @codeCoverageIgnore
        }

        $i = 0;
        foreach ($array as $k => $dummy) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_indexarray') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_indexarray'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_indexarray')) {
    /**
     * 配列が数値配列か調べる
     *
     * 空の配列も数値配列とみなす。
     * さらにいわゆる「連番配列」ではなく「キーが数値のみか？」で判定する。
     *
     * つまり、 is_hasharray とは排他的ではない。
     *
     * Example:
     * ```php
     * that(is_indexarray([]))->isTrue();
     * that(is_indexarray([1, 2, 3]))->isTrue();
     * that(is_indexarray(['x' => 'X']))->isFalse();
     * // 抜け番があっても true になる（これは is_hasharray も true になる）
     * that(is_indexarray([1 => 1, 2 => 2, 3 => 3]))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @return bool 数値配列なら true
     */
    function is_indexarray($array)
    {
        foreach ($array as $k => $dummy) {
            if (!is_int($k)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\kvsort') || (new \ReflectionFunction('ryunosuke\\ltsv\\kvsort'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\kvsort')) {
    /**
     * 比較関数にキーも渡ってくる安定ソート
     *
     * 比較関数は ($valueA, $valueB, $keyA, $keyB) という引数を取る。
     * 「値で比較して同値だったらキーも見たい」という状況はまれによくあるはず。
     * さらに安定ソートであり、同値だとしても元の並び順は維持される。
     *
     * $schwartzians を指定した場合は呼び出しが ($schwartzianA, $schwartzianB, $valueA, $valueB, $keyA, $keyB) になる。
     * $schwartzianX は単一値の場合はその結果、配列の場合はキー構造が維持されて渡ってくる。
     * このあたりは表現しにくいので Example を参照。
     *
     * $comparator は省略できる。省略した場合、型に基づいてよしなにソートする。
     * （が、比較のたびに型チェックが入るので指定したほうが高速に動く）。
     *
     * ただし、標準のソート関数とは異なり、参照渡しではなくソートして返り値で返す。
     * また、いわゆる asort であり、キー・値は常に維持される。
     *
     * Example:
     * ```php
     * $array = [
     *     'a'  => 3,
     *     'b'  => 1,
     *     'c'  => 2,
     *     'x1' => 9,
     *     'x2' => 9,
     *     'x3' => 9,
     * ];
     * // 普通のソート
     * that(kvsort($array))->isSame([
     *     'b'  => 1,
     *     'c'  => 2,
     *     'a'  => 3,
     *     'x1' => 9,
     *     'x2' => 9,
     *     'x3' => 9,
     * ]);
     * // キーを使用したソート
     * that(kvsort($array, fn($av, $bv, $ak, $bk) => strcmp($bk, $ak)))->isSame([
     *     'x3' => 9,
     *     'x2' => 9,
     *     'x1' => 9,
     *     'c'  => 2,
     *     'b'  => 1,
     *     'a'  => 3,
     * ]);
     * // シュワルツ変換を使用したソート（引数説明のために全て列挙している）
     * that(kvsort($array, fn($hashA, $hashB, $av, $bv, $ak, $bk) => ($hashA['md5'] <=> $hashB['md5']) ?: ($hashA['sha1'] <=> $hashB['sha1']), [
     *     'md5'  => fn($v) => md5($v),
     *     'sha1' => fn($v) => sha1($v),
     * ]))->isSame([
     *     'x1' => 9,
     *     'x2' => 9,
     *     'x3' => 9,
     *     'b'  => 1,
     *     'c'  => 2,
     *     'a'  => 3,
     * ]);
     * // シュワルツ変換の場合 $comparator は省略可能（昇順）で、配列ではなく単一値を渡せばその結果値が渡ってくる（これは要するに md5 での昇順ソート）
     * that(kvsort($array, null, fn($v) => md5($v)))->isSame([
     *     'x1' => 9,
     *     'x2' => 9,
     *     'x3' => 9,
     *     'b'  => 1,
     *     'c'  => 2,
     *     'a'  => 3,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @template T of iterable|array
     * @param T $array 対象配列
     * @param callable|int|null $comparator 比較関数。SORT_XXX も使える
     * @param callable|callable[] $schwartzians シュワルツ変換に使用する仮想列
     * @return T ソートされた配列
     */
    function kvsort($array, $comparator = null, $schwartzians = [])
    {
        // シュワルツ変換の準備（単一であるとかピッタリ呼び出しとか）
        $is_array = is_array($schwartzians) && !is_callable($schwartzians);
        $schwartzians = arrayize($schwartzians);
        foreach ($schwartzians as $s => $schwartzian) {
            $schwartzians[$s] = func_user_func_array($schwartzian);
        }

        // $comparator が定数あるいは省略時は自動導出
        if ($comparator === null || is_int($comparator)) {
            // シュワルツ変換のときは型は意識しなくてよい（呼び元の責務）ので昇順降順だけ見る
            if ($schwartzians) {
                if (($comparator ?? SORT_ASC) === SORT_ASC) {
                    $comparator = fn($as, $bs) => $as <=> $bs;
                }
                else {
                    $comparator = fn($as, $bs) => -($as <=> $bs);
                }
            }
            // そうでない場合は varcmp に委譲
            else {
                $sort_flg = $comparator;
                $comparator = fn($av, $bv, $ak, $bk) => varcmp($av, $bv, $sort_flg);
            }
        }

        // 一時配列の準備
        $n = 0;
        $virtuals = [];
        $result = [];
        foreach ($array as $k => $v) {
            if ($is_array) {
                foreach ($schwartzians as $s => $schwartzian) {
                    $virtuals[$k][$s] = $schwartzian($v, $k, $n);
                }
            }
            else {
                $virtuals[$k] = $schwartzians[0]($v, $k, $n);
            }
            $result[$k] = $v;
        }
        uksort($result, function ($keyA, $keyB) use ($result, $comparator, $virtuals) {
            $a = $result[$keyA];
            $b = $result[$keyB];

            $virtual = $virtuals ? [$virtuals[$keyA], $virtuals[$keyB]] : [];
            return $comparator(...$virtual, ...[$a, $b, $keyA, $keyB]);
        });
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\last_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\last_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\last_key')) {
    /**
     * 配列の最後のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_key(['a', 'b', 'c']))->isSame(2);
     * that(last_key([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後のキー
     */
    function last_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $k;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\last_keyvalue') || (new \ReflectionFunction('ryunosuke\\ltsv\\last_keyvalue'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\last_keyvalue')) {
    /**
     * 配列の最後のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_keyvalue(['a', 'b', 'c']))->isSame([2, 'c']);
     * that(last_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最後のキー, 最後の値]
     */
    function last_keyvalue($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        if (is_array($array)) {
            $k = array_key_last($array);
            return [$k, $array[$k]];
        }
        /** @noinspection PhpStatementHasEmptyBodyInspection */
        foreach ($array as $k => $v) {
            // dummy
        }
        // $k がセットされてるなら「ループが最低でも1度回った（≠空）」とみなせる
        if (isset($k)) {
            /** @noinspection PhpUndefinedVariableInspection */
            return [$k, $v];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\last_value') || (new \ReflectionFunction('ryunosuke\\ltsv\\last_value'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\last_value')) {
    /**
     * 配列の最後の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_value(['a', 'b', 'c']))->isSame('c');
     * that(last_value([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後の値
     */
    function last_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $v;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\next_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\next_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\next_key')) {
    /**
     * 配列の指定キーの次のキーを返す
     *
     * $key が最後のキーだった場合は null を返す。
     * $key が存在しない場合は false を返す。
     * $key が未指定だと「次に生成されるキー」（$array[]='hoge' で生成されるキー）を返す。
     *
     * $array[] = 'hoge' で作成されるキーには完全準拠しない（標準は unset すると結構乱れる）。公式マニュアルを参照。
     *
     * Example:
     * ```php
     * $array = [9 => 9, 'a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 'b' キーの次は 'c'
     * that(next_key($array, 'b'))->isSame('c');
     * // 'c' キーの次は無いので null
     * that(next_key($array, 'c'))->isSame(null);
     * // 'x' キーはそもそも存在しないので false
     * that(next_key($array, 'x'))->isSame(false);
     * // 次に生成されるキーは 10
     * that(next_key($array, null))->isSame(10);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param string|int|null $key 調べるキー
     * @return string|int|bool|null $key の次のキー
     */
    function next_key($array, $key = null)
    {
        $keynull = $key === null;
        $key = (string) $key;
        $current = false;
        $max = -1;
        foreach ($array as $k => $v) {
            if ($current !== false) {
                return $k;
            }
            if ($key === (string) $k) {
                $current = null;
            }
            if ($keynull && is_int($k) && $k > $max) {
                $max = $k;
            }
        }
        if ($keynull) {
            // PHP 4.3.0 以降は0以下にはならない
            return max(0, $max + 1);
        }
        else {
            return $current;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\prev_key') || (new \ReflectionFunction('ryunosuke\\ltsv\\prev_key'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\prev_key')) {
    /**
     * 配列の指定キーの前のキーを返す
     *
     * $key が最初のキーだった場合は null を返す。
     * $key が存在しない場合は false を返す。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 'b' キーの前は 'a'
     * that(prev_key($array, 'b'))->isSame('a');
     * // 'a' キーの前は無いので null
     * that(prev_key($array, 'a'))->isSame(null);
     * // 'x' キーはそもそも存在しないので false
     * that(prev_key($array, 'x'))->isSame(false);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param string|int $key 調べるキー
     * @return string|int|bool|null $key の前のキー
     */
    function prev_key($array, $key)
    {
        $key = (string) $key;
        $current = null;
        foreach ($array as $k => $v) {
            if ($key === (string) $k) {
                return $current;
            }
            $current = $k;
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\auto_loader') || (new \ReflectionFunction('ryunosuke\\ltsv\\auto_loader'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\auto_loader')) {
    /**
     * vendor/autoload.php を返す
     *
     * かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。
     *
     * Example:
     * ```php
     * that(auto_loader())->contains('autoload.php');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param ?string $startdir 高速化用の検索開始ディレクトリを指定するが、どちらかと言えばテスト用
     * @return string autoload.php のフルパス
     */
    function auto_loader($startdir = null)
    {
        return cache("path-$startdir", function () use ($startdir) {
            $cache = dirname_r($startdir ?: __DIR__, function ($dir) {
                if (file_exists($file = "$dir/autoload.php") || file_exists($file = "$dir/vendor/autoload.php")) {
                    return $file;
                }
            });
            if (!$cache) {
                throw new \DomainException('autoloader is not found.');
            }
            return $cache;
        }, __FUNCTION__);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_aliases') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_aliases'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_aliases')) {
    /**
     * 遅延ロードする class_alias
     *
     * class_alias は即座にオートロードされるが、この関数は必要とされるまでオートロードしない。
     *
     * Example:
     * ```php
     * class_aliases([
     *     'TestCase' => \PHPUnit\Framework\TestCase::class,
     * ]);
     * that(class_exists('TestCase', false))->isFalse(); // オートロードを走らせなければまだ定義されていない
     * that(class_exists('TestCase', true))->isTrue();   // オートロードを走らせなければ定義されている
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param array $aliases
     * @return array エイリアス配列
     */
    function class_aliases($aliases)
    {
        static $alias_map = [];

        foreach ($aliases as $alias => $class) {
            $alias_map[trim($alias, '\\')] = $class;
        }

        static $registered = false;
        if (!$registered) {
            $registered = true;
            spl_autoload_register(function ($class) use (&$alias_map) {
                if (isset($alias_map[$class])) {
                    class_alias($alias_map[$class], $class);
                }
            }, true, true);
        }

        return $alias_map;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_constants') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_constants'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_constants')) {
    /**
     * クラス定数を配列で返す
     *
     * `(new \ReflectionClass($class))->getConstants()` とほぼ同じだが、可視性でフィルタができる。
     * さらに「自分自身の定義か？」でもフィルタできる。
     *
     * Example:
     * ```php
     * $class = new class extends \ArrayObject
     * {
     *     private   const C_PRIVATE   = 'private';
     *     protected const C_PROTECTED = 'protected';
     *     public    const C_PUBLIC    = 'public';
     * };
     * // 普通に全定数を返す
     * that(class_constants($class))->isSame([
     *     'C_PRIVATE'      => 'private',
     *     'C_PROTECTED'    => 'protected',
     *     'C_PUBLIC'       => 'public',
     *     'STD_PROP_LIST'  => \ArrayObject::STD_PROP_LIST,
     *     'ARRAY_AS_PROPS' => \ArrayObject::ARRAY_AS_PROPS,
     * ]);
     * // public のみを返す
     * that(class_constants($class, IS_PUBLIC))->isSame([
     *     'C_PUBLIC'       => 'public',
     *     'STD_PROP_LIST'  => \ArrayObject::STD_PROP_LIST,
     *     'ARRAY_AS_PROPS' => \ArrayObject::ARRAY_AS_PROPS,
     * ]);
     * // 自身定義でかつ public のみを返す
     * that(class_constants($class, IS_OWNSELF | IS_PUBLIC))->isSame([
     *     'C_PUBLIC'       => 'public',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $class クラス名 or オブジェクト
     * @param ?int $filter アクセスレベル定数
     * @return array クラス定数の配列
     */
    function class_constants($class, $filter = null)
    {
        $class = ltrim(is_object($class) ? get_class($class) : $class, '\\');
        $filter ??= (IS_PUBLIC | IS_PROTECTED | IS_PRIVATE);

        $result = [];
        foreach ((new \ReflectionClass($class))->getReflectionConstants() as $constant) {
            if (($filter & IS_OWNSELF) && $constant->getDeclaringClass()->name !== $class) {
                continue;
            }
            $modifiers = $constant->getModifiers();
            $modifiers2 = 0;
            $modifiers2 |= ($modifiers & \ReflectionProperty::IS_PUBLIC) ? IS_PUBLIC : 0;
            $modifiers2 |= ($modifiers & \ReflectionProperty::IS_PROTECTED) ? IS_PROTECTED : 0;
            $modifiers2 |= ($modifiers & \ReflectionProperty::IS_PRIVATE) ? IS_PRIVATE : 0;
            if ($modifiers2 & $filter) {
                $result[$constant->name] = $constant->getValue();
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_extends') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_extends'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_extends')) {
    /**
     * インスタンスを動的に拡張する
     *
     * インスタンスに特異メソッド・特異フィールドのようなものを生やす。
     * ただし、特異フィールドの用途はほとんどない（php はデフォルトで特異フィールドのような動作なので）。
     * そのクラスの `__set`/`__get` が禁止されている場合に使えるかもしれない程度。
     *
     * クロージャ配列を渡すと特異メソッドになる。
     * そのクロージャの $this は元オブジェクトで bind される。
     * ただし、static closure を渡した場合はそれは static メソッドとして扱われる。
     *
     * $implements でインターフェースの配列を渡すとすべてが動的に implement される。
     * つまり得られたオブジェクトが instanceof を通るようになる。
     * もちろんメソッド配列としてその名前が含まれていなければならない。
     *
     * 内部的にはいわゆる Decorator パターンを動的に実行しているだけであり、実行速度は劣悪。
     * 当然ながら final クラス/メソッドの拡張もできない。
     *
     * Example:
     * ```php
     * // Exception に「count」メソッドと「コードとメッセージを結合して返す」メソッドを動的に生やす
     * $object = new \Exception('hoge', 123);
     * $newobject = class_extends($object, [
     *     'count'       => function () { return $this->code; },
     *     'codemessage' => function () {
     *         // bind されるので protected フィールドが使える
     *         return $this->code . ':' . $this->message;
     *     },
     * ], [], [\Countable::class]);
     * that($newobject->count())->isSame(123);
     * that($newobject->codemessage())->isSame('123:hoge');
     * that($newobject)->isInstanceOf(\Countable::class); // instanceof をパスできる
     *
     * // オーバーライドもできる（ArrayObject の count を2倍になるように上書き）
     * $object = new \ArrayObject([1, 2, 3]);
     * $newobject = class_extends($object, [
     *     'count' => function () {
     *         // parent は元オブジェクトを表す
     *         return parent::count() * 2;
     *     },
     * ]);
     * that($newobject->count())->isSame(6);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @template T
     * @param T $object 対象オブジェクト
     * @param \Closure[] $methods 注入するメソッド
     * @param array $fields 注入するフィールド
     * @param array $implements 実装するインターフェース
     * @return T $object を拡張した object
     */
    function class_extends($object, $methods, $fields = [], $implements = [])
    {
        assert(is_array($methods));

        static $template_source, $template_reflection;
        if (!isset($template_source)) {
            // コード補完やフォーマッタを効かせたいので文字列 eval ではなく直に new する（1回だけだし）
            // @codeCoverageIgnoreStart
            $template_reflection = new \ReflectionClass(new class() {
                    private static $__originalClass;
                    private        $__original;
                    private        $__fields;
                    private        $__methods       = [];
                    private static $__staticMethods = [];

                    public function __construct(\ReflectionClass $refclass = null, $original = null, $fields = [], $methods = [])
                    {
                        if ($refclass === null) {
                            return;
                        }
                        self::$__originalClass = get_class($original);

                        $this->__original = $original;
                        $this->__fields = $fields;

                        foreach ($methods as $name => $method) {
                            $bmethod = @$method->bindTo($this->__original, $refclass->isInternal() ? $this : $this->__original);
                            // 内部クラスは $this バインドできないので original じゃなく自身にする
                            if ($bmethod) {
                                $this->__methods[$name] = $bmethod;
                            }
                            else {
                                self::$__staticMethods[$name] = $method->bindTo(null, self::$__originalClass);
                            }
                        }
                    }

                    public function __clone()
                    {
                        $this->__original = clone $this->__original;
                    }

                    public function __get($name)
                    {
                        if (array_key_exists($name, $this->__fields)) {
                            return $this->__fields[$name];
                        }
                        return $this->__original->$name;
                    }

                    public function __set($name, $value)
                    {
                        if (array_key_exists($name, $this->__fields)) {
                            return $this->__fields[$name] = $value;
                        }
                        return $this->__original->$name = $value;
                    }

                    public function __call($name, $arguments)
                    {
                        return $this->__original->$name(...$arguments);
                    }

                    public static function __callStatic($name, $arguments)
                    {
                        return self::$__originalClass::$name(...$arguments);
                    }
                }
            );
            // @codeCoverageIgnoreEnd
            $sl = $template_reflection->getStartLine();
            $el = $template_reflection->getEndLine();
            $template_source = array_slice(file($template_reflection->getFileName()), $sl, $el - $sl - 1, true);
        }

        $parse = static function ($name, \ReflectionFunctionAbstract $reffunc) {
            if ($reffunc instanceof \ReflectionMethod) {
                $modifier = implode(' ', \Reflection::getModifierNames($reffunc->getModifiers()));
                $receiver = ($reffunc->isStatic() ? 'self::$__originalClass::' : '$this->__original->') . $name;
            }
            else {
                $bindable = is_bindable_closure($reffunc->getClosure());
                $modifier = $bindable ? '' : 'static ';
                $receiver = ($bindable ? '$this->__methods' : 'self::$__staticMethods') . "[" . var_export($name, true) . "]";
            }

            $ref = $reffunc->returnsReference() ? '&' : '';

            $params = function_parameter($reffunc);
            $prms = implode(', ', $params);
            $args = implode(', ', array_keys($params));

            $rtype = strval($reffunc->getReturnType());
            $return = $rtype === 'void' ? '' : 'return $return;';
            $rtype = $rtype ? ": $rtype" : '';

            return [
                "#[\ReturnTypeWillChange]\n$modifier function $ref$name($prms)$rtype",
                "{ \$return = $ref$receiver(...[$args]);$return }\n",
            ];
        };

        /** @var \ReflectionClass[][]|\ReflectionMethod[][][] $spawners */
        static $spawners = [];

        $classname = get_class($object);
        $classalias = str_replace('\\', '__', $classname);

        if (!isset($spawners[$classname])) {
            $template = $template_source;
            $template_methods = get_class_methods($template_reflection->getName());
            $refclass = new \ReflectionClass($classname);
            $classmethods = [];
            foreach ($refclass->getMethods() as $method) {
                if (in_array($method->getName(), $template_methods)) {
                    if ($method->isFinal()) {
                        $template_method = $template_reflection->getMethod($method->name);
                        array_unset($template, range($template_method->getStartLine() - 1, $template_method->getEndLine()));
                    }
                }
                else {
                    if (!$method->isFinal() && !$method->isAbstract()) {
                        $classmethods[$method->name] = $method;
                    }
                }
            }

            $cachefile = function_configure('cachedir') . '/' . rawurlencode(__FUNCTION__ . '-' . $classname) . '.php';
            if (!file_exists($cachefile)) {
                $declares = "";
                foreach ($classmethods as $name => $method) {
                    $declares .= implode(' ', $parse($name, $method));
                }
                $traitcode = "trait X{$classalias}Trait\n{\n" . implode('', $template) . "{$declares}}";
                file_put_contents($cachefile, "<?php\n" . $traitcode, LOCK_EX);
            }

            require_once $cachefile;
            $spawners[$classname] = [
                'original' => $refclass,
                'methods'  => $classmethods,
            ];
        }

        $declares = "";
        // 指定クロージャ配列から同名メソッドを差っ引いたもの（まさに特異メソッドとなる）
        foreach (array_diff_key($methods, $spawners[$classname]['methods']) as $name => $singular) {
            $declares .= implode(' ', $parse($name, new \ReflectionFunction($singular)));
        }
        // 指定クロージャ配列でメソッドと同名のもの（オーバーライドを模倣する）
        foreach (array_intersect_key($methods, $spawners[$classname]['methods']) as $name => $override) {
            $method = $spawners[$classname]['methods'][$name];
            $ref = $method->returnsReference() ? '&' : '';
            $receiver = $method->isStatic() ? 'self::$__originalClass::' : '$this->__original->';
            $modifier = implode(' ', \Reflection::getModifierNames($method->getModifiers()));

            // シグネチャエラーが出てしまうので、指定がない場合は強制的に合わせる
            $refmember = new \ReflectionFunction($override);
            $params = function_parameter(!$refmember->getNumberOfParameters() && $method->getNumberOfParameters() ? $method : $override);
            $rtype = strval((!$refmember->hasReturnType() && $method->hasReturnType() ? $method : $refmember)->getReturnType());
            $rtype = $rtype ? ": $rtype" : '';

            [, $codeblock] = callable_code($override);
            $tokens = php_parse('<?php ' . $codeblock);
            array_shift($tokens);
            $parented = null;
            foreach ($tokens as $n => $token) {
                if ($token->id !== T_WHITESPACE) {
                    if ($token->id === T_STRING && $token->text === 'parent') {
                        $parented = $n;
                    }
                    elseif ($parented !== null && $token->id === T_DOUBLE_COLON) {
                        unset($tokens[$parented]);
                        $tokens[$n] = clone $tokens[$n];
                        $tokens[$n]->text = $receiver;
                    }
                    else {
                        $parented = null;
                    }
                }
            }
            $codeblock = implode('', array_column($tokens, 'text'));

            $prms = implode(', ', $params);
            $declares .= "#[\ReturnTypeWillChange]\n$modifier function $ref$name($prms)$rtype $codeblock\n";
        }

        $newclassname = "X{$classalias}Class" . md5(uniqid('RF', true));
        $implements = $implements ? 'implements ' . implode(',', $implements) : '';
        evaluate("class $newclassname extends $classname $implements\n{\nuse X{$classalias}Trait;\n$declares}", [], 10);
        return new $newclassname($spawners[$classname]['original'], $object, $fields, $methods);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_loader') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_loader'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_loader')) {
    /**
     * composer のクラスローダを返す
     *
     * かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。
     *
     * Example:
     * ```php
     * that(class_loader())->isInstanceOf(\Composer\Autoload\ClassLoader::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param ?string $startdir 高速化用の検索開始ディレクトリを指定するが、どちらかと言えばテスト用
     * @return \Composer\Autoload\ClassLoader クラスローダ
     */
    function class_loader($startdir = null)
    {
        return require auto_loader($startdir);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_map') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_map'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_map')) {
    /**
     * 指定クラスローダで読み込まれるであろう class => file を返す
     *
     * 実質的には composer で読み込まれるクラスマップを返す。
     * つまり `dump-autoload -o` したときの getClassMap 相当を返す。
     *
     * ファイル名からクラス名を逆引きする都合上、猛烈に遅いので注意。
     *
     * @package ryunosuke\Functions\Package\classobj
     */
    function class_map(
        /** @var ?\Composer\Autoload\ClassLoader オートローダオブジェクト */
        ?object $loader = null,
        /** パスが相対パスだった場合の基底ディレクトリ */
        ?string $basePath = null,
        /** キャッシュを使用するか */
        bool $cache = true,
    ): /** [class => file] の配列 */ array
    {
        $loader ??= class_loader();
        $basePath ??= dirname((new \ReflectionClass($loader))->getFileName(), 3);
        $cachekey = json_encode([spl_object_id($loader), $basePath]);
        if (!$cache) {
            cache($cachekey, null, __FUNCTION__);
        }
        return cache($cachekey, function () use ($loader, $basePath) {
            $result = [];

            // psr0+4
            foreach ([
                0 => $loader->getPrefixes() + ["" => $loader->getFallbackDirs()],
                4 => $loader->getPrefixesPsr4() + ["" => $loader->getFallbackDirsPsr4()],
            ] as $level => $psr) {
                foreach ($psr as $prefix => $dirs) {
                    foreach ($dirs as $dir) {
                        $dir = path_normalize(path_is_absolute($dir) ? $dir : "$basePath/$dir");
                        foreach (file_list($dir, ['name' => '#^[a-z_\x80-\xff][a-z0-9_\x80-\xff]*\.php$#ui']) ?? [] as $file) {
                            if ($level === 0) {
                                $class = strtr(substr($file, strlen($dir) + 1, -4), [DIRECTORY_SEPARATOR => '\\']);
                                if (!isset($result[$class]) && str_starts_with($class, $prefix)) {
                                    $result[$class] = $file;
                                }
                            }
                            elseif ($level === 4) {
                                $class = strtr($prefix . substr($file, strlen($dir) + 1, -4), [DIRECTORY_SEPARATOR => '\\']);
                                if (!isset($result[$class])) {
                                    $result[$class] = $file;
                                }
                            }
                        }
                    }
                }
            }

            // クラスファイル名が見つかったからといってクラス定義ファイルとは限らないので中身を見なければならない
            $result = array_filter($result, function ($file, $class) {
                try {
                    [$N, $C] = namespace_split($class);
                    $tokens = \PhpToken::tokenize(file_get_contents($file), TOKEN_PARSE);
                    $namespace = '';
                    $namespacing = false;
                    foreach ($tokens as $n => $token) {
                        switch (true) {
                            case $token->is(T_NAMESPACE):
                                $namespacing = true;
                                $namespace = '';
                                break;
                            case $token->is([';', '{']):
                                $namespacing = false;
                                break;
                            // namespace の文脈で T_NAME_FULLY_QUALIFIED は流れてこないが \\ がないと T_STRING で流れてくる
                            case $token->is([T_NAME_QUALIFIED, T_STRING]):
                                if ($namespacing) {
                                    $namespace .= $token->text;
                                }
                                break;
                            case $token->is([T_CLASS, T_INTERFACE, T_TRAIT, /*T_ENUM:*/]):
                                // ある程度で区切らないと無名クラス（new class() { }）や class 定数（Hoge::class）で最後まで読んでしまい、極端に遅くなる
                                // class/interface/trait/enum キーワードとクラス名が16トークンも離れてることはまずないだろう
                                for ($i = $n + 1, $l = min($n + 16, count($tokens)); $i < $l; $i++) {
                                    if ($tokens[$i]->is(T_STRING) && $namespace === $N && $tokens[$i]->is($C)) {
                                        return true;
                                    }
                                }
                                break;
                        }
                    }
                }
                catch (\ParseError) {
                    // TOKEN_PARSE で tokenize するとパースエラーが発生するが、パースエラーになるファイルでクラス定義がされるわけないのでスルーでよい
                }
                return false;
            }, ARRAY_FILTER_USE_BOTH);

            // classmap は composer が生成するかユーザーが明示的に設定するので↑のような漁る処理は必要ない
            // ただしパスの正規化は行わなければならない
            foreach ($loader->getClassMap() as $class => $file) {
                $result[$class] ??= path_normalize(path_is_absolute($file) ? $file : "$basePath/$file");
            }

            return $result;
        }, __FUNCTION__);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_namespace') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_namespace'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_namespace')) {
    /**
     * クラスの名前空間部分を取得する
     *
     * Example:
     * ```php
     * that(class_namespace('vendor\\namespace\\ClassName'))->isSame('vendor\\namespace');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $class 対象クラス・オブジェクト
     * @return string クラスの名前空間
     */
    function class_namespace($class)
    {
        if (is_object($class)) {
            $class = get_class($class);
        }

        $parts = explode('\\', $class);
        array_pop($parts);
        return ltrim(implode('\\', $parts), '\\');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_replace') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_replace'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_replace')) {
    /**
     * 既存（未読み込みに限る）クラスを強制的に置換する
     *
     * 例えば継承ツリーが下記の場合を考える。
     *
     * classA <- classB <- classC
     *
     * この場合、「classC は classB に」「classB は classA に」それぞれ依存している、と考えることができる。
     * これは静的に決定的であり、この依存を壊したり注入したりする手段は存在しない。
     * 例えば classA の実装を差し替えたいときに、いかに classA を継承した classAA を定義したとしても classB の親は classA で決して変わらない。
     *
     * この関数を使うと本当に classA そのものを弄るので、継承ツリーを下記のように変えることができる。
     *
     * classA <- classAA <- classB <- classC
     *
     * つまり、classA を継承した classAA を定義してそれを classA とみなすことが可能になる。
     * ただし、内部的には class_alias を使用して実現しているので厳密には異なるクラスとなる。
     *
     * 実際のところかなり強力な機能だが、同時にかなり黒魔術的なので乱用は控えたほうがいい。
     *
     * Example:
     * ```php
     * // Y1 extends X1 だとしてクラス定義でオーバーライドする
     * class_replace('\\ryunosuke\\Test\\Package\\files\\classes\\X1', function () {
     *     // アンスコがついたクラスが定義されるので匿名クラスを返す
     *     return new class() extends \ryunosuke\Test\Package\files\classes\X1_
     *     {
     *         function method(){return 'this is X1d';}
     *         function newmethod(){return 'this is newmethod';}
     *     };
     * });
     * // X1 を継承している Y1 にまで影響が出ている（X1 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y1())->method())->isSame('this is X1d');
     * that((new \ryunosuke\Test\Package\files\classes\Y1())->newmethod())->isSame('this is newmethod');
     *
     * // Y2 extends X2 だとしてクロージャ配列でオーバーライドする
     * class_replace('\\ryunosuke\\Test\\Package\\files\classes\\X2', fn() => [
     *     'method'    => function () {return 'this is X2d';},
     *     'newmethod' => function () {return 'this is newmethod';},
     * ]);
     * // X2 を継承している Y2 にまで影響が出ている（X2 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y2())->method())->isSame('this is X2d');
     * that((new \ryunosuke\Test\Package\files\classes\Y2())->newmethod())->isSame('this is newmethod');
     *
     * // メソッド定義だけであればクロージャではなく配列指定でも可能。さらに trait 配列を渡すとそれらを use できる
     * class_replace('\\ryunosuke\\Test\\Package\\files\classes\\X3', [
     *     [\ryunosuke\Test\Package\files\classes\XTrait::class],
     *     'method' => function () {return 'this is X3d';},
     * ]);
     * // X3 を継承している Y3 にまで影響が出ている（X3 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y3())->method())->isSame('this is X3d');
     * // トレイトのメソッドも生えている
     * that((new \ryunosuke\Test\Package\files\classes\Y3())->traitMethod())->isSame('this is XTrait::traitMethod');
     *
     * // メソッドとトレイトだけならば無名クラスを渡すことでも可能
     * class_replace('\\ryunosuke\\Test\\Package\\files\classes\\X4', new class() {
     *     use \ryunosuke\Test\Package\files\classes\XTrait;
     *     function method(){return 'this is X4d';}
     * });
     * // X4 を継承している Y4 にまで影響が出ている（X4 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y4())->method())->isSame('this is X4d');
     * // トレイトのメソッドも生えている
     * that((new \ryunosuke\Test\Package\files\classes\Y4())->traitMethod())->isSame('this is XTrait::traitMethod');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string $class 対象クラス名
     * @param \Closure|object|array $register 置換クラスを定義 or 返すクロージャ or 定義メソッド配列 or 無名クラス
     */
    function class_replace($class, $register)
    {
        $class = ltrim($class, '\\');

        // 読み込み済みクラスは置換できない（php はクラスのアンロード機能が存在しない）
        if (class_exists($class, false)) {
            throw new \DomainException("'$class' is already declared.");
        }

        // 対象クラス名をちょっとだけ変えたクラスを用意して読み込む
        $classfile = class_loader()->findFile($class);
        $fname = function_configure('cachedir') . '/' . rawurlencode(__FUNCTION__ . '-' . $class) . '.php';
        if (!file_exists($fname)) {
            $content = file_get_contents($classfile);
            $content = preg_replace("#class\\s+[a-z0-9_]+#ui", '$0_', $content);
            file_put_contents($fname, $content, LOCK_EX);
        }
        require_once $fname;

        if ($register instanceof \Closure) {
            $newclass = $register();
        }
        elseif (is_object($register)) {
            $ref = new \ReflectionObject($register);
            $newclass = [class_uses($register)];
            $trait_methods = $ref->getTraitAliases();
            foreach (class_uses($register) as $trait) {
                $trait_methods += array_flip(get_class_methods($trait));
            }
            foreach ($ref->getMethods() as $method) {
                if (!isset($trait_methods[$method->getName()])) {
                    $newclass[$method->getName()] = $method->isStatic() ? $method->getClosure() : $method->getClosure($register);
                }
            }
        }
        else {
            $newclass = $register;
        }

        // 無名クラス
        if (is_object($newclass)) {
            $newclass = get_class($newclass);
        }
        // 配列はメソッド定義のクロージャ配列とする
        if (is_array($newclass)) {
            $content = file_get_contents($fname);
            $origspace = php_parse($content, [
                'begin' => T_NAMESPACE,
                'end'   => ';',
            ]);
            array_shift($origspace);
            array_pop($origspace);

            $origclass = php_parse($content, [
                'begin'  => T_CLASS,
                'end'    => T_STRING,
                'offset' => count($origspace),
            ]);
            array_shift($origclass);

            $origspace = trim(implode('', array_column($origspace, 'text')));
            $origclass = trim(implode('', array_column($origclass, 'text')));

            $classcode = '';
            foreach ($newclass as $name => $member) {
                if (is_array($member)) {
                    foreach ($member as $trait) {
                        $classcode .= "use \\" . trim($trait, '\\') . ";\n";
                    }
                }
                else {
                    [$declare, $codeblock] = callable_code($member);
                    $parentclass = new \ReflectionClass("\\$origspace\\$origclass");
                    // 元クラスに定義されているならオーバーライドとして特殊な処理を行う
                    if ($parentclass->hasMethod($name)) {
                        /** @var \ReflectionFunctionAbstract $refmember */
                        $refmember = reflect_callable($member);
                        $refmethod = $parentclass->getMethod($name);
                        // 指定クロージャに引数が無くて、元メソッドに有るなら継承
                        if (!$refmember->getNumberOfParameters() && $refmethod->getNumberOfParameters()) {
                            $declare = 'function (' . implode(', ', function_parameter($refmethod)) . ')';
                        }
                        // 同上。返り値版
                        if (!$refmember->hasReturnType() && $refmethod->hasReturnType()) {
                            $declare .= ':' . reflect_type_resolve($refmethod->getReturnType());
                        }
                    }
                    $mname = preg_replaces('#function(\\s*)\\(#u', " $name", $declare);
                    $classcode .= "public $mname $codeblock\n";
                }
            }

            $newclass = "\\$origspace\\{$origclass}_";
            evaluate("namespace $origspace;\nclass {$origclass}_ extends {$origclass}\n{\n$classcode}");
        }

        class_alias($newclass, $class);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_shorten') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_shorten'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_shorten')) {
    /**
     * クラスの名前空間部分を除いた短い名前を取得する
     *
     * Example:
     * ```php
     * that(class_shorten('vendor\\namespace\\ClassName'))->isSame('ClassName');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $class 対象クラス・オブジェクト
     * @return string クラスの短い名前
     */
    function class_shorten($class)
    {
        if (is_object($class)) {
            $class = get_class($class);
        }

        $parts = explode('\\', $class);
        return array_pop($parts);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\class_uses_all') || (new \ReflectionFunction('ryunosuke\\ltsv\\class_uses_all'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\class_uses_all')) {
    /**
     * クラスが use しているトレイトを再帰的に取得する
     *
     * トレイトが use しているトレイトが use しているトレイトが use している・・・のような場合もすべて返す。
     *
     * Example:
     * ```php
     * trait T1{}
     * trait T2{use T1;}
     * trait T3{use T2;}
     * that(class_uses_all(new class{use T3;}))->isSame([
     *     'Example\\T3' => 'Example\\T3', // クラスが直接 use している
     *     'Example\\T2' => 'Example\\T2', // T3 が use している
     *     'Example\\T1' => 'Example\\T1', // T2 が use している
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $class
     * @param bool $autoload オートロードを呼ぶか
     * @return array トレイト名の配列
     */
    function class_uses_all($class, $autoload = true)
    {
        static $cache = [];

        $cachekey = ltrim(is_object($class) ? get_class($class) : $class, '\\');

        if (isset($cache[$cachekey])) {
            return $cache[$cachekey];
        }

        // まずはクラス階層から取得
        $traits = [];
        do {
            $traits += array_fill_keys(class_uses($class, $autoload), false);
        } while ($class = get_parent_class($class));

        // そのそれぞれのトレイトに対してさらに再帰的に探す
        // 見つかったトレイトがさらに use している可能性もあるので「増えなくなるまで」 while ループして探す必要がある
        // （まずないと思うが）再帰的に use していることもあるかもしれないのでムダを省くためにチェック済みフラグを設けてある（ただ多分不要）
        $count = count($traits);
        while (true) {
            foreach ($traits as $trait => $checked) {
                if (!$checked) {
                    $traits[$trait] = true;
                    $traits += array_fill_keys(class_uses($trait, $autoload), false);
                }
            }
            if ($count === count($traits)) {
                break;
            }
            $count = count($traits);
        }

        $names = array_keys($traits);
        return $cache[$cachekey] = array_combine($names, $names);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\const_exists') || (new \ReflectionFunction('ryunosuke\\ltsv\\const_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\const_exists')) {
    /**
     * クラス定数が存在するか調べる
     *
     * グローバル定数も調べられる。ので実質的には defined とほぼ同じで違いは下記。
     *
     * - defined は単一引数しか与えられないが、この関数は2つの引数も受け入れる
     * - defined は private const で即死するが、この関数はきちんと調べることができる
     * - ClassName::class は常に true を返す
     *
     * あくまで存在を調べるだけで実際にアクセスできるかは分からないので注意（`property_exists` と同じ）。
     *
     * Example:
     * ```php
     * // クラス定数が調べられる（1引数、2引数どちらでも良い）
     * that(const_exists('ArrayObject::STD_PROP_LIST'))->isTrue();
     * that(const_exists('ArrayObject', 'STD_PROP_LIST'))->isTrue();
     * that(const_exists('ArrayObject::UNDEFINED'))->isFalse();
     * that(const_exists('ArrayObject', 'UNDEFINED'))->isFalse();
     * // グローバル（名前空間）もいける
     * that(const_exists('PHP_VERSION'))->isTrue();
     * that(const_exists('UNDEFINED'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $classname 調べるクラス
     * @param string $constname 調べるクラス定数
     * @return bool 定数が存在するなら true
     */
    function const_exists($classname, $constname = '')
    {
        $colonp = strpos($classname, '::');
        if ($colonp === false && strlen($constname) === 0) {
            return defined($classname);
        }
        if (strlen($constname) === 0) {
            $constname = substr($classname, $colonp + 2);
            $classname = substr($classname, 0, $colonp);
        }

        try {
            $refclass = new \ReflectionClass($classname);
            if (strcasecmp($constname, 'class') === 0) {
                return true;
            }
            return $refclass->hasConstant($constname);
        }
        catch (\Throwable) {
            return false;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\namespace_detect') || (new \ReflectionFunction('ryunosuke\\ltsv\\namespace_detect'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\namespace_detect')) {
    /**
     * ディレクトリ構造から名前空間を推測して返す
     *
     * 指定パスに名前空間を持つような php ファイルが有るならその名前空間を返す。
     * 指定パスに名前空間を持つような php ファイルが無いなら親をたどる。
     * 親に名前空間を持つような php ファイルが有るならその名前空間＋ローカルパスを返す。
     *
     * 言葉で表すとややこしいが、「そのパスに配置しても違和感の無い名前空間」を返してくれるはず。
     *
     * Example:
     * ```php
     * // Example 用としてこのパッケージの Transporter を使用してみる
     * $dirname = dirname(class_loader()->findFile(\ryunosuke\Functions\Transporter::class));
     * // "$dirname/Hoge" の名前空間を推測して返す
     * that(namespace_detect("$dirname/Hoge"))->isSame("ryunosuke\\Functions\\Hoge");
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string $location 配置パス。ファイル名を与えるとそのファイルを配置すべきクラス名を返す
     * @return string 名前空間
     */
    function namespace_detect($location)
    {
        // php をパースして名前空間部分を得るクロージャ
        $detectNS = function ($phpfile) {
            $tokens = \PhpToken::tokenize(file_get_contents($phpfile));
            $count = count($tokens);

            $namespace = [];
            foreach ($tokens as $n => $token) {
                if ($token->id === T_NAMESPACE) {
                    // T_NAMESPACE と T_WHITESPACE で最低でも2つは読み飛ばしてよい
                    for ($m = $n + 2; $m < $count; $m++) {
                        if ($tokens[$m]->id === T_NAME_QUALIFIED) {
                            return $tokens[$m]->text;
                        }
                        if ($tokens[$m]->id === T_NAME_FULLY_QUALIFIED) {
                            $namespace[] = trim($tokens[$m]->text, '\\');
                        }
                        // よほどのことがないと T_NAMESPACE の次の T_STRING は名前空間の一部
                        if ($tokens[$m]->id === T_STRING) {
                            $namespace[] = $tokens[$m]->text;
                        }
                        // 終わりが来たら結合して返す
                        if ($tokens[$m]->text === ';') {
                            return implode('\\', $namespace);
                        }
                    }
                }
            }
            return null;
        };

        // 指定パスの兄弟ファイルを調べた後、親ディレクトリを辿っていく
        $basenames = [];
        return dirname_r($location, function ($directory) use ($detectNS, &$basenames) {
            foreach (array_filter(glob("$directory/*.php"), 'is_file') as $file) {
                $namespace = $detectNS($file);
                if ($namespace !== null) {
                    $localspace = implode('\\', array_reverse($basenames));
                    return rtrim($namespace . '\\' . $localspace, '\\');
                }
            }
            $basenames[] = pathinfo($directory, PATHINFO_FILENAME);
        }) ?: throw new \InvalidArgumentException('can not detect namespace. invalid output path or not specify namespace.');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\object_dive') || (new \ReflectionFunction('ryunosuke\\ltsv\\object_dive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\object_dive')) {
    /**
     * パス形式でプロパティ値を取得
     *
     * 存在しない場合は $default を返す。
     *
     * Example:
     * ```php
     * $class = (object) [
     *     'a' => (object) [
     *         'b' => (object) [
     *             'c' => 'vvv'
     *         ]
     *     ]
     * ];
     * that(object_dive($class, 'a.b.c'))->isSame('vvv');
     * that(object_dive($class, 'a.b.x', 9))->isSame(9);
     * // 配列を与えても良い。その場合 $delimiter 引数は意味をなさない
     * that(object_dive($class, ['a', 'b', 'c']))->isSame('vvv');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param object $object 調べるオブジェクト
     * @param string|array $path パス文字列。配列も与えられる
     * @param mixed $default 無かった場合のデフォルト値
     * @param string $delimiter パスの区切り文字。大抵は '.' か '/'
     * @return mixed パスが示すプロパティ値
     */
    function object_dive($object, $path, $default = null, $delimiter = '.')
    {
        $keys = is_array($path) ? $path : explode($delimiter, $path);
        foreach ($keys as $key) {
            if (!isset($object->$key)) {
                return $default;
            }
            $object = $object->$key;
        }
        return $object;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\object_id') || (new \ReflectionFunction('ryunosuke\\ltsv\\object_id'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\object_id')) {
    /**
     * 重複しない spl_object_id
     *
     * 内部でオブジェクト自体は保持しない。
     * つまり、そのオブジェクトは GC の対象になる。
     *
     * オブジェクトを与えると一意な整数を返す。
     * 内部で連番を保持するので PHP_INT_MAX まで生成できる。
     * PHP_INT_MAX を超えた場合の挙動は未定義（まぁまずありえないだろう）。
     * null は特別扱いとして必ず 0 を返す。
     *
     * 逆に整数を与えると対応したオブジェクトを返す。
     * 設定していないか既に GC されている場合は null を返す。
     * 0 は特別扱いとして必ず null を返す。
     *
     * Example:
     * ```php
     * // spl_object_id は容易に重複するが・・・
     * that(spl_object_id(new \stdClass()) === spl_object_id(new \stdClass()))->isTrue();
     * // この object_id 関数は重複しない
     * that(object_id(new \stdClass()) === object_id(new \stdClass()))->isFalse();
     *
     * $o = new \stdClass();
     * // オブジェクトを与えると固有IDを返す
     * that($id = object_id($o))->isInt();
     * // そのIDを与えると元のオブジェクトが得られる
     * that($o === object_id($id))->isTrue();
     * // 参照を握っているわけではないので GC されていると null を返す
     * unset($o);
     * that(null === object_id($id))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param null|object|int $objectOrId 対象オブジェクト or オブジェクトID
     * @return null|int|object オブジェクトID or 対象オブジェクト
     */
    function object_id($objectOrId)
    {
        if (is_string($objectOrId) && ctype_digit($objectOrId)) {
            $objectOrId = (int) $objectOrId;
        }

        assert(is_null($objectOrId) || is_object($objectOrId) || is_int($objectOrId));

        if ($objectOrId === null) {
            return 0;
        }
        if ($objectOrId === 0) {
            return null;
        }

        /** @var array<\WeakReference> $idmap */
        static $idmap = [];

        if (is_int($objectOrId)) {
            if (!isset($idmap[$objectOrId])) {
                return null;
            }
            $result = $idmap[$objectOrId]->get();
            if ($result === null) {
                unset($idmap[$objectOrId]);
            }
            return $result;
        }

        static $lastid = 0;
        static $references = null;
        $references ??= new \WeakMap();

        $references[$objectOrId] ??= [\WeakReference::create($objectOrId), ++$lastid];
        $idmap[$references[$objectOrId][1]] = $references[$objectOrId][0];
        return $references[$objectOrId][1];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\object_properties') || (new \ReflectionFunction('ryunosuke\\ltsv\\object_properties'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\object_properties')) {
    /**
     * オブジェクトのプロパティを可視・不可視を問わず取得する
     *
     * get_object_vars + no public プロパティを返すイメージ。
     * クロージャだけは特別扱いで this + use 変数を返す。
     *
     * Example:
     * ```php
     * $object = new #[\AllowDynamicProperties] class('something', 42) extends \Exception{};
     * $object->oreore = 'oreore';
     *
     * // get_object_vars はそのスコープから見えないプロパティを取得できない
     * // var_dump(get_object_vars($object));
     *
     * // array キャストは全て得られるが null 文字を含むので扱いにくい
     * // var_dump((array) $object);
     *
     * // この関数を使えば不可視プロパティも取得できる
     * that(object_properties($object))->subsetEquals([
     *     'message' => 'something',
     *     'code'    => 42,
     *     'oreore'  => 'oreore',
     * ]);
     *
     * // クロージャは this と use 変数を返す
     * that(object_properties(fn() => $object))->is([
     *     'this'   => $this,
     *     'object' => $object,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param object $object オブジェクト
     * @param array $privates 継承ツリー上の private が格納される
     * @return array 全プロパティの配列
     */
    function object_properties($object, &$privates = [])
    {
        if ($object instanceof \Closure) {
            $ref = new \ReflectionFunction($object);
            $uses = method_exists($ref, 'getClosureUsedVariables') ? $ref->getClosureUsedVariables() : $ref->getStaticVariables();
            return ['this' => $ref->getClosureThis()] + $uses;
        }

        $fields = [];
        foreach ((array) $object as $name => $field) {
            $cname = '';
            $names = explode("\0", $name);
            if (count($names) > 1) {
                $name = array_pop($names);
                $cname = $names[1];
            }
            $fields[$cname][$name] = $field;
        }

        $classname = get_class($object);
        $parents = array_values(['', '*', $classname] + class_parents($object));
        uksort($fields, function ($a, $b) use ($parents) {
            return array_search($a, $parents, true) <=> array_search($b, $parents, true);
        });

        $result = [];
        foreach ($fields as $cname => $props) {
            foreach ($props as $name => $field) {
                if ($cname !== '' && $cname !== '*' && $classname !== $cname) {
                    $privates[$cname][$name] = $field;
                }
                if (!array_key_exists($name, $result)) {
                    $result[$name] = $field;
                }
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\object_storage') || (new \ReflectionFunction('ryunosuke\\ltsv\\object_storage'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\object_storage')) {
    /**
     * オブジェクトに付加データを付与する
     *
     * 実質的に WeakMap と同じ。
     * ただし php 内部では本来オブジェクトであるべきものもリソースとして扱われる（curl とか）ので統一のためにリソースも扱える。
     *
     * 典型的な利用法として「クロージャに値を持たせたい」がある。
     * クロージャに限らず、大抵の内部オブジェクトは動的プロパティを生やせないので、値の保持がめんどくさい。
     * （spl_object_id は重複するので使えないし、下手に実装すると参照が握られて GC されない羽目になる）。
     *
     * Example:
     * ```php
     * $storage = object_storage('test');
     * $closure = fn() => 123;
     * $resource = tmpfile();
     *
     * // このように set すると・・・
     * $storage->set($closure, 'attached data1');
     * // get で取り出せる
     * that($storage->get($closure))->isSame('attached data1');
     * // リソースも扱える
     * $storage->set($resource, 'attached data2');
     * that($storage->get($resource))->isSame('attached data2');
     *
     * // 名前空間が同じならインスタンスをまたいで取得できる
     * $storage2 = object_storage('test');
     * that($storage2->get($closure))->isSame('attached data1');
     *
     * // オブジェクトが死ぬと同時に消える
     * unset($closure);
     * that($storage2->count())->isSame(1);
     * // リソースの場合は close でも消える
     * fclose($resource);
     * that($storage2->count())->isSame(0);
     * that($storage2->get($resource))->is(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string $namespace 名前空間
     * @return \ObjectStorage|object ストレージオブジェクト
     */
    function object_storage($namespace = 'global')
    {
        static $storages = [];
        return $storages[$namespace] ??= new class() implements \Countable, \ArrayAccess, \IteratorAggregate {
            private iterable $objects;
            private iterable $resources;

            public function __construct()
            {
                $this->objects = new \WeakMap();
                $this->resources = [];
            }

            private function typeid($objectOrResource)
            {
                if (is_object($objectOrResource)) {
                    return ['objects', $objectOrResource];
                }
                if (is_resourcable($objectOrResource)) {
                    return ['resources', (int) $objectOrResource];
                }
                throw new \InvalidArgumentException('supports only object or resource');
            }

            private function gc()
            {
                // WeakMap と言えど循環参照が残っているかもしれないので呼んでおく
                gc_collect_cycles();

                // 参照が切れたり閉じてるリソースを消す
                if ($this->resources) {
                    $resources = get_resources();
                    foreach ($this->resources as $id => $data) {
                        // 参照が切れてるのは get_resources に現れない、閉じてるのは現れるが gettype しないと判断できない
                        if (!isset($resources[$id]) || strpos(gettype($resources[$id]), 'closed') !== false) {
                            unset($this->resources[$id]);
                        }
                    }
                }
            }

            public function has($objectOrResource): bool
            {
                return $this->offsetExists($objectOrResource);
            }

            public function get($objectOrResource, $default = null): mixed
            {
                if ($this->has($objectOrResource)) {
                    return $this->offsetGet($objectOrResource);
                }
                return $default;
            }

            public function set($objectOrResource, $data): self
            {
                $this->offsetSet($objectOrResource, $data);
                return $this;
            }

            public function clear(): bool
            {
                // 型が違ったりでめんどくさいので横着している
                $this->__construct();

                gc_collect_cycles();
                return true;
            }

            public function offsetExists($offset): bool
            {
                $this->gc();

                [$type, $id] = $this->typeid($offset);
                return isset($this->$type[$id]);
            }

            public function offsetGet($offset): mixed
            {
                [$type, $id] = $this->typeid($offset);
                return $this->$type[$id];
            }

            public function offsetSet($offset, $value): void
            {
                [$type, $id] = $this->typeid($offset);
                $this->$type[$id] = $value;
            }

            public function offsetUnset($offset): void
            {
                [$type, $id] = $this->typeid($offset);
                unset($this->$type[$id]);
            }

            public function count(): int
            {
                $this->gc();

                return count($this->objects) + count($this->resources);
            }

            public function getIterator(): \Generator
            {
                $this->gc();

                // WeakMap はキーとしてオブジェクトを返すのでそれに合わせる（ID を返されても意味がないし）

                foreach ($this->objects as $id => $data) {
                    yield is_int($id) ? object_id($id) : $id => $data;
                }

                $resources = get_resources();
                foreach ($this->resources as $id => $data) {
                    yield $resources[$id] => $data;
                }
            }
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\register_autoload_function') || (new \ReflectionFunction('ryunosuke\\ltsv\\register_autoload_function'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\register_autoload_function')) {
    /**
     * オートロード前後にコールバックする
     *
     * before を使って「クラスを読み込み前に動的に書き換える」のようなことが可能になる。
     * after を使って「`__initialize` を呼ぶ」のような規約を定めればスタティックイニシャライザのようなことが可能になる。
     *
     * prepend なオートローダで実装してあるので、その後のさらに prepend されたようなオートローダでの読み込みは感知できない。
     * もちろんロード済みクラスも感知できない。
     *
     * before 内で無条件にクラスを呼ぶと無限ループになるので注意（オートローダが呼ばれて before が呼ばれてオートローダが呼ばれて before が呼ばれて・・・）。
     *
     * ローダーオブジェクトを返すが特に意味はなく、使うべきではない。
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param ?callable $before 読み込み前コールバック
     * @param ?callable $after 読み込み後コールバック
     * @return object ローダーオブジェクト
     */
    function register_autoload_function($before = null, $after = null)
    {
        static $loader = null;
        $loader ??= new class() {
            public $befores = [];
            public $afters  = [];

            private $loading = false;

            public function __invoke($classname)
            {
                if (!$this->loading) {
                    $this->loading = true;
                    // file スキームをこの瞬間だけ上書きして require/include をフックする
                    $include_stream = include_stream()->register(function ($filename) use ($classname) {
                        $contents = null;
                        foreach ($this->befores as $before) {
                            $contents = $before($classname, $filename, $contents);
                        }
                        return $contents ?? file_get_contents($filename);
                    });
                    try {
                        $autoloaders = spl_autoload_functions();
                        foreach ($autoloaders as $autoloader) {
                            if ($autoloader !== $this) {
                                // ここで require/include が走れば↑の before がコールされる
                                $autoloader($classname);
                                if (type_exists($classname, false)) {
                                    break;
                                }
                            }
                        }

                    }
                    finally {
                        // file スキームの上書きは影響範囲が大きいので必ず元に戻す
                        $include_stream->restore();
                        $this->loading = false;
                    }
                }
                if (type_exists($classname, false)) {
                    // ロードができたら after をコールする
                    foreach ($this->afters as $after) {
                        $after($classname);
                    }
                }
            }
        };
        if ($before) {
            $loader->befores[] = $before;
        }
        if ($after) {
            $loader->afters[] = $after;
        }

        spl_autoload_unregister($loader);
        spl_autoload_register($loader, true, true);

        return $loader;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\type_exists') || (new \ReflectionFunction('ryunosuke\\ltsv\\type_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\type_exists')) {
    /**
     * 型が存在するか返す
     *
     * class/interface/trait/enum exists の合せ技。
     * trait/enum のように今後型的なものがさらに増えるかもしれないし、class_exists だけして interface/trait が抜けているコードを何度も見てきた。
     * それを一元管理するような関数となる。
     *
     * Example:
     * ```php
     * that(class_exists(\Throwable::class))->isFalse();     // class_exists は class にしか反応しない
     * that(interface_exists(\Exception::class))->isFalse(); // interface_exists は interface にしか反応しない
     * that(trait_exists(\Error::class))->isFalse();         // trait_exists は trait にしか反応しない
     * // type_exists であれば全てに反応する
     * that(type_exists(\Throwable::class))->isTrue();
     * that(type_exists(\Exception::class))->isTrue();
     * that(type_exists(\Error::class))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string $typename 調べる型名
     * @param bool $autoload オートロードを行うか
     * @return bool 型が存在するなら true
     */
    function type_exists($typename, $autoload = true)
    {
        if (class_exists($typename, $autoload)) {
            return true;
        }
        if (interface_exists($typename, $autoload)) {
            return true;
        }
        if (trait_exists($typename, $autoload)) {
            return true;
        }
        // enum は class で実装されているので enum_exists は不要
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\sql_bind') || (new \ReflectionFunction('ryunosuke\\ltsv\\sql_bind'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\sql_bind')) {
    /**
     * ものすごく雑に SQL に値を埋め込む
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた SQL を**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * プレースホルダは ? か :alnum で混在していても良い。
     *
     * Example:
     * ```php
     * that(sql_bind('select ?', 1))->isSame("select 1");
     * that(sql_bind('select :hoge', ['hoge' => 'hoge']))->isSame("select 'hoge'");
     * that(sql_bind('select ?, :hoge', [1, 'hoge' => 'hoge']))->isSame("select 1, 'hoge'");
     * ```
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param string $sql 値を埋め込む SQL
     * @param array|mixed $values 埋め込む値
     * @param ?callable $quote 値をクォートするクロージャ
     * @return mixed 値が埋め込まれた SQL
     */
    function sql_bind($sql, $values, $quote = null)
    {
        $quote ??= fn($v) => sql_quote($v);

        $embed = [];
        foreach (arrayval($values, false) as $k => $v) {
            if (is_int($k)) {
                $embed['?'][] = $quote($v);
            }
            else {
                $embed[":$k"] = $quote($v);
            }
        }

        return str_embed($sql, $embed, [
            "'"   => "'",
            '"'   => '"',
            '-- ' => "\n",
            '/*'  => "*/",
        ]);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\sql_format') || (new \ReflectionFunction('ryunosuke\\ltsv\\sql_format'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\sql_format')) {
    /**
     * ものすごく雑に SQL を整形する
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた SQL を**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * JOIN 句は FROM 句とみなさず、別句として処理する。
     * AND と && は微妙に処理が異なる。 AND は改行されるが && は改行されない（OR と || も同様）。
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param string $sql 整形する SQL
     * @param array $options 整形オプション
     * @return string 整形された SQL
     */
    function sql_format($sql, $options = [])
    {
        static $keywords = [
            'ACCESSIBLE'                 => true,
            'ACTION'                     => true,
            'ADD'                        => true,
            'AFTER'                      => true,
            'AGAINST'                    => true,
            'AGGREGATE'                  => true,
            'ALGORITHM'                  => true,
            'ALL'                        => true,
            'ALTER'                      => true,
            'ALTER TABLE'                => true,
            'ANALYSE'                    => true,
            'ANALYZE'                    => true,
            'AND'                        => true,
            'AS'                         => true,
            'ASC'                        => true,
            'AUTOCOMMIT'                 => true,
            'AUTO_INCREMENT'             => true,
            'BACKUP'                     => true,
            'BEGIN'                      => true,
            'BETWEEN'                    => true,
            'BINLOG'                     => true,
            'BOTH'                       => true,
            'CASCADE'                    => true,
            'CASE'                       => true,
            'CHANGE'                     => true,
            'CHANGED'                    => true,
            'CHARACTER SET'              => true,
            'CHARSET'                    => true,
            'CHECK'                      => true,
            'CHECKSUM'                   => true,
            'COLLATE'                    => true,
            'COLLATION'                  => true,
            'COLUMN'                     => true,
            'COLUMNS'                    => true,
            'COMMENT'                    => true,
            'COMMIT'                     => true,
            'COMMITTED'                  => true,
            'COMPRESSED'                 => true,
            'CONCURRENT'                 => true,
            'CONSTRAINT'                 => true,
            'CONTAINS'                   => true,
            'CONVERT'                    => true,
            'CREATE'                     => true,
            'CROSS'                      => true,
            'CURRENT_TIMESTAMP'          => true,
            'DATABASE'                   => true,
            'DATABASES'                  => true,
            'DAY'                        => true,
            'DAY_HOUR'                   => true,
            'DAY_MINUTE'                 => true,
            'DAY_SECOND'                 => true,
            'DEFAULT'                    => true,
            'DEFINER'                    => true,
            'DELAYED'                    => true,
            'DELETE'                     => true,
            'DELETE FROM'                => true,
            'DESC'                       => true,
            'DESCRIBE'                   => true,
            'DETERMINISTIC'              => true,
            'DISTINCT'                   => true,
            'DISTINCTROW'                => true,
            'DIV'                        => true,
            'DO'                         => true,
            'DROP'                       => true,
            'DUMPFILE'                   => true,
            'DUPLICATE'                  => true,
            'DYNAMIC'                    => true,
            'ELSE'                       => true,
            'ENCLOSED'                   => true,
            'END'                        => true,
            'ENGINE'                     => true,
            'ENGINES'                    => true,
            'ENGINE_TYPE'                => true,
            'ESCAPE'                     => true,
            'ESCAPED'                    => true,
            'EVENTS'                     => true,
            'EXCEPT'                     => true,
            'EXECUTE'                    => true,
            'EXISTS'                     => true,
            'EXPLAIN'                    => true,
            'EXTENDED'                   => true,
            'FAST'                       => true,
            'FIELDS'                     => true,
            'FILE'                       => true,
            'FIRST'                      => true,
            'FIXED'                      => true,
            'FLUSH'                      => true,
            'FOR'                        => true,
            'FORCE'                      => true,
            'FOREIGN'                    => true,
            'FROM'                       => true,
            'FULL'                       => true,
            'FULLTEXT'                   => true,
            'FUNCTION'                   => true,
            'GLOBAL'                     => true,
            'GRANT'                      => true,
            'GRANTS'                     => true,
            'GROUP'                      => true,
            'GROUP_CONCAT'               => true,
            'HAVING'                     => true,
            'HEAP'                       => true,
            'HIGH_PRIORITY'              => true,
            'HOSTS'                      => true,
            'HOUR'                       => true,
            'HOUR_MINUTE'                => true,
            'HOUR_SECOND'                => true,
            'IDENTIFIED'                 => true,
            'IF'                         => true,
            'IFNULL'                     => true,
            'IGNORE'                     => true,
            'IN'                         => true,
            'INDEX'                      => true,
            'INDEXES'                    => true,
            'INFILE'                     => true,
            'INNER'                      => true,
            'INSERT'                     => true,
            'INSERT_ID'                  => true,
            'INSERT_METHOD'              => true,
            'INTERSECT'                  => true,
            'INTERVAL'                   => true,
            'INTO'                       => true,
            'INVOKER'                    => true,
            'IS'                         => true,
            'ISOLATION'                  => true,
            'JOIN'                       => true,
            'JSON_ARRAY'                 => true,
            'JSON_ARRAY_APPEND'          => true,
            'JSON_ARRAY_INSERT'          => true,
            'JSON_CONTAINS'              => true,
            'JSON_CONTAINS_PATH'         => true,
            'JSON_DEPTH'                 => true,
            'JSON_EXTRACT'               => true,
            'JSON_INSERT'                => true,
            'JSON_KEYS'                  => true,
            'JSON_LENGTH'                => true,
            'JSON_MERGE_PATCH'           => true,
            'JSON_MERGE_PRESERVE'        => true,
            'JSON_OBJECT'                => true,
            'JSON_PRETTY'                => true,
            'JSON_QUOTE'                 => true,
            'JSON_REMOVE'                => true,
            'JSON_REPLACE'               => true,
            'JSON_SEARCH'                => true,
            'JSON_SET'                   => true,
            'JSON_STORAGE_SIZE'          => true,
            'JSON_TYPE'                  => true,
            'JSON_UNQUOTE'               => true,
            'JSON_VALID'                 => true,
            'KEY'                        => true,
            'KEYS'                       => true,
            'KILL'                       => true,
            'LAST_INSERT_ID'             => true,
            'LEADING'                    => true,
            'LEFT'                       => true,
            'LEVEL'                      => true,
            'LIKE'                       => true,
            'LIMIT'                      => true,
            'LINEAR'                     => true,
            'LINES'                      => true,
            'LOAD'                       => true,
            'LOCAL'                      => true,
            'LOCK'                       => true,
            'LOCKS'                      => true,
            'LOGS'                       => true,
            'LOW_PRIORITY'               => true,
            'MARIA'                      => true,
            'MASTER'                     => true,
            'MASTER_CONNECT_RETRY'       => true,
            'MASTER_HOST'                => true,
            'MASTER_LOG_FILE'            => true,
            'MATCH'                      => true,
            'MAX_CONNECTIONS_PER_HOUR'   => true,
            'MAX_QUERIES_PER_HOUR'       => true,
            'MAX_ROWS'                   => true,
            'MAX_UPDATES_PER_HOUR'       => true,
            'MAX_USER_CONNECTIONS'       => true,
            'MEDIUM'                     => true,
            'MERGE'                      => true,
            'MINUTE'                     => true,
            'MINUTE_SECOND'              => true,
            'MIN_ROWS'                   => true,
            'MODE'                       => true,
            'MODIFY'                     => true,
            'MONTH'                      => true,
            'MRG_MYISAM'                 => true,
            'MYISAM'                     => true,
            'NAMES'                      => true,
            'NATURAL'                    => true,
            'NOT'                        => true,
            'NOW()'                      => true,
            'NULL'                       => true,
            'OFFSET'                     => true,
            'ON'                         => true,
            'ON DELETE'                  => true,
            'ON UPDATE'                  => true,
            'OPEN'                       => true,
            'OPTIMIZE'                   => true,
            'OPTION'                     => true,
            'OPTIONALLY'                 => true,
            'OR'                         => true,
            'ORDER'                      => true,
            'BY'                         => true,
            'OUTER'                      => true,
            'OUTFILE'                    => true,
            'PACK_KEYS'                  => true,
            'PAGE'                       => true,
            'PARTIAL'                    => true,
            'PARTITION'                  => true,
            'PARTITIONS'                 => true,
            'PASSWORD'                   => true,
            'PRIMARY'                    => true,
            'PRIVILEGES'                 => true,
            'PROCEDURE'                  => true,
            'PROCESS'                    => true,
            'PROCESSLIST'                => true,
            'PURGE'                      => true,
            'QUICK'                      => true,
            'RAID0'                      => true,
            'RAID_CHUNKS'                => true,
            'RAID_CHUNKSIZE'             => true,
            'RAID_TYPE'                  => true,
            'RANGE'                      => true,
            'READ'                       => true,
            'READ_ONLY'                  => true,
            'READ_WRITE'                 => true,
            'REFERENCES'                 => true,
            'REGEXP'                     => true,
            'RELOAD'                     => true,
            'RENAME'                     => true,
            'REPAIR'                     => true,
            'REPEATABLE'                 => true,
            'REPLACE'                    => true,
            'REPLICATION'                => true,
            'RESET'                      => true,
            'RESTORE'                    => true,
            'RESTRICT'                   => true,
            'RETURN'                     => true,
            'RETURNS'                    => true,
            'REVOKE'                     => true,
            'RIGHT'                      => true,
            'RLIKE'                      => true,
            'ROLLBACK'                   => true,
            'ROLLUP'                     => true,
            'ROW'                        => true,
            'ROWS'                       => true,
            'ROW_FORMAT'                 => true,
            'SECOND'                     => true,
            'SECURITY'                   => true,
            'SELECT'                     => true,
            'SEPARATOR'                  => true,
            'SERIALIZABLE'               => true,
            'SESSION'                    => true,
            'SET'                        => true,
            'SHARE'                      => true,
            'SHOW'                       => true,
            'SHUTDOWN'                   => true,
            'SLAVE'                      => true,
            'SONAME'                     => true,
            'SOUNDS'                     => true,
            'SQL'                        => true,
            'SQL_AUTO_IS_NULL'           => true,
            'SQL_BIG_RESULT'             => true,
            'SQL_BIG_SELECTS'            => true,
            'SQL_BIG_TABLES'             => true,
            'SQL_BUFFER_RESULT'          => true,
            'SQL_CACHE'                  => true,
            'SQL_CALC_FOUND_ROWS'        => true,
            'SQL_LOG_BIN'                => true,
            'SQL_LOG_OFF'                => true,
            'SQL_LOG_UPDATE'             => true,
            'SQL_LOW_PRIORITY_UPDATES'   => true,
            'SQL_MAX_JOIN_SIZE'          => true,
            'SQL_NO_CACHE'               => true,
            'SQL_QUOTE_SHOW_CREATE'      => true,
            'SQL_SAFE_UPDATES'           => true,
            'SQL_SELECT_LIMIT'           => true,
            'SQL_SLAVE_SKIP_COUNTER'     => true,
            'SQL_SMALL_RESULT'           => true,
            'SQL_WARNINGS'               => true,
            'START'                      => true,
            'STARTING'                   => true,
            'STATUS'                     => true,
            'STOP'                       => true,
            'STORAGE'                    => true,
            'STRAIGHT_JOIN'              => true,
            'STRING'                     => true,
            'STRIPED'                    => true,
            'SUPER'                      => true,
            'TABLE'                      => true,
            'TABLES'                     => true,
            'TEMPORARY'                  => true,
            'TERMINATED'                 => true,
            'THEN'                       => true,
            'TO'                         => true,
            'TRAILING'                   => true,
            'TRANSACTIONAL'              => true,
            'TRUE'                       => true,
            'TRUNCATE'                   => true,
            'TYPE'                       => true,
            'TYPES'                      => true,
            'UNCOMMITTED'                => true,
            'UNION'                      => true,
            'UNION ALL'                  => true,
            'UNIQUE'                     => true,
            'UNLOCK'                     => true,
            'UNSIGNED'                   => true,
            'UPDATE'                     => true,
            'USAGE'                      => true,
            'USE'                        => true,
            'USING'                      => true,
            'VALUES'                     => true,
            'VARIABLES'                  => true,
            'VIEW'                       => true,
            'WHEN'                       => true,
            'WHERE'                      => true,
            'WITH'                       => true,
            'WORK'                       => true,
            'WRITE'                      => true,
            'XOR'                        => true,
            'YEAR_MONTH'                 => true,
            'ABS'                        => true,
            'ACOS'                       => true,
            'ADDDATE'                    => true,
            'ADDTIME'                    => true,
            'AES_DECRYPT'                => true,
            'AES_ENCRYPT'                => true,
            'AREA'                       => true,
            'ASBINARY'                   => true,
            'ASCII'                      => true,
            'ASIN'                       => true,
            'ASTEXT'                     => true,
            'ATAN'                       => true,
            'ATAN2'                      => true,
            'AVG'                        => true,
            'BDMPOLYFROMTEXT'            => true,
            'BDMPOLYFROMWKB'             => true,
            'BDPOLYFROMTEXT'             => true,
            'BDPOLYFROMWKB'              => true,
            'BENCHMARK'                  => true,
            'BIN'                        => true,
            'BIT_AND'                    => true,
            'BIT_COUNT'                  => true,
            'BIT_LENGTH'                 => true,
            'BIT_OR'                     => true,
            'BIT_XOR'                    => true,
            'BOUNDARY'                   => true,
            'BUFFER'                     => true,
            'CAST'                       => true,
            'CEIL'                       => true,
            'CEILING'                    => true,
            'CENTROID'                   => true,
            'CHAR'                       => true,
            'CHARACTER_LENGTH'           => true,
            'CHAR_LENGTH'                => true,
            'COALESCE'                   => true,
            'COERCIBILITY'               => true,
            'COMPRESS'                   => true,
            'CONCAT'                     => true,
            'CONCAT_WS'                  => true,
            'CONNECTION_ID'              => true,
            'CONV'                       => true,
            'CONVERT_TZ'                 => true,
            'CONVEXHULL'                 => true,
            'COS'                        => true,
            'COT'                        => true,
            'COUNT'                      => true,
            'CRC32'                      => true,
            'CROSSES'                    => true,
            'CURDATE'                    => true,
            'CURRENT_DATE'               => true,
            'CURRENT_TIME'               => true,
            'CURRENT_USER'               => true,
            'CURTIME'                    => true,
            'DATE'                       => true,
            'DATEDIFF'                   => true,
            'DATE_ADD'                   => true,
            'DATE_DIFF'                  => true,
            'DATE_FORMAT'                => true,
            'DATE_SUB'                   => true,
            'DAYNAME'                    => true,
            'DAYOFMONTH'                 => true,
            'DAYOFWEEK'                  => true,
            'DAYOFYEAR'                  => true,
            'DECODE'                     => true,
            'DEGREES'                    => true,
            'DES_DECRYPT'                => true,
            'DES_ENCRYPT'                => true,
            'DIFFERENCE'                 => true,
            'DIMENSION'                  => true,
            'DISJOINT'                   => true,
            'DISTANCE'                   => true,
            'ELT'                        => true,
            'ENCODE'                     => true,
            'ENCRYPT'                    => true,
            'ENDPOINT'                   => true,
            'ENVELOPE'                   => true,
            'EQUALS'                     => true,
            'EXP'                        => true,
            'EXPORT_SET'                 => true,
            'EXTERIORRING'               => true,
            'EXTRACT'                    => true,
            'EXTRACTVALUE'               => true,
            'FIELD'                      => true,
            'FIND_IN_SET'                => true,
            'FLOOR'                      => true,
            'FORMAT'                     => true,
            'FOUND_ROWS'                 => true,
            'FROM_DAYS'                  => true,
            'FROM_UNIXTIME'              => true,
            'GEOMCOLLFROMTEXT'           => true,
            'GEOMCOLLFROMWKB'            => true,
            'GEOMETRYCOLLECTION'         => true,
            'GEOMETRYCOLLECTIONFROMTEXT' => true,
            'GEOMETRYCOLLECTIONFROMWKB'  => true,
            'GEOMETRYFROMTEXT'           => true,
            'GEOMETRYFROMWKB'            => true,
            'GEOMETRYN'                  => true,
            'GEOMETRYTYPE'               => true,
            'GEOMFROMTEXT'               => true,
            'GEOMFROMWKB'                => true,
            'GET_FORMAT'                 => true,
            'GET_LOCK'                   => true,
            'GLENGTH'                    => true,
            'GREATEST'                   => true,
            'GROUP_UNIQUE_USERS'         => true,
            'HEX'                        => true,
            'INET_ATON'                  => true,
            'INET_NTOA'                  => true,
            'INSTR'                      => true,
            'INTERIORRINGN'              => true,
            'INTERSECTION'               => true,
            'INTERSECTS'                 => true,
            'ISCLOSED'                   => true,
            'ISEMPTY'                    => true,
            'ISNULL'                     => true,
            'ISRING'                     => true,
            'ISSIMPLE'                   => true,
            'IS_FREE_LOCK'               => true,
            'IS_USED_LOCK'               => true,
            'LAST_DAY'                   => true,
            'LCASE'                      => true,
            'LEAST'                      => true,
            'LENGTH'                     => true,
            'LINEFROMTEXT'               => true,
            'LINEFROMWKB'                => true,
            'LINESTRING'                 => true,
            'LINESTRINGFROMTEXT'         => true,
            'LINESTRINGFROMWKB'          => true,
            'LN'                         => true,
            'LOAD_FILE'                  => true,
            'LOCALTIME'                  => true,
            'LOCALTIMESTAMP'             => true,
            'LOCATE'                     => true,
            'LOG'                        => true,
            'LOG10'                      => true,
            'LOG2'                       => true,
            'LOWER'                      => true,
            'LPAD'                       => true,
            'LTRIM'                      => true,
            'MAKEDATE'                   => true,
            'MAKETIME'                   => true,
            'MAKE_SET'                   => true,
            'MASTER_POS_WAIT'            => true,
            'MAX'                        => true,
            'MBRCONTAINS'                => true,
            'MBRDISJOINT'                => true,
            'MBREQUAL'                   => true,
            'MBRINTERSECTS'              => true,
            'MBROVERLAPS'                => true,
            'MBRTOUCHES'                 => true,
            'MBRWITHIN'                  => true,
            'MD5'                        => true,
            'MICROSECOND'                => true,
            'MID'                        => true,
            'MIN'                        => true,
            'MLINEFROMTEXT'              => true,
            'MLINEFROMWKB'               => true,
            'MOD'                        => true,
            'MONTHNAME'                  => true,
            'MPOINTFROMTEXT'             => true,
            'MPOINTFROMWKB'              => true,
            'MPOLYFROMTEXT'              => true,
            'MPOLYFROMWKB'               => true,
            'MULTILINESTRING'            => true,
            'MULTILINESTRINGFROMTEXT'    => true,
            'MULTILINESTRINGFROMWKB'     => true,
            'MULTIPOINT'                 => true,
            'MULTIPOINTFROMTEXT'         => true,
            'MULTIPOINTFROMWKB'          => true,
            'MULTIPOLYGON'               => true,
            'MULTIPOLYGONFROMTEXT'       => true,
            'MULTIPOLYGONFROMWKB'        => true,
            'NAME_CONST'                 => true,
            'NULLIF'                     => true,
            'NUMGEOMETRIES'              => true,
            'NUMINTERIORRINGS'           => true,
            'NUMPOINTS'                  => true,
            'OCT'                        => true,
            'OCTET_LENGTH'               => true,
            'OLD_PASSWORD'               => true,
            'ORD'                        => true,
            'OVERLAPS'                   => true,
            'PERIOD_ADD'                 => true,
            'PERIOD_DIFF'                => true,
            'PI'                         => true,
            'POINT'                      => true,
            'POINTFROMTEXT'              => true,
            'POINTFROMWKB'               => true,
            'POINTN'                     => true,
            'POINTONSURFACE'             => true,
            'POLYFROMTEXT'               => true,
            'POLYFROMWKB'                => true,
            'POLYGON'                    => true,
            'POLYGONFROMTEXT'            => true,
            'POLYGONFROMWKB'             => true,
            'POSITION'                   => true,
            'POW'                        => true,
            'POWER'                      => true,
            'QUARTER'                    => true,
            'QUOTE'                      => true,
            'RADIANS'                    => true,
            'RAND'                       => true,
            'RELATED'                    => true,
            'RELEASE_LOCK'               => true,
            'REPEAT'                     => true,
            'REVERSE'                    => true,
            'ROUND'                      => true,
            'ROW_COUNT'                  => true,
            'RPAD'                       => true,
            'RTRIM'                      => true,
            'SCHEMA'                     => true,
            'SEC_TO_TIME'                => true,
            'SESSION_USER'               => true,
            'SHA'                        => true,
            'SHA1'                       => true,
            'SIGN'                       => true,
            'SIN'                        => true,
            'SLEEP'                      => true,
            'SOUNDEX'                    => true,
            'SPACE'                      => true,
            'SQRT'                       => true,
            'SRID'                       => true,
            'STARTPOINT'                 => true,
            'STD'                        => true,
            'STDDEV'                     => true,
            'STDDEV_POP'                 => true,
            'STDDEV_SAMP'                => true,
            'STRCMP'                     => true,
            'STR_TO_DATE'                => true,
            'SUBDATE'                    => true,
            'SUBSTR'                     => true,
            'SUBSTRING'                  => true,
            'SUBSTRING_INDEX'            => true,
            'SUBTIME'                    => true,
            'SUM'                        => true,
            'SYMDIFFERENCE'              => true,
            'SYSDATE'                    => true,
            'SYSTEM_USER'                => true,
            'TAN'                        => true,
            'TIME'                       => true,
            'TIMEDIFF'                   => true,
            'TIMESTAMP'                  => true,
            'TIMESTAMPADD'               => true,
            'TIMESTAMPDIFF'              => true,
            'TIME_FORMAT'                => true,
            'TIME_TO_SEC'                => true,
            'TOUCHES'                    => true,
            'TO_DAYS'                    => true,
            'TRIM'                       => true,
            'UCASE'                      => true,
            'UNCOMPRESS'                 => true,
            'UNCOMPRESSED_LENGTH'        => true,
            'UNHEX'                      => true,
            'UNIQUE_USERS'               => true,
            'UNIX_TIMESTAMP'             => true,
            'UPDATEXML'                  => true,
            'UPPER'                      => true,
            'USER'                       => true,
            'UTC_DATE'                   => true,
            'UTC_TIME'                   => true,
            'UTC_TIMESTAMP'              => true,
            'UUID'                       => true,
            'VARIANCE'                   => true,
            'VAR_POP'                    => true,
            'VAR_SAMP'                   => true,
            'VERSION'                    => true,
            'WEEK'                       => true,
            'WEEKDAY'                    => true,
            'WEEKOFYEAR'                 => true,
            'WITHIN'                     => true,
            'X'                          => true,
            'Y'                          => true,
            'YEAR'                       => true,
            'YEARWEEK'                   => true,
        ];

        $options += [
            // インデント文字
            'indent'    => "  ",
            // インラインレベル
            'inline'    => 999,
            // 括弧の展開レベル
            'nestlevel' => 1,
            // キーワードの大文字/小文字可変換（true だと大文字化。false だと小文字化。あるいは 'ucfirst' 等の文字列関数を直接指定する。クロージャでも良い）
            'case'      => null,
            // シンタックス装飾（true だと SAPI に基づいてよしなに。"html", "cli" だと SAPI を明示的に指定。クロージャだと直接コール）
            'highlight' => null,
            // 最大折返し文字数（未実装）
            'wrapsize'  => false,
        ];

        if ($options['case'] === true) {
            $options['case'] = 'strtoupper';
        }
        elseif ($options['case'] === false) {
            $options['case'] = 'strtolower';
        }

        if ($options['highlight'] === true) {
            $options['highlight'] = php_sapi_name() === 'cli' ? 'cli' : 'html';
        }
        if (is_string($options['highlight'])) {
            $rules = [
                'cli'  => [
                    'KEYWORD' => fn($token) => "\e[1m" . $token . "\e[m",
                    'COMMENT' => fn($token) => "\e[33m" . $token . "\e[m",
                    'STRING'  => fn($token) => "\e[31m" . $token . "\e[m",
                    'NUMBER'  => fn($token) => "\e[36m" . $token . "\e[m",
                ],
                'html' => [
                    'KEYWORD' => fn($token) => "<span style='font-weight:bold;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'COMMENT' => fn($token) => "<span style='color:#FF8000;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'STRING'  => fn($token) => "<span style='color:#DD0000;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'NUMBER'  => fn($token) => "<span style='color:#0000BB;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                ],
            ];
            $rule = $rules[$options['highlight']] ?? throw new \InvalidArgumentException('highlight must be "cli" or "html".');
            $options['highlight'] = function ($token, $ttype) use ($keywords, $rule) {
                switch (true) {
                    case isset($keywords[strtoupper($token)]):
                        return $rule['KEYWORD']($token);
                    case in_array($ttype, [T_COMMENT, T_DOC_COMMENT]):
                        return $rule['COMMENT']($token);
                    case in_array($ttype, [T_CONSTANT_ENCAPSED_STRING, T_ENCAPSED_AND_WHITESPACE]):
                        return $rule['STRING']($token);
                    case in_array($ttype, [T_LNUMBER, T_DNUMBER]):
                        return $rule['NUMBER']($token);
                }
                return $token;
            };
        }
        $options['syntaxer'] = function ($token, $ttype) use ($options, $keywords) {
            if (in_array($ttype, [T_COMMENT, T_DOC_COMMENT, T_CONSTANT_ENCAPSED_STRING], true)) {
                $tokens = [$token];
            }
            else {
                $tokens = explode(' ', $token);
            }

            $result = [];
            foreach ($tokens as $token) {
                if ($options['case'] && isset($keywords[strtoupper($token)])) {
                    $token = $options['case']($token);
                }
                if ($options['highlight']) {
                    $token = $options['highlight']($token, $ttype);
                }
                $result[] = $token;
            }
            return implode(' ', $result);
        };

        // 構文解析も先読みもない素朴な実装なので、特定文字列をあとから置換するための目印文字列
        $MARK = unique_string($sql, 8);
        $MARK_BR = "{$MARK}_BR:}"; // 改行マーク
        $MARK_CS = "{$MARK}_CS:}"; // コメント開始マーク
        $MARK_CE = "{$MARK}_CE:}"; // コメント終了マーク
        $MARK_NT = "{$MARK}_NT:}"; // インデントマーク
        $MARK_SP = "{$MARK}_SP:}"; // スペースマーク
        $MARK_PT = "{$MARK}_PT:}"; // 括弧ネストマーク

        // 字句にバラす（シンタックスが php に似ているので token_get_all で大幅にサボることができる）
        $tokens = [];
        $comment = '';
        $last = [];
        foreach (\PhpToken::tokenize("<?php $sql") as $token) {
            // パースのために無理やり <?php を付けているので無視
            if ($token->id === T_OPEN_TAG) {
                continue;
            }

            // '--' は php ではデクリメントだが sql ではコメントなので特別扱いする
            if ($token->id === T_DEC) {
                $comment = $token->text;
            }
            // 改行は '--' コメントの終わり
            elseif ($comment && in_array($token->id, [T_WHITESPACE, T_COMMENT], true) && strpos($token->text, "\n") !== false) {
                $tokens[] = new \PhpToken(T_COMMENT, $comment . $token->text);
                $comment = '';
            }
            // コメント中はコメントに格納する
            elseif ($comment) {
                $comment .= $token->text;
            }
            // END IF, END LOOP などは一つのトークンとする
            elseif (strtoupper($last->text ?? '') === 'END' && in_array(strtoupper($token->text), ['CASE', 'IF', 'LOOP', 'REPEAT', 'WHILE'], true)) {
                $tokens[array_key_last($tokens)]->text .= " " . $token->text;
            }
            // 上記以外はただのトークンとして格納する
            else {
                // `string` のような文字列は T_ENCAPSED_AND_WHITESPACE として得られる（ただし ` がついていないので付与）
                if ($token->id === T_ENCAPSED_AND_WHITESPACE) {
                    $tokens[] = new \PhpToken($token->id, "`{$token->text}`");
                }
                elseif ($token->id !== T_WHITESPACE && $token->text !== '`') {
                    $tokens[] = new \PhpToken($token->id, $token->text);
                }
            }

            if ($token->id !== T_WHITESPACE) {
                $last = $token;
            }
        }

        // コメント以外の前後のトークンを返すクロージャ
        $seek = function ($start, $step) use ($tokens) {
            $comments = [];
            for ($n = 1; ; $n++) {
                $index = $start + $n * $step;
                if (!isset($tokens[$index])) {
                    break;
                }
                $token = $tokens[$index];
                if ($token->id === T_COMMENT || $token->id === T_DOC_COMMENT) {
                    $comments[] = trim($token->text);
                }
                else {
                    return [$index, trim($token->text), $comments];
                }
            }
            return [$start, '', $comments];
        };

        $interpret = function (&$index = -1, $context = '', $breaker = '', $nest = 0) use (&$interpret, $MARK_BR, $MARK_CS, $MARK_CE, $MARK_NT, $MARK_SP, $MARK_PT, $tokens, $options, $seek) {
            $index++;
            $beginning = true; // クエリの冒頭か
            $subcontext = '';  // SET, VALUES などのサブ分類
            $modifier = '';    // RIGHT などのキーワード修飾語
            $firstcol = null;  // SELECT における最初の列か

            $result = [];
            for ($token_length = count($tokens); $index < $token_length; $index++) {
                $token = $tokens[$index];
                $ttype = $token->id;

                $rawtoken = trim($token->text);
                $virttoken = $options['syntaxer']($rawtoken, $ttype);
                $uppertoken = strtoupper($rawtoken);

                // SELECT の直後には DISTINCT などのオプションが来ることがあるので特別扱い
                if ($context === 'SELECT' && $firstcol) {
                    if (!in_array($uppertoken, ['DISTINCT', 'DISTINCTROW', 'STRAIGHT_JOIN'], true) && !preg_match('#^SQL_#i', $uppertoken)) {
                        $firstcol = false;
                        $result[] = $MARK_BR;
                    }
                }

                // コメントは特別扱いでただ付け足すだけ
                if ($ttype === T_COMMENT || $ttype === T_DOC_COMMENT) {
                    $result[] = ($beginning ? '' : $MARK_CS) . $virttoken . $MARK_CE . $MARK_BR;
                    continue;
                }

                $prev = $seek($index, -1);
                $next = $seek($index, +1);

                switch ($uppertoken) {
                    default:
                        _DEFAULT:
                        // "tablename. columnname" になってしまう
                        // "@ var" になってしまう
                        // ": holder" になってしまう
                        if (!in_array($prev[1], ['.', '@', ':', ';'])) {
                            $result[] = $MARK_SP;
                        }

                        $result[] = $virttoken;

                        // "tablename .columnname" になってしまう
                        // "columnname ," になってしまう
                        // mysql において関数呼び出し括弧の前に空白は許されない
                        // ただし、関数呼び出しではなく記号の場合はスペースを入れたい（ colname = (SELECT ～) など）
                        if (!in_array($prev[1], [';']) && !in_array($next[1], ['.', ',', '(', ';']) || ($next[1] === '(' && !preg_match('#^[a-z0-9_"\'`]+$#i', $rawtoken))) {
                            $result[] = $MARK_SP;
                        }
                        break;
                    case "@":
                    case ":":
                        $result[] = $MARK_SP . $virttoken;
                        break;
                    case ".":
                        $result[] = $virttoken;
                        break;
                    case ",":
                        if ($subcontext === 'LIMIT') {
                            $result[] = $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $virttoken . $MARK_BR;
                        break;
                    case ";":
                        $result[] = $virttoken . $MARK_BR;
                        break;
                    case "WITH":
                        $result[] = $virttoken;
                        $result[] = $MARK_BR;
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "BETWEEN":
                        $subcontext = $uppertoken;
                        goto _DEFAULT;
                    case "CREATE":
                    case "ALTER":
                    case "DROP":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $context = $uppertoken;
                        break;
                    case "TABLE":
                        // CREATE TABLE tablename は括弧があるので何もしなくて済むが、
                        // ALTER TABLE tablename は括弧がなく ADD などで始まるので特別分岐
                        $index = $next[0];
                        $result[] = $MARK_SP . $virttoken . $MARK_SP . ($MARK_SP . implode('', $next[2]) . $MARK_CE) . $next[1] . $MARK_SP;
                        if ($context !== 'CREATE' && $context !== 'DROP') {
                            $result[] = $MARK_BR;
                        }
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "AND":
                        // BETWEEN A AND B と論理演算子の AND が競合するので分岐後にフォールスルー
                        if ($subcontext === 'BETWEEN') {
                            $subcontext = '';
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        goto _BINARY_OPERATOR_;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "OR":
                        // CREATE OR REPLACE
                        if ($context === 'CREATE') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        goto _BINARY_OPERATOR_;
                    case "XOR":
                        _BINARY_OPERATOR_:
                        // WHEN の条件はカッコがない限り改行しない
                        if ($subcontext === 'WHEN') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $MARK_SP . $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "UNION":
                    case "EXCEPT":
                    case "INTERSECT":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        $result[] = $MARK_BR;
                        break;
                    case "BY":
                    case "ALL":
                    case "RECURSIVE":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP . array_pop($result);
                        break;
                    case "SELECT":
                        if (!$beginning) {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        $context = $uppertoken;
                        $firstcol = true;
                        break;
                    case "LEFT":
                        /** @noinspection PhpMissingBreakStatementInspection */
                    case "RIGHT":
                        // 例えば LEFT や RIGHT は関数呼び出しの場合もあるので分岐後にフォールスルー
                        if ($next[1] === '(') {
                            goto _DEFAULT;
                        }
                    case "CROSS":
                    case "INNER":
                    case "OUTER":
                        $modifier .= $virttoken . $MARK_SP;
                        break;
                    case "FROM":
                    case "JOIN":
                    case "WHERE":
                    case "HAVING":
                    case "GROUP":
                    case "ORDER":
                    case "LIMIT":
                    case "OFFSET":
                        $subcontext = $uppertoken;
                        $result[] = $MARK_BR . $modifier . $virttoken;
                        $result[] = $MARK_BR; // のちの BY のために結合はせず後ろに入れるだけにする
                        $modifier = '';
                        break;
                    case "FOR":
                    case "LOCK":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        break;
                    case "ON":
                        // ON は ON でも mysql の ON DUPLICATED かもしれない（pgsql の ON CONFLICT も似たようなコンテキスト）
                        if (in_array(strtoupper($next[1]), ['DUPLICATE', 'CONFLICT'], true)) {
                            $result[] = $MARK_BR;
                        }
                        else {
                            $result[] = $MARK_SP;
                        }
                        $result[] = $virttoken . $MARK_SP;
                        break;
                    case "SET":
                        if ($context === "INSERT" || $context === "UPDATE") {
                            $subcontext = $uppertoken;
                            $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        }
                        elseif ($context === "ALTER" || $subcontext === "REFERENCES") {
                            $result[] = $MARK_SP . $virttoken;
                        }
                        else {
                            $result[] = $virttoken;
                        }
                        break;
                    case "INSERT":
                    case "REPLACE":
                        $result[] = $virttoken . $MARK_SP;
                        $context = "INSERT"; // 構文的には INSERT と同じ
                        break;
                    case "INTO":
                        if ($context === "SELECT") {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        if ($context === "INSERT") {
                            $result[] = $MARK_BR;
                        }
                        break;
                    case "VALUES":
                        if ($context === "UPDATE") {
                            $result[] = $MARK_SP . $virttoken;
                        }
                        else {
                            $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        }
                        break;
                    case "REFERENCES":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $subcontext = $uppertoken;
                        break;
                    case "UPDATE":
                    case "DELETE":
                        $result[] = $virttoken;
                        if ($context !== 'CREATE' && $subcontext !== 'REFERENCES') {
                            $result[] = $MARK_BR;
                            $context = $uppertoken;
                        }
                        break;
                    case "IF":
                        $subcontext = $uppertoken;
                        $result[] = $virttoken;
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "WHEN":
                        $subcontext = $uppertoken;
                        $result[] = $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "ELSE":
                        if ($context === 'CASE') {
                            $result[] = $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $virttoken . $MARK_SP;
                        break;
                    case "CASE":
                        $parts = $interpret($index, $uppertoken, 'END', $nest + 1);
                        $parts = str_replace($MARK_BR, $MARK_BR . $MARK_NT, $parts);
                        $result[] = $MARK_NT . $virttoken . $MARK_SP . $parts;
                        break;
                    case "BEGIN":
                        if ($next[1] === ';') {
                            $result[] = $virttoken;
                        }
                        else {
                            $parts = $interpret($index, $uppertoken, 'END', $nest + 1);
                            $parts = preg_replace("#^($MARK_SP)+#u", "", $parts);
                            $parts = preg_replace("#$MARK_BR#u", $MARK_BR . $MARK_NT, $parts, substr_count($parts, $MARK_BR) - 1);
                            $result[] = $MARK_BR . $virttoken . $MARK_BR . $MARK_NT . $parts;
                        }
                        break;
                    case "COMMIT":
                    case "ROLLBACK":
                        // begin は begin～end の一部の可能性があるが commit,rollback は俺の知る限りそのような構文はない
                        $result[] = $virttoken;
                        break;
                    case "END":
                        if ($context === 'CASE') {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        break;
                    case "(":
                        if ($next[1] === ')') {
                            $result[] = $virttoken . implode('', $next[2]) . ')';
                            $index = $next[0];
                            break;
                        }

                        $parts = $uppertoken . $MARK_BR . $interpret($index, $uppertoken, ')', $nest + 1);

                        // コメントを含まない指定ネストレベルなら改行とインデントを吹き飛ばす
                        if (strpos($parts, $MARK_CE) === false && ($nest >= $options['inline'] || substr_count($parts, $MARK_PT) < $options['nestlevel'])) {
                            $parts = strtr($parts, [
                                $MARK_BR => "",
                                $MARK_NT => "",
                            ]);
                            $parts = preg_replace("#\\(($MARK_SP)+#u", '(', $parts);
                            $parts = preg_replace("#($MARK_SP)+\\)#u", ')', $parts);
                        }
                        elseif ($context === 'CREATE') {
                            // ???
                            assert($context === 'CREATE');
                        }
                        else {
                            $lastnt = $MARK_NT;
                            $brnt = $MARK_BR . $MARK_NT;
                            if (strtoupper($next[1]) === 'SELECT') {
                                $brnt .= $lastnt;
                            }
                            $parts = preg_replace("#($MARK_BR(?!\\)))+#u", $brnt, $parts) . $lastnt;
                            $parts = preg_replace("#($MARK_BR(\\)))+#u", "$MARK_BR$MARK_NT)", $parts) . $lastnt;
                            $parts = preg_replace("#$MARK_CS#u", "", $parts);
                        }

                        // IN や数式はネストとみなさない
                        $suffix = $MARK_PT;
                        if (strtoupper($prev[1]) === 'IN' || !preg_match('#^[a-z0-9_]+$#i', $prev[1])) {
                            $suffix = '';
                        }

                        $result[] = $MARK_NT . $parts . $suffix;
                        break;
                    case ")":
                        $result[] = $MARK_BR . $virttoken;
                        break;
                }

                $beginning = false;

                if ($uppertoken === $breaker) {
                    break;
                }
            }
            return implode('', $result);
        };

        $result = $interpret();
        $result = preg_replaces("#" . implode('|', [
                // 改行文字＋インデント文字をインデントとみなす（改行＋連続スペースもついでに）
                "(?<indent>$MARK_BR(($MARK_NT|$MARK_SP)+))",
                // 末尾スペースは除去
                "(?<spbr>($MARK_SP)+(?=$MARK_BR))",
                // 行末コメントと単一コメント
                "(?<cs1>$MARK_BR$MARK_CS)",
                "(?<cs2>$MARK_CS)",
                // 連続改行は1つに集約
                "(?<br>$MARK_BR(($MARK_NT|$MARK_SP)*)($MARK_BR)*)",
                // 連続スペースは1つに集約
                "(?<sp>($MARK_SP)+)",
                // 下記はマーカ文字が現れないように単純置換
                "(?<ce>$MARK_CE)",
                "(?<nt>$MARK_NT)",
                "(?<pt>$MARK_PT)",
            ]) . "#u", [
            'indent' => fn($str) => "\n" . str_repeat($options['indent'], (substr_count($str, $MARK_NT) + substr_count($str, $MARK_SP))),
            'spbr'   => "",
            'cs1'    => "\n" . $options['indent'],
            'cs2'    => "",
            'br'     => "\n",
            'sp'     => ' ',
            'ce'     => "",
            'nt'     => "",
            'pt'     => "",
        ], $result);

        return trim($result);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\sql_quote') || (new \ReflectionFunction('ryunosuke\\ltsv\\sql_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\sql_quote')) {
    /**
     * ものすごく雑に値をクオートする
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた値で**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * - null は NULL になる
     * - 数字はそのまま数字になる
     * - bool は 0 or 1 になる
     * - 配列は再帰的にカンマ区切りになる
     *   - この実装はエラー回避の意味合いが強く、実装は変更される可能性がある
     * - それ以外は addcslashes される
     *
     * Example:
     * ```php
     * that(sql_quote(null))->isSame('NULL');
     * that(sql_quote(123))->isSame(123);
     * that(sql_quote(true))->isSame(1);
     * that(sql_quote("hoge"))->isSame("'hoge'");
     * that(sql_quote([1, 2, 3]))->isSame("1,2,3");
     * ```
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param mixed $value クオートする値
     * @return mixed クオートされた値
     */
    function sql_quote($value)
    {
        if ($value === null) {
            return 'NULL';
        }
        if (is_numeric($value)) {
            return $value;
        }
        if (is_bool($value)) {
            return (int) $value;
        }
        if (is_iterable($value) && !is_stringable($value)) {
            return implode(',', array_map(fn($v) => sql_quote($v), arrayval($value)));
        }
        return "'" . addcslashes((string) $value, "\0\e\f\n\r\t\v'\\") . "'";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\css_selector') || (new \ReflectionFunction('ryunosuke\\ltsv\\css_selector'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\css_selector')) {
    /**
     * CSS セレクタ文字をパースして配列で返す
     *
     * 包含などではない属性セレクタを与えると属性として認識する。
     * 独自仕様として・・・
     *
     * - [!attr]: 否定属性として false を返す
     * - {styles}: style 属性とみなす
     *
     * がある。
     *
     * Example:
     * ```php
     * that(css_selector('#hoge.c1.c2[name=hoge\[\]][href="http://hoge"][hidden][!readonly]{width:123px;height:456px}'))->is([
     *     'id'       => 'hoge',
     *     'class'    => ['c1', 'c2'],
     *     'name'     => 'hoge[]',
     *     'href'     => 'http://hoge',
     *     'hidden'   => true,
     *     'readonly' => false,
     *     'style'    => [
     *         'width'  => '123px',
     *         'height' => '456px',
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $selector CSS セレクタ
     * @return array 属性配列
     */
    function css_selector($selector)
    {
        $tag = '';
        $id = '';
        $classes = [];
        $styles = [];
        $attrs = [];

        $context = null;
        $escaping = null;
        $chars = preg_split('##u', $selector, -1, PREG_SPLIT_NO_EMPTY);
        for ($i = 0, $l = count($chars); $i < $l; $i++) {
            $char = $chars[$i];
            if ($char === '"' || $char === "'") {
                $escaping = $escaping === $char ? null : $char;
            }

            if (!$escaping) {
                if ($context !== '{' && $context !== '[') {
                    if ($char === '#') {
                        if (strlen($id)) {
                            throw new \InvalidArgumentException('#id is multiple.');
                        }
                        $context = $char;
                        continue;
                    }
                    if ($char === '.') {
                        $context = $char;
                        $classes[] = '';
                        continue;
                    }
                }
                if ($char === '{') {
                    $context = $char;
                    $styles[] = '';
                    continue;
                }
                if ($char === ';') {
                    $styles[] = '';
                    continue;
                }
                if ($char === '}') {
                    $context = null;
                    continue;
                }
                if ($char === '[') {
                    $context = $char;
                    $attrs[] = '';
                    continue;
                }
                if ($char === ']') {
                    $context = null;
                    continue;
                }
            }

            if ($char === '\\') {
                $char = $chars[++$i];
            }

            if ($context === null) {
                $tag .= $char;
                continue;
            }
            if ($context === '#') {
                $id .= $char;
                continue;
            }
            if ($context === '.') {
                $classes[count($classes) - 1] .= $char;
                continue;
            }
            if ($context === '{') {
                $styles[count($styles) - 1] .= $char;
                continue;
            }
            if ($context === '[') {
                $attrs[count($attrs) - 1] .= $char;
                continue;
            }
        }

        $attrkv = [];
        if (strlen($tag)) {
            $attrkv[''] = $tag;
        }
        if (strlen($id)) {
            $attrkv['id'] = $id;
        }
        if ($classes) {
            $attrkv['class'] = $classes;
        }
        foreach ($styles as $style) {
            $declares = array_filter(array_map('trim', explode(';', $style)), 'strlen');
            foreach ($declares as $declare) {
                [$k, $v] = array_map('trim', explode(':', $declare, 2)) + [1 => null];
                if ($v === null) {
                    throw new \InvalidArgumentException("[$k] is empty.");
                }
                $attrkv['style'][$k] = $v;
            }
        }
        foreach ($attrs as $attr) {
            [$k, $v] = explode('=', $attr, 2) + [1 => true];
            if (array_key_exists($k, $attrkv)) {
                throw new \InvalidArgumentException("[$k] is dumplicated.");
            }
            if ($k[0] === '!') {
                $k = substr($k, 1);
                $v = false;
            }
            $attrkv[$k] = is_string($v) ? json_decode($v) ?? $v : $v;
        }

        return $attrkv;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\csv_export') || (new \ReflectionFunction('ryunosuke\\ltsv\\csv_export'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\csv_export')) {
    /**
     * 連想配列の配列を CSV 的文字列に変換する
     *
     * CSV ヘッダ行は全連想配列のキーの共通項となる。
     * 順番には依存しないが、余計な要素があってもそのキーはヘッダには追加されないし、データ行にも含まれない。
     * ただし、オプションで headers が与えられた場合はそれを使用する。
     * この headers オプションに連想配列を与えるとヘッダ文字列変換になる（[key => header] で「key を header で吐き出し」となる）。
     * 数値配列を与えると単純に順序指定での出力指定になるが、ヘッダ行が出力されなくなる。
     *
     * callback オプションが渡された場合は「あらゆる処理の最初」にコールされる。
     * つまりヘッダの読み換えや文字エンコーディングの変換が行われる前の状態でコールされる。
     * また、 false を返すとその要素はスルーされる。
     *
     * output オプションにリソースを渡すとそこに対して書き込みが行われる（fclose はされない）。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * $csvarrays = [
     *     ['a' => 'A1', 'b' => 'B1', 'c' => 'C1'],             // 普通の行
     *     ['c' => 'C2', 'a' => 'A2', 'b' => 'B2'],             // 順番が入れ替わっている行
     *     ['c' => 'C3', 'a' => 'A3', 'b' => 'B3', 'x' => 'X'], // 余計な要素が入っている行
     * ];
     * that(csv_export($csvarrays))->is("a,b,c
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * ");
     *
     * // ヘッダを指定できる
     * that(csv_export($csvarrays, [
     *     'headers' => ['a' => 'A', 'c' => 'C'], // a と c だけを出力＋ヘッダ文字変更
     * ]))->is("A,C
     * A1,C1
     * A2,C2
     * A3,C3
     * ");
     *
     * // ヘッダ行を出さない
     * that(csv_export($csvarrays, [
     *     'headers' => ['a', 'c'], // a と c だけを出力＋ヘッダ行なし
     * ]))->is("A1,C1
     * A2,C2
     * A3,C3
     * ");
     *
     * // structure:true で配列も扱える
     * that(csv_export([
     *     ['scalar' => '123', 'list' => ['list11', 'list12'], 'hash' => ['a' => 'hash1A', 'b' => 'hash1B']],
     *     ['scalar' => '456', 'list' => ['list21', 'list22'], 'hash' => ['a' => 'hash2A', 'b' => 'hash2B']],
     * ], [
     *     'structure' => true,
     * ]))->is("scalar,list[],list[],hash[a],hash[b]
     * 123,list11,list12,hash1A,hash1B
     * 456,list21,list22,hash2A,hash2B
     * ");
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param iterable $csvarrays 連想配列の配列
     * @param array $options オプション配列。fputcsv の第3引数以降もここで指定する
     * @return string|int CSV 的文字列。output オプションを渡した場合は書き込みバイト数
     */
    function csv_export($csvarrays, $options = [])
    {
        $options += [
            'delimiter' => ',',
            'enclosure' => '"',
            'escape'    => '\\',
            'encoding'  => mb_internal_encoding(),
            'initial'   => '', // "\xEF\xBB\xBF"
            'headers'   => null,
            'structure' => false,
            'callback'  => null, // map + filter 用コールバック（1行が参照で渡ってくるので書き換えられる&&false を返すと結果から除かれる）
            'output'    => null,
        ];

        $output = $options['output'];

        if ($output) {
            $fp = $options['output'];
        }
        else {
            $fp = fopen('php://temp', 'rw+');
        }

        $restore = set_error_exception_handler();
        try {
            $size = (function ($fp, $csvarrays, $delimiter, $enclosure, $escape, $encoding, $initial, $headers, $structure, $callback) {
                $size = 0;
                $mb_internal_encoding = mb_internal_encoding();

                if (!is_array($csvarrays)) {
                    [$csvarrays, $csvarrays2] = iterator_split($csvarrays, [1], true);
                }

                if ($structure) {
                    foreach ($csvarrays as $n => $array) {
                        $query = strtr(http_build_query($array, ''), ['%5B' => '[', '%5D' => ']']);
                        $csvarrays[$n] = array_map('rawurldecode', str_array(explode('&', $query), '=', true));
                    }
                }
                if (strlen($initial)) {
                    fwrite($fp, $initial);
                }
                if (!$headers) {
                    $tmp = [];
                    foreach ($csvarrays as $array) {
                        // この関数は積集合のヘッダを出すと定義してるが、構造化の場合は和集合で出す
                        if ($structure) {
                            $tmp += $array;
                        }
                        else {
                            $tmp = array_intersect_key($tmp ?: $array, $array);
                        }
                    }
                    $keys = array_keys($tmp);
                    if ($structure) {
                        $tmp = [];
                        for ($i = 0, $l = count($keys); $i < $l; $i++) {
                            $key = $keys[$i];
                            if (isset($tmp[$key])) {
                                continue;
                            }
                            $tmp[$key] = true;
                            $p = strrpos($key, '[');
                            if ($p !== false) {
                                $plain = substr($key, 0, $p + 1);
                                for ($j = $i + 1; $j < $l; $j++) {
                                    if (starts_with($keys[$j], $plain)) {
                                        $tmp[$keys[$j]] = true;
                                    }
                                }
                            }
                        }
                        $keys = array_keys($tmp);
                    }
                    $headers = is_array($headers) ? $keys : array_combine($keys, $keys);
                }
                if (!is_hasharray($headers)) {
                    $headers = array_combine($headers, $headers);
                }
                else {
                    if ($callback) {
                        if ($callback($headers, null) === false) {
                            goto BODY;
                        }
                    }

                    $headerline = $headers;
                    if ($encoding !== $mb_internal_encoding) {
                        mb_convert_variables($encoding, $mb_internal_encoding, $headerline);
                    }
                    if ($structure) {
                        $headerline = array_map(fn($header) => preg_replace('#\[\d+]$#imu', '[]', $header), $headerline);
                    }
                    $size += fputcsv($fp, $headerline, $delimiter, $enclosure, $escape);
                }

                BODY:

                $default = array_fill_keys(array_keys($headers), '');

                if (isset($csvarrays2)) {
                    $csvarrays = iterator_join([$csvarrays, $csvarrays2]);
                }

                foreach ($csvarrays as $n => $array) {
                    if ($callback) {
                        if ($callback($array, $n) === false) {
                            continue;
                        }
                    }
                    $row = array_intersect_key(array_replace($default, $array), $default);
                    if ($encoding !== $mb_internal_encoding) {
                        mb_convert_variables($encoding, $mb_internal_encoding, $row);
                    }
                    $size += fputcsv($fp, $row, $delimiter, $enclosure, $escape);
                }
                return $size;
            })($fp, $csvarrays, $options['delimiter'], $options['enclosure'], $options['escape'], $options['encoding'], $options['initial'], $options['headers'], $options['structure'], $options['callback']);
            if ($output) {
                return $size;
            }
            rewind($fp);
            return stream_get_contents($fp);
        }
        finally {
            $restore();
            if (!$output) {
                fclose($fp);
            }
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\csv_import') || (new \ReflectionFunction('ryunosuke\\ltsv\\csv_import'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\csv_import')) {
    /**
     * CSV 的文字列を連想配列の配列に変換する
     *
     * 1行目をヘッダ文字列とみなしてそれをキーとした連想配列の配列を返す。
     * ただし、オプションで headers が与えられた場合はそれを使用する。
     * この headers オプションはヘッダフィルタも兼ねる（[n => header] で「n 番目フィールドを header で取り込み」となる）。
     * 入力にヘッダがありかつ headers に連想配列が渡された場合はフィルタ兼読み換えとなる（Example を参照）。
     *
     * structure オプションが渡された場合は query like なヘッダーで配列になる。
     *
     * callback オプションが渡された場合は「あらゆる処理の最後」にコールされる。
     * つまりヘッダの読み換えや文字エンコーディングの変換が行われた後の状態でコールされる。
     * また、 false を返すとその要素はスルーされる。
     *
     * メモリ効率は意識しない（どうせ配列を返すので意識しても無駄）。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * that(csv_import("
     * a,b,c
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * "))->is([
     *     ['a' => 'A1', 'b' => 'B1', 'c' => 'C1'],
     *     ['a' => 'A2', 'b' => 'B2', 'c' => 'C2'],
     *     ['a' => 'A3', 'b' => 'B3', 'c' => 'C3'],
     * ]);
     *
     * // ヘッダを指定できる
     * that(csv_import("
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * ", [
     *     'headers' => [0 => 'a', 2 => 'c'], // 1がないので1番目のフィールドを読み飛ばしつつ、0, 2 は "a", "c" として取り込む
     * ]))->is([
     *     ['a' => 'A1', 'c' => 'C1'],
     *     ['a' => 'A2', 'c' => 'C2'],
     *     ['a' => 'A3', 'c' => 'C3'],
     * ]);
     *
     * // ヘッダありで連想配列で指定するとキーの読み換えとなる（指定しなければ読み飛ばしも行える）
     * that(csv_import("
     * a,b,c
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * ", [
     *     'headers' => ['a' => 'hoge', 'c' => 'piyo'], // a は hoge, c は piyo で読み込む。 b は指定がないので飛ばされる
     * ]))->is([
     *     ['hoge' => 'A1', 'piyo' => 'C1'],
     *     ['hoge' => 'A2', 'piyo' => 'C2'],
     *     ['hoge' => 'A3', 'piyo' => 'C3'],
     * ]);
     *
     * // structure:true で配列も扱える
     * that(csv_import("
     * scalar,list[],list[],hash[a],hash[b]
     * 123,list11,list12,hash1A,hash1B
     * 456,list21,list22,hash2A,hash2B
     * ", [
     *     'structure' => true,
     * ]))->is([
     *     ['scalar' => '123', 'list' => ['list11', 'list12'], 'hash' => ['a' => 'hash1A', 'b' => 'hash1B']],
     *     ['scalar' => '456', 'list' => ['list21', 'list22'], 'hash' => ['a' => 'hash2A', 'b' => 'hash2B']],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string|resource $csvstring CSV 的文字列。ファイルポインタでも良いが終了後に必ず閉じられる
     * @param array $options オプション配列。fgetcsv の第3引数以降もここで指定する
     * @return array 連想配列の配列
     */
    function csv_import($csvstring, $options = [])
    {
        $options += [
            'delimiter' => ',',
            'enclosure' => '"',
            'escape'    => '\\',
            'encoding'  => mb_internal_encoding(),
            'headers'   => [],
            'headermap' => null,
            'structure' => false,
            'grouping'  => null,
            'callback'  => null, // map + filter 用コールバック（1行が参照で渡ってくるので書き換えられる&&false を返すと結果から除かれる）
        ];

        // 文字キーを含む場合はヘッダーありの読み換えとなる
        if (is_array($options['headers']) && count(array_filter(array_keys($options['headers']), 'is_string')) > 0) {
            $options['headermap'] = $options['headers'];
            $options['headers'] = null;
        }

        if (is_resource($csvstring)) {
            $fp = $csvstring;
        }
        else {
            $fp = fopen('php://temp', 'r+b');
            fwrite($fp, $csvstring);
            rewind($fp);
        }

        $restore = set_error_exception_handler();
        try {
            return (function ($fp, $delimiter, $enclosure, $escape, $encoding, $headers, $headermap, $structure, $grouping, $callback) {
                $mb_internal_encoding = mb_internal_encoding();
                $result = [];
                $n = -1;
                while ($row = fgetcsv($fp, 0, $delimiter, $enclosure, $escape)) {
                    if ($row === [null]) {
                        continue;
                    }
                    if ($mb_internal_encoding !== $encoding) {
                        mb_convert_variables($mb_internal_encoding, $encoding, $row);
                    }
                    if (!$headers) {
                        $headers = $row;
                        continue;
                    }

                    $n++;
                    if ($structure) {
                        $query = [];
                        foreach ($headers as $i => $header) {
                            $query[] = rawurlencode($header) . "=" . rawurlencode($row[$i]);
                        }
                        $row = query_parse(implode('&', $query), '&', PHP_QUERY_RFC3986);
                        // csv の仕様上、空文字を置かざるを得ないが、数値配列の場合は空にしたいことがある
                        $row = array_map_recursive($row, function ($v) {
                            if (is_array($v) && is_indexarray($v)) {
                                return array_values(array_filter($v, function ($v) {
                                    if (is_array($v)) {
                                        $v = implode('', array_flatten($v));
                                    }
                                    return strlen($v);
                                }));
                            }
                            return $v;
                        }, true, true);
                    }
                    else {
                        $row = array_combine($headers, array_intersect_key($row, $headers));
                    }
                    if ($headermap) {
                        $row = array_pickup($row, $headermap);
                    }
                    if ($callback) {
                        if ($callback($row, $n) === false) {
                            continue;
                        }
                    }

                    if ($grouping !== null) {
                        foreach ($row as $column => $value) {
                            $parts = explode($grouping, $column, 2);
                            if (count($parts) === 1) {
                                array_unshift($parts, "");
                            }
                            $result[$parts[0]][$n][$parts[1]] = $value;
                        }
                    }
                    else {
                        $result[] = $row;
                    }
                }

                if ($grouping !== null) {
                    foreach ($result as $g => $rows) {
                        $result[$g] = array_values(array_unique($rows, SORT_REGULAR));
                    }
                }

                return $result;
            })($fp, $options['delimiter'], $options['enclosure'], $options['escape'], $options['encoding'], $options['headers'], $options['headermap'], $options['structure'], $options['grouping'], $options['callback']);
        }
        finally {
            $restore();
            fclose($fp);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\html_attr') || (new \ReflectionFunction('ryunosuke\\ltsv\\html_attr'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\html_attr')) {
    /**
     * 配列を html の属性文字列に変換する
     *
     * data-* や style, 論理属性など、全てよしなに変換して文字列で返す。
     * 返り値の文字列はエスケープが施されており、基本的にはそのまま html に埋め込んで良い。
     * （オプション次第では危険だったり乱れたりすることはある）。
     *
     * separator オプションを指定すると属性の区切り文字を指定できる。
     * 大抵の場合は半角スペースであり、少し特殊な場合に改行文字を指定するくらいだろう。
     * ただし、この separator に null を与えると文字列ではなく生の配列で返す。
     * この配列は `属性名 => 属性値` な生の配列であり、エスケープも施されていない。
     * $options 自体に文字列を与えた場合は separator 指定とみなされる。
     *
     * 属性の変換ルールは下記。
     *
     * - 属性名が数値の場合は属性としては生成されない
     * - 属性名は camelCase -> cahin-case の変換が行われる
     * - 値が null の場合は無条件で無視される
     *     - 下記 false との違いは「配列返しの場合に渡ってくるか？」である（null は無条件フィルタなので配列返しでも渡ってこない）
     * - 値が true の場合は論理属性とみなし値なしで生成される
     * - 値が false の場合は論理属性とみなし、 属性としては生成されない
     * - 値が配列の場合は ","（カンマ）で結合される
     *     - これは観測範囲内でカンマ区切りが多いため（srcset, accept など）。属性によってはカンマが適切ではない場合がある
     *     - 更にその配列が文字キーを持つ場合、キーが "=" で結合される
     *         - これは観測範囲内で = 区切りが多いため（viewport など）。属性によっては = が適切ではない場合がある
     * - 値が配列で属性名が class, style, data の場合は下記の特殊な挙動を示す
     *     - class: 半角スペースで結合される
     *         - キーは無視される
     *     - style: キーが css 名、値が css 値として ";" で結合される
     *         - キーは cahin-case に変換される
     *         - キーが数値の場合は値がそのまま追加される
     *         - 値が配列の場合は半角スペースで結合される
     *     - data-: キーが data 名、値が data 値として data 属性になる
     *         - キーは cahin-case に変換される
     *         - 値が真偽値以外のスカラーの場合はそのまま、非スカラー||真偽値の場合は json で埋め込まれる
     *             - これは jQuery において json をよしなに扱うことができるため
     *
     * ※ 上記における「配列」とは iterable を指すが、toString を実装した iterable なオブジェクトは toString が優先され、文字列とみなされる
     *
     * 複雑に見えるが「よしなに」やってくれると考えて良い。
     * 配列や真偽値で分岐が大量にあるが、大前提として「string だった場合は余計なことはしない」がある。
     * ので迷ったり予期しない結果の場合は呼び出し側で文字列化して呼べば良い。
     *
     * Example:
     * ```php
     * that(html_attr([
     *     // camelCase は camel-case になる
     *     'camelCase' => '<value>',
     *     // true は論理属性 true とみなし、値なし属性になる
     *     'checked'   => true,
     *     // false は論理属性 false とみなし、属性として現れない
     *     'disabled'  => false,
     *     // null は無条件で無視され、属性として現れない
     *     'readonly'  => null,
     *     // 配列はカンマで結合される
     *     'srcset'    => [
     *         'hoge.jpg 1x',
     *         'fuga.jpg 2x',
     *     ],
     *     // 連想配列は = で結合される
     *     'content'   => [
     *         'width' => 'device-width',
     *         'scale' => '1.0',
     *     ],
     *     // class はスペースで結合される
     *     'class'     => ['hoge', 'fuga'],
     *     // style 原則的に proerty:value; とみなす
     *     'style'     => [
     *         'color'           => 'red',
     *         'backgroundColor' => 'white',      // camel-case になる
     *         'margin'          => [1, 2, 3, 4], // スペースで結合される
     *         'opacity:0.5',                     // 直値はそのまま追加される
     *     ],
     *     // data- はその分属性が生える
     *     'data-'     => [
     *         'camelCase' => 123,
     *         'hoge'      => false,        // 真偽値は文字列として埋め込まれる
     *         'fuga'      => "fuga",       // 文字列はそのまま文字列
     *         'piyo'      => ['a' => 'A'], // 非スカラー以外は json になる
     *     ],
     * ], ['separator' => "\n"]))->is('camel-case="&lt;value&gt;"
     * checked
     * srcset="hoge.jpg 1x,fuga.jpg 2x"
     * content="width=device-width,scale=1.0"
     * class="hoge fuga"
     * style="color:red;background-color:white;margin:1 2 3 4;opacity:0.5"
     * data-camel-case="123"
     * data-hoge="false"
     * data-fuga="fuga"
     * data-piyo="{&quot;a&quot;:&quot;A&quot;}"');
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param iterable $array 属性配列
     * @param string|array|null $options オプション配列
     * @return string|array 属性文字列 or 属性配列
     */
    function html_attr($array, $options = [])
    {
        if (!is_array($options)) {
            $options = ['separator' => $options];
        }

        $options += [
            'quote'     => '"',  // 属性のクオート文字
            'separator' => " ",  // 属性の区切り文字
            'chaincase' => true, // 属性名, data などキーで camelCase を chain-case に変換するか
        ];

        $chaincase = static function ($string) use ($options) {
            if ($options['chaincase']) {
                return chain_case($string);
            }
            return $string;
        };
        $is_iterable = static function ($value) {
            if (is_array($value)) {
                return true;
            }
            if (is_object($value) && $value instanceof \Traversable && !method_exists($value, '__toString')) {
                return true;
            }
            return false;
        };
        $implode = static function ($glue, $iterable) use ($is_iterable) {
            if (!$is_iterable($iterable)) {
                return $iterable;
            }
            if (is_array($iterable)) {
                return implode($glue, $iterable);
            }
            return implode($glue, iterator_to_array($iterable));
        };

        $attrs = [];
        foreach ($array as $k => $v) {
            if ($v === null) {
                continue;
            }

            $k = $chaincase($k);
            assert(!isset($attrs[$k]));

            if (strpbrk($k, "\r\n\t\f '\"<>/=") !== false) {
                throw new \UnexpectedValueException('found invalid charactor as attribute name');
            }

            switch ($k) {
                default:
                    if ($is_iterable($v)) {
                        $tmp = [];
                        foreach ($v as $name => $value) {
                            $name = (is_string($name) ? "$name=" : '');
                            $value = $implode(';', $value);
                            $tmp[] = $name . $value;
                        }
                        $v = implode(',', $tmp);
                    }
                    break;
                case 'class':
                    $v = $implode(' ', $v);
                    break;
                case 'style':
                    if ($is_iterable($v)) {
                        $tmp = [];
                        foreach ($v as $property => $value) {
                            // css において CamelCace は意味を為さないのでオプションによらず強制的に chain-case にする
                            $property = (is_string($property) ? chain_case($property) . ":" : '');
                            $value = $implode(' ', $value);
                            $tmp[] = rtrim($property . $value, ';');
                        }
                        $v = implode(';', $tmp);
                    }
                    break;
                case 'data-':
                    if ($is_iterable($v)) {
                        foreach ($v as $name => $data) {
                            $name = $chaincase($name);
                            $data = is_scalar($data) && !is_bool($data) ? $data : json_encode($data);
                            $attrs[$k . $name] = $data;
                        }
                        continue 2;
                    }
                    break;
            }

            $attrs[$k] = is_bool($v) ? $v : (string) $v;
        }

        if ($options['separator'] === null) {
            return $attrs;
        }

        $result = [];
        foreach ($attrs as $name => $value) {
            if (is_int($name)) {
                continue;
            }
            if ($value === false) {
                continue;
            }
            elseif ($value === true) {
                $result[] = htmlspecialchars($name, ENT_QUOTES);
            }
            else {
                $result[] = htmlspecialchars($name, ENT_QUOTES) . '=' . $options['quote'] . htmlspecialchars($value, ENT_QUOTES) . $options['quote'];
            }
        }
        return implode($options['separator'], $result);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\html_strip') || (new \ReflectionFunction('ryunosuke\\ltsv\\html_strip'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\html_strip')) {
    /**
     * html の空白類を除去して minify する
     *
     * 文字列的ではなく DOM 的に行うのでおかしな部分 html を食わせると意図しない結果になる可能性がある。
     * その副作用として属性のクオートやタグ内空白は全て正規化される。
     *
     * html コメントも削除される。
     * また、空白が意味を持つタグ（textarea, pre）は対象にならない。
     * さらに、php を含むような html （テンプレート）の php タグは一切の対象外となる。
     *
     * これらの挙動の一部はオプションで指定が可能。
     *
     * Example:
     * ```php
     * // e.g. id が " でクオートされている
     * // e.g. class のクオートが " になっている
     * // e.g. タグ内空白（id, class の間隔等）がスペース1つになっている
     * // e.g. php タグは一切変更されていない
     * // e.g. textarea は保持されている
     * that(html_strip("<span  id=id  class='c1  c2  c3'><?= '<hoge>  </hoge>' ?> a  b  c </span> <pre> a  b  c </pre>"))->isSame('<span id="id" class="c1  c2  c3"><?= \'<hoge>  </hoge>\' ?> a b c </span><pre> a  b  c </pre>');
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $html html 文字列
     * @param array $options オプション配列
     * @return string 空白除去された html 文字列
     */
    function html_strip($html, $options = [])
    {
        $options += [
            'error-level'    => E_USER_ERROR, // エラー時の報告レベル
            'encoding'       => 'UTF-8',      // html のエンコーディング
            'escape-phpcode' => true,         // php タグを退避するか
            'html-comment'   => true,         // html コメントも対象にするか
            'ignore-tags'    => [
                // 空白を除去しない特別タグ
                'pre',      // html の仕様でそのまま表示
                'textarea', // html の仕様...なのかスタイルなのかは分からないが普通はそのまま表示だろう
                'script',   // type が js とは限らない。そもそも js だとしても下手にいじるのは怖すぎる
                'style',    // 同上
            ],
        ];

        $preserving = unique_string($html, 64, range('a', 'z'));
        $mapping = [];

        if ($options['escape-phpcode']) {
            $mapping = [];
            $html = php_strip($html, [
                'replacer'       => $preserving,
                'trailing_break' => false,
            ], $mapping);
        }

        // xml 宣言がないとマルチバイト文字が html エンティティになってしまうし documentElement がないと <p> が自動付与されてしまう
        $docTag = "root-$preserving";
        $mapping["<$docTag>"] = '';
        $mapping["</$docTag>"] = '';
        $html = "<?xml encoding=\"{$options['encoding']}\"><$docTag>$html</$docTag>";

        // dom 化
        libxml_clear_errors();
        $current = libxml_use_internal_errors(true);
        $dom = new \DOMDocument();
        $dom->loadHTML($html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD | LIBXML_NOXMLDECL);
        if ($options['error-level']) {
            // http://www.xmlsoft.org/html/libxml-xmlerror.html
            $nohandling = [];
            $nohandling[] = 801;
            if (!$options['escape-phpcode']) {
                $nohandling[] = 46;
            }
            foreach (libxml_get_errors() as $error) {
                if (!in_array($error->code, $nohandling, true)) {
                    trigger_error($error->code . ': ' . $error->message, $options['error-level']);
                }
            }
        }
        libxml_use_internal_errors($current);

        $xpath = new \DOMXPath($dom);

        if ($options['html-comment']) {
            /** @var \DOMComment[] $comments */
            $comments = iterator_to_array($xpath->query('//comment()'), true);
            foreach ($comments as $comment) {
                $comment->parentNode->removeChild($comment);
            }
            $dom->documentElement->normalize();
        }

        /** @var \DOMText[] $texts */
        $texts = iterator_to_array($xpath->query('//text()'), true);
        $texts = array_values(array_filter($texts, function (\DOMNode $node) use ($options) {
            while ($node = $node->parentNode) {
                if (in_array($node->nodeName, $options['ignore-tags'], true)) {
                    return false;
                }
            }
            return true;
        }));
        // @see https://developer.mozilla.org/ja/docs/Web/API/Document_Object_Model/Whitespace
        foreach ($texts as $n => $text) {
            // 連続空白の正規化
            $text->data = preg_replace("#[\t\n\r ]+#u", " ", $text->data);

            // 空白の直後に他の空白がある場合は (2 つが別々なインライン要素をまたぐ場合も含めて) 無視
            if (($next = $texts[$n + 1] ?? null) && ($text->data[-1] ?? null) === ' ') {
                $next->data = ltrim($next->data, "\t\n\r ");
            }

            // 行頭と行末の一連の空白が削除される
            $prev = $text->previousSibling ?? $text->parentNode->previousSibling;
            if (!$prev || in_array($prev->nodeName, $options['ignore-tags'], true)) {
                $text->data = ltrim($text->data, "\t\n\r ");
            }
            $next = $text->nextSibling ?? $text->parentNode->nextSibling;
            if (!$next || in_array($next->nodeName, $options['ignore-tags'], true)) {
                $text->data = rtrim($text->data, "\t\n\r ");
            }
        }
        return trim(strtr($dom->saveHTML($dom->documentElement), $mapping), "\t\n\r ");
    }
}

assert(!function_exists('ryunosuke\\ltsv\\html_tag') || (new \ReflectionFunction('ryunosuke\\ltsv\\html_tag'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\html_tag')) {
    /**
     * css セレクタから html 文字列を生成する
     *
     * `tag#id.class[attr=value]` のような css セレクタから `<tag id="id" class="class" attr="value"></tag>` のような html 文字列を返す。
     * 配列を与えるとキーがセレクタ、値がコンテント文字列になる。
     * さらに値が配列だと再帰して生成する。
     *
     * 値や属性は適切に htmlspecialchars される。
     *
     * Example:
     * ```php
     * // 単純文字列はただのタグを生成する
     * that(
     *     html_tag('a#hoge.c1.c2[name=hoge\[\]][href="http://hoge"][hidden]'))
     *     ->isSame('<a id="hoge" class="c1 c2" name="hoge[]" href="http://hoge" hidden></a>'
     * );
     * // ペア配列を与えるとコンテント文字列になる
     * that(
     *     html_tag(['a.c1#hoge.c2[name=hoge\[\]][href="http://hoge"][hidden]' => "this is text's content"]))
     *     ->isSame('<a id="hoge" class="c1 c2" name="hoge[]" href="http://hoge" hidden>this is text&#039;s content</a>'
     * );
     * // ネストした配列を与えると再帰される
     * that(
     *     html_tag([
     *         'div#wrapper' => [
     *             'b.class1' => [
     *                 '<plain>',
     *             ],
     *             'b.class2' => [
     *                 '<plain1>',
     *                 's' => '<strike>',
     *                 '<plain2>',
     *             ],
     *         ],
     *     ]))
     *     ->isSame('<div id="wrapper"><b class="class1">&lt;plain&gt;</b><b class="class2">&lt;plain1&gt;<s>&lt;strike&gt;</s>&lt;plain2&gt;</b></div>'
     * );
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string|array $selector
     * @return string html 文字列
     */
    function html_tag($selector)
    {
        if (!is_iterable($selector)) {
            $selector = [$selector => ''];
        }

        $html = static fn($string) => htmlspecialchars($string, ENT_QUOTES);

        $build = static function ($selector, $content, $escape) use ($html) {
            $attrs = css_selector($selector);
            $tag = array_unset($attrs, '', '');
            if (!strlen($tag)) {
                throw new \InvalidArgumentException('tagname is empty.');
            }
            if (isset($attrs['class'])) {
                $attrs['class'] = implode(' ', $attrs['class']);
            }
            foreach ($attrs as $k => $v) {
                if ($v === false) {
                    unset($attrs[$k]);
                    continue;
                }
                elseif ($v === true) {
                    $v = $html($k);
                }
                elseif (is_array($v)) {
                    $v = 'style="' . array_sprintf($v, fn($style, $key) => is_int($key) ? $style : "$key:$style", ';') . '"';
                }
                else {
                    $v = sprintf('%s="%s"', $html($k), $html(preg_replace('#^([\"\'])|([^\\\\])([\"\'])$#u', '$2', $v)));
                }
                $attrs[$k] = $v;
            }

            preg_match('#(\s*)(.+)(\s*)#u', $tag, $m);
            [, $prefix, $tag, $suffix] = $m;
            $tag_attr = $html($tag) . concat(' ', implode(' ', $attrs));
            $content = ($escape ? $html($content) : $content);

            return "$prefix<$tag_attr>$content</$tag>$suffix";
        };

        $result = '';
        foreach ($selector as $key => $value) {
            if (is_int($key)) {
                $result .= $html($value);
            }
            elseif (is_iterable($value)) {
                $result .= $build($key, html_tag($value), false);
            }
            else {
                $result .= $build($key, $value, true);
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ini_export') || (new \ReflectionFunction('ryunosuke\\ltsv\\ini_export'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ini_export')) {
    /**
     * 連想配列を INI 的文字列に変換する
     *
     * Example:
     * ```php
     * that(ini_export(['a' => 1, 'b' => 'B', 'c' => PHP_SAPI]))->is('a = 1
     * b = "B"
     * c = "cli"
     * ');
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param array $iniarray ini 化する配列
     * @param array $options オプション配列
     * @return string ini 文字列
     */
    function ini_export($iniarray, $options = [])
    {
        $options += [
            'process_sections' => false,
            'alignment'        => true,
        ];

        $generate = function ($array, $key = null) use (&$generate, $options) {
            $ishasharray = is_array($array) && is_hasharray($array);
            return array_sprintf($array, function ($v, $k) use ($generate, $key, $ishasharray) {
                if (is_iterable($v)) {
                    return $generate($v, $k);
                }

                if ($key === null) {
                    return $k . ' = ' . var_export2($v, true);
                }
                return ($ishasharray ? "{$key}[$k]" : "{$key}[]") . ' = ' . var_export2($v, true);
            }, "\n");
        };

        if ($options['process_sections']) {
            return array_sprintf($iniarray, fn($v, $k) => "[$k]\n{$generate($v)}\n", "\n");
        }

        return $generate($iniarray) . "\n";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ini_import') || (new \ReflectionFunction('ryunosuke\\ltsv\\ini_import'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ini_import')) {
    /**
     * INI 的文字列を連想配列に変換する
     *
     * Example:
     * ```php
     * that(ini_import("
     * a = 1
     * b = 'B'
     * c = PHP_VERSION
     * "))->is(['a' => 1, 'b' => 'B', 'c' => PHP_VERSION]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $inistring ini 文字列
     * @param array $options オプション配列
     * @return array 配列
     */
    function ini_import($inistring, $options = [])
    {
        $options += [
            'process_sections' => false,
            'scanner_mode'     => INI_SCANNER_TYPED,
        ];

        return parse_ini_string($inistring, $options['process_sections'], $options['scanner_mode']);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\json_export') || (new \ReflectionFunction('ryunosuke\\ltsv\\json_export'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\json_export')) {
    /**
     * json_encode のプロキシ関数
     *
     * 引数体系とデフォルト値を変更してある。また、エラー時に例外が飛ぶ。
     *
     * 下記の拡張オプションがある。
     *
     * - JSON_INLINE_LEVEL: PRETTY_PRINT 時に指定以上の階層をインライン化する（数値以外にパスで階層も指定できる）
     * - JSON_INLINE_SCALARLIST: PRETTY_PRINT 時にスカラーのみのリストをインライン化する
     * - JSON_INDENT: PRETTY_PRINT 時にインデント数・文字列を指定する
     * - JSON_CLOSURE: 任意のリテラルを埋め込む
     *   - クロージャの返り値がそのまま埋め込まれるので、文字列化可能な結果を返さなければならない
     *
     * JSON_ES5 を与えると JSON5 互換でエンコードされる。
     * その際下記のプションも使用可能になる。
     *
     * - JSON_TEMPLATE_LITERAL: 改行を含む文字列をテンプレートリテラルで出力する
     * - JSON_TRAILING_COMMA: 末尾カンマを強制する
     * - JSON_COMMENT_PREFIX: コメントとして埋め込まれるキープレフィックスを指定する
     *   - そのキーで始まる要素が文字列なら // コメントになる
     *   - そのキーで始まる要素が配列なら /* コメントになる
     *
     * Example:
     * ```php
     * // オプションはこのように [定数 => bool] で渡す。false は指定されていないとみなされる（JSON_MAX_DEPTH 以外）
     * that(json_export(['a' => 'A', 'b' => 'B'], [
     *    JSON_PRETTY_PRINT => false,
     * ]))->is('{"a":"A","b":"B"}');
     * // json5 でコメント付きかつ末尾カンマ強制モード
     * that(json_export(['a' => 'A', '#comment' => 'this is comment', 'b' => 'B'], [
     *    JSON_ES5            => true,
     *    JSON_TRAILING_COMMA => true,
     *    JSON_COMMENT_PREFIX => '#',
     *    JSON_PRETTY_PRINT   => true,
     * ]))->is('{
     *     a: "A",
     *     // this is comment
     *     b: "B",
     * }');
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param mixed $value encode する値
     * @param array $options JSON_*** をキーにした連想配列。 値が false は指定されていないとみなされる
     * @return string JSON 文字列
     */
    function json_export($value, $options = [])
    {
        $options += [
            JSON_UNESCAPED_UNICODE      => true, // エスケープなしで特にデメリットはない
            JSON_PRESERVE_ZERO_FRACTION => true, // 勝手に変換はできるだけ避けたい
            JSON_THROW_ON_ERROR         => true, // 標準動作はエラーすら出ずに false を返すだけ
        ];
        $es5 = array_unset($options, JSON_ES5, false);
        $comma = array_unset($options, JSON_TRAILING_COMMA, false);
        $comment = array_unset($options, JSON_COMMENT_PREFIX, '');
        $depth = array_unset($options, JSON_MAX_DEPTH, 512);
        $indent = array_unset($options, JSON_INDENT, null);
        $closure = array_unset($options, JSON_CLOSURE, false);
        $nest_level = array_unset($options, JSON_NEST_LEVEL, 0);
        $inline_level = array_unset($options, JSON_INLINE_LEVEL, 0);
        $template_literal = array_unset($options, JSON_TEMPLATE_LITERAL, false);
        $inline_scalarlist = array_unset($options, JSON_INLINE_SCALARLIST, false);

        $option = array_sum(array_keys(array_filter($options)));

        $encode = function ($value, $parents, $objective) use (&$encode, $option, $depth, $indent, $closure, $template_literal, $inline_scalarlist, $nest_level, $inline_level, $es5, $comma, $comment) {
            $nest = $nest_level + count($parents);
            $indent = $indent ?: 4;

            if ($depth < $nest) {
                throw new \ErrorException('Maximum stack depth exceeded', JSON_ERROR_DEPTH);
            }
            if ($closure && $value instanceof \Closure) {
                return $value();
            }
            if (is_object($value)) {
                if ($value instanceof \JsonSerializable) {
                    return $encode($value->jsonSerialize(), $parents, false);
                }
                return $encode(arrayval($value, false), $parents, true);
            }
            if (is_array($value)) {
                $pretty_print = $option & JSON_PRETTY_PRINT;
                $force_object = $option & JSON_FORCE_OBJECT;

                $withoutcommentarray = $value;
                if ($es5 && strlen($comment)) {
                    $withoutcommentarray = array_filter($withoutcommentarray, fn($k) => strpos("$k", $comment) === false, ARRAY_FILTER_USE_KEY);
                }

                $objective = $force_object || $objective || is_hasharray($withoutcommentarray);

                if (!$value) {
                    return $objective ? '{}' : '[]';
                }

                $inline = false;
                if ($inline_level) {
                    if (is_array($inline_level)) {
                        $inline = $inline || fnmatch_or(array_map(fn($v) => "$v.*", $inline_level), implode('.', $parents) . '.');
                    }
                    elseif (ctype_digit("$inline_level")) {
                        $inline = $inline || $inline_level <= $nest;
                    }
                    else {
                        $inline = $inline || fnmatch("$inline_level.*", implode('.', $parents) . '.');
                    }
                }
                if ($inline_scalarlist) {
                    $inline = $inline || !$objective && array_all($value, fn($v) => is_primitive($v) || $v instanceof \Closure);
                }

                $break = $indent0 = $indent1 = $indent2 = $separator = '';
                $delimiter = ',';
                if ($pretty_print && !$inline) {
                    $break = "\n";
                    $separator = ' ';
                    $indent0 = ctype_digit("$indent") ? str_repeat(' ', ($nest + 0) * $indent) : str_repeat($indent, ($nest + 0));
                    $indent1 = ctype_digit("$indent") ? str_repeat(' ', ($nest + 1) * $indent) : str_repeat($indent, ($nest + 1));
                    $indent2 = ctype_digit("$indent") ? str_repeat(' ', ($nest + 2) * $indent) : str_repeat($indent, ($nest + 2));
                }
                if ($pretty_print && $inline) {
                    $separator = ' ';
                    $delimiter = ', ';
                }

                $n = 0;
                $count = count($withoutcommentarray);
                $result = ($objective ? '{' : '[') . $break;
                foreach ($value as $k => $v) {
                    if ($es5 && strlen($comment) && strpos("$k", $comment) === 0) {
                        if (!$pretty_print) {
                            $v = (array) $v;
                        }
                        if (is_array($v)) {
                            $comments = [];
                            foreach ($v as $vv) {
                                $comments[] = "$indent2$vv";
                            }
                            $result .= "$indent1/*$break" . implode($break, $comments) . "$break$indent1*/";
                        }
                        else {
                            $comments = [];
                            foreach (preg_split('#\\R#u', $v) as $vv) {
                                $comments[] = "$indent1// $vv";
                            }
                            $result .= implode($break, $comments);
                        }
                    }
                    else {
                        $result .= $indent1;
                        if ($objective) {
                            $result .= ($es5 && preg_match("#^[a-zA-Z_$][a-zA-Z0-9_$]*$#u", $k) ? $k : json_encode("$k")) . ":$separator";
                        }
                        $result .= $encode($v, array_append($parents, $k), false);
                        if (++$n !== $count || ($comma && !$inline)) {
                            $result .= $delimiter;
                        }
                    }
                    $result .= $break;
                }
                return $result . $indent0 . ($objective ? '}' : ']');
            }

            if ($es5) {
                if (is_float($value) && is_nan($value)) {
                    return 'NaN';
                }
                if (is_float($value) && is_infinite($value) && $value > 0) {
                    return '+Infinity';
                }
                if (is_float($value) && is_infinite($value) && $value < 0) {
                    return '-Infinity';
                }
                if ($template_literal && is_string($value) && strpos($value, "\n") !== false) {
                    $indent1 = ctype_digit("$indent") ? str_repeat(' ', ($nest + 1) * $indent) : str_repeat($indent, ($nest + 1));
                    $jsonstr = json_encode(str_replace(["\r\n", "\r"], "\n", $value), $option, $depth);
                    $jsonstr = substr($jsonstr, 1, -1);
                    $jsonstr = strtr_escaped($jsonstr, [
                        '\\n' => "\n$indent1",
                        '`'   => '\\`',
                    ]);
                    return "`\n$indent1$jsonstr\n$indent1`";
                }
            }
            return json_encode($value, $option, $depth);
        };

        // 特別な状況（クロージャを使うとか ES5 でないとか）以外は 標準を使用したほうが遥かに速い
        if ($indent || $closure || $inline_scalarlist || $inline_level || $es5 || $comma || $comment || $template_literal) {
            return $encode($value, [], false);
        }
        else {
            return json_encode($value, $option, $depth);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\json_import') || (new \ReflectionFunction('ryunosuke\\ltsv\\json_import'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\json_import')) {
    /**
     * json_decode のプロキシ関数
     *
     * 引数体系とデフォルト値を変更してある。
     *
     * JSON_ES5 に null か true を渡すと json5 としてでデコードする（null はまず json_decode で試みる、true は json5 のみ）。
     * その場合拡張オプションとして下記がある。
     *
     * - JSON_INT_AS_STRING: 常に整数を文字列で返す
     * - JSON_FLOAT_AS_STRING: 常に小数を文字列で返す
     * - JSON_BARE_AS_STRING: bare string を文字列として扱う
     * - JSON_TEMPLATE_LITERAL: テンプレートリテラルが使用可能になる
     *   - あくまで「文字列の括りに ` が使えるようになる」というものでテンプレートリテラルそのものではない
     *   - 末尾のインデントと同じインデントがすべて除去され、前後の改行は取り除かれる
     *
     * Example:
     * ```php
     * // オプションはこのように [定数 => bool] で渡す。false は指定されていないとみなされる（JSON_MAX_DEPTH 以外）
     * that(json_import('{"a":"A","b":"B"}', [
     *    JSON_OBJECT_AS_ARRAY => true,
     * ]))->is(['a' => 'A', 'b' => 'B']);
     *
     * // json5 が使える
     * that(json_import('{a: "A", b: "B", }'))->is(['a' => 'A', 'b' => 'B']);
     *
     * // テンプレートリテラル
     * that(json_import('`
     *     1
     *     2
     *     3
     *     `', [
     *     JSON_TEMPLATE_LITERAL => true,
     * ]))->is("1\n2\n3");
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $value JSON 文字列
     * @param array $options JSON_*** をキーにした連想配列。値が false は指定されていないとみなされる
     * @return mixed decode された値
     */
    function json_import($value, $options = [])
    {
        $specials = [
            JSON_OBJECT_AS_ARRAY  => true, // 個人的嗜好だが連想配列のほうが扱いやすい
            JSON_MAX_DEPTH        => 512,
            JSON_ES5              => null,
            JSON_INT_AS_STRING    => false,
            JSON_FLOAT_AS_STRING  => false,
            JSON_TEMPLATE_LITERAL => false,
            JSON_BARE_AS_STRING   => false,
        ];
        foreach ($specials as $key => $default) {
            $specials[$key] = $options[$key] ?? $default;
            unset($options[$key]);
        }
        $specials[JSON_THROW_ON_ERROR] = $options[JSON_THROW_ON_ERROR] ?? true;
        $specials[JSON_BIGINT_AS_STRING] = $options[JSON_BIGINT_AS_STRING] ?? false;
        if ($specials[JSON_INT_AS_STRING] || $specials[JSON_FLOAT_AS_STRING] || $specials[JSON_TEMPLATE_LITERAL] || $specials[JSON_BARE_AS_STRING]) {
            $specials[JSON_ES5] = true;
        }

        // true でないならまず json_decode で試行（json が来るならその方が遥かに速い）
        if ($specials[JSON_ES5] === false || $specials[JSON_ES5] === null) {
            $option = array_sum(array_keys(array_filter($options)));
            $result = json_decode($value, $specials[JSON_OBJECT_AS_ARRAY], $specials[JSON_MAX_DEPTH], $option);

            // エラーが出なかったらもうその時点で返せば良い
            if (json_last_error() === JSON_ERROR_NONE) {
                return $result;
            }
            // json5 を試行しないモードならこの時点で例外
            if ($specials[JSON_ES5] === false) {
                throw new \ErrorException(json_last_error_msg(), json_last_error());
            }
        }

        // 上記を通り抜けたら json5 で試行
        $parser = new class($value) {
            private $json_string;
            private $type;
            private $begin_position;
            private $end_position;
            private $keys;
            private $values;

            public function __construct($json_string)
            {
                $this->json_string = "<?php [$json_string]";
            }

            public function parse($options)
            {
                $tokens = @php_parse($this->json_string, [
                    'cache' => false,
                ]);
                array_shift($tokens);

                $braces = [];
                for ($i = 0; $i < count($tokens); $i++) {
                    $token = $tokens[$i];
                    if ($token->text === '{' || $token->text === '[') {
                        if ($options[JSON_MAX_DEPTH] <= count($braces) + 1) {
                            throw $this->exception("Maximum stack depth exceeded", $token);
                        }
                        $braces[] = $i;
                    }
                    elseif ($token->text === '}' || $token->text === ']') {
                        if (!$braces) {
                            throw $this->exception("Mismatch", $token);
                        }
                        $brace = array_pop($braces);
                        if ($tokens[$brace]->text !== '{' && $token->text === '}' || $tokens[$brace]->text !== '[' && $token->text === ']') {
                            throw $this->exception("Mismatch", $token);
                        }
                        $block = array_filter(array_slice(array_splice($tokens, $brace + 1, $i - $brace, []), 0, -1), fn($token) => !(!$token instanceof $this && in_array($token->id, [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT, T_BAD_CHARACTER], true)));
                        $elements = array_explode($block, fn($token) => !$token instanceof $this && $token->text === ',');
                        // for trailing comma
                        if ($elements && !$elements[count($elements) - 1]) {
                            array_pop($elements);
                        }
                        // check consecutive comma (e.g. [1,,3])
                        if (count(array_filter($elements)) !== count($elements)) {
                            throw $this->exception("Missing element", $token);
                        }
                        $i = $brace;
                        if ($token->text === '}') {
                            $object = $this->token('object', $tokens[$brace]->pos, $token->pos + strlen($token->text));
                            foreach ($elements as $element) {
                                $keyandval = array_explode($element, fn($token) => !$token instanceof $this && $token->text === ':');
                                // check no colon (e.g. {123})
                                if (count($keyandval) !== 2) {
                                    throw $this->exception("Missing object key", first_value($keyandval[0]));
                                }
                                // check objective key (e.g. {[1]: 123})
                                if (($k = array_find($keyandval[0], fn($v) => $v instanceof $this)) !== null) {
                                    throw $this->exception("Unexpected object key", $keyandval[0][$k]);
                                }
                                // check consecutive objective value (e.g. {k: 123 [1]})
                                if (!(count($keyandval[1]) === 1 && count(array_filter($keyandval[1], fn($v) => $v instanceof $this)) === 1 || count(array_filter($keyandval[1], fn($v) => !$v instanceof $this)) === count($keyandval[1]))) {
                                    throw $this->exception("Unexpected object value", $token);
                                }
                                $key = first_value($keyandval[0]);
                                $lastkey = last_value($keyandval[0]);
                                $val = first_value($keyandval[1]);
                                $lastval = last_value($keyandval[1]);
                                if (!$val instanceof $this) {
                                    $val = $this->token('value', $val->pos, $lastval->pos + strlen($lastval->text));
                                }
                                $object->append($this->token('key', $key->pos, $lastkey->pos + strlen($lastkey->text)), $val);
                            }
                            $tokens[$brace] = $object;
                        }
                        if ($token->text === ']') {
                            $array = $this->token('array', $tokens[$brace]->pos, $token->pos + strlen($token->text));
                            foreach ($elements as $element) {
                                // check consecutive objective value (e.g. [123 [1]])
                                if (!(count($element) === 1 && count(array_filter($element, fn($v) => $v instanceof $this)) === 1 || count(array_filter($element, fn($v) => !$v instanceof $this)) === count($element))) {
                                    throw $this->exception("Unexpected array value", $token);
                                }
                                $val = first_value($element);
                                $lastval = last_value($element);
                                if (!$val instanceof $this) {
                                    $val = $this->token('value', $val->pos, $lastval->pos + strlen($lastval->text));
                                }
                                $array->append(null, $val);
                            }
                            $tokens[$brace] = $array;
                        }
                    }
                }

                if ($braces) {
                    throw $this->exception("Mismatch", $tokens[$braces[count($braces) - 1]]);
                }

                /** @var self $root */
                $root = $tokens[0];
                $result = $root->value($options);

                if (count($result) !== 1) {
                    throw $this->exception("Mismatch", $tokens[0]);
                }
                return $result[0];
            }

            private function token($type, $begin_position, $end_position)
            {
                $clone = clone $this;
                $clone->type = $type;
                $clone->begin_position = $begin_position;
                $clone->end_position = $end_position;
                $clone->keys = [];
                $clone->values = [];
                return $clone;
            }

            private function append($key, $value)
            {
                assert(($key !== null && $this->type === 'object') || ($key === null && $this->type === 'array'));
                $this->keys[] = $key ?? count($this->keys);
                $this->values[] = $value;
            }

            private function value($options = [])
            {
                $numberify = function ($token) use ($options) {
                    if (is_numeric($token[0]) || $token[0] === '-' || $token[0] === '+' || $token[0] === '.') {
                        $sign = 1;
                        if ($token[0] === '+' || $token[0] === '-') {
                            $sign = substr($token, 0, 1) === '-' ? -1 : 1;
                            $token = substr($token, 1);
                        }
                        if (($token[0] ?? null) === '0' && isset($token[1]) && $token[1] !== '.') {
                            if (!($token[1] === 'x' || $token[1] === 'X')) {
                                throw $this->exception("Octal literal", $this);
                            }
                            $token = substr($token, 2);
                            if (!ctype_xdigit($token)) {
                                throw $this->exception("Bad hex number", $this);
                            }
                            $token = hexdec($token);
                        }
                        if (!is_numeric($token) || !is_finite($token)) {
                            throw $this->exception("Bad number", $this);
                        }
                        if (false
                            || ($options[JSON_INT_AS_STRING] && ctype_digit("$token"))
                            || ($options[JSON_FLOAT_AS_STRING] && !ctype_digit("$token"))
                            || ($options[JSON_BIGINT_AS_STRING] && ctype_digit("$token") && is_float(($token + 0)))
                        ) {
                            return $sign === -1 ? "-$token" : $token;
                        }

                        return 0 + $sign * $token;
                    }
                    return null;
                };
                $stringify = function ($token) use ($options) {
                    if (strlen($token) > 1 && ($token[0] === '"' || $token[0] === "'" || ($options[JSON_TEMPLATE_LITERAL] && $token[0] === "`"))) {
                        if (strlen($token) < 2 || $token[0] !== $token[-1]) {
                            throw $this->exception("Bad string", $this);
                        }
                        $rawtoken = $token;
                        $token = substr($token, 1, -1);
                        if ($rawtoken[0] === "`" && $rawtoken[1] === "\n" && preg_match('#\n( +)`#u', $rawtoken, $match)) {
                            $token = substr(preg_replace("#\n{$match[1]}#u", "\n", $token), 1, -1);
                        }
                        $token = preg_replace_callback('/(?:\\\\u[0-9A-Fa-f]{4})+/u', function ($m) { return json_decode('"' . $m[0] . '"'); }, $token);
                        $token = strtr($token, [
                            "\\'"    => "'",
                            "\\`"    => "`",
                            '\\"'    => '"',
                            '\\\\'   => '\\',
                            '\\/'    => '/',
                            "\\\n"   => "",
                            "\\\r"   => "",
                            "\\\r\n" => "",
                            '\\b'    => chr(8),
                            '\\f'    => "\f",
                            '\\n'    => "\n",
                            '\\r'    => "\r",
                            '\\t'    => "\t",
                        ]);
                        return $token;
                    }
                    return null;
                };

                switch ($this->type) {
                    default:
                        throw new \DomainException(); // @codeCoverageIgnore
                    case 'array':
                        return array_map(fn($value) => $value->value($options), $this->values);
                    case 'object':
                        $array = array_combine(
                            array_map(fn($value) => $value->value($options), $this->keys),
                            array_map(fn($value) => $value->value($options), $this->values)
                        );
                        return $options[JSON_OBJECT_AS_ARRAY] ? $array : (object) $array;
                    case 'key':
                        $token = substr($this->json_string, $this->begin_position, $this->end_position - $this->begin_position);
                        $token = trim($token, chr(0xC2) . chr(0xA0) . " \n\r\t\v\x00\x0c");
                        if (preg_match('/^(?:[\$_\p{L}\p{Nl}]|\\\\u[0-9A-Fa-f]{4})(?:[\$_\p{L}\p{Nl}\p{Mn}\p{Mc}\p{Nd}\p{Pc}‌‍]|\\\\u[0-9A-Fa-f]{4})*/u', $token)) {
                            $token = preg_replace_callback('/(?:\\\\u[0-9A-Fa-f]{4})+/u', fn($m) => json_decode('"' . $m[0] . '"'), $token);
                            return $token;
                        }
                        if (($string = $stringify($token)) !== null) {
                            return $string;
                        }
                        throw $this->exception("Bad identifier", $this);
                    case 'value':
                        $token = substr($this->json_string, $this->begin_position, $this->end_position - $this->begin_position);
                        $token = trim($token, chr(0xC2) . chr(0xA0) . " \n\r\t\v\x00\x0c");
                        $literals = [
                            'null'      => null,
                            'false'     => false,
                            'true'      => true,
                            'Infinity'  => INF,
                            '+Infinity' => +INF,
                            '-Infinity' => -INF,
                            'NaN'       => NAN,
                            '+NaN'      => +NAN,
                            '-NaN'      => -NAN,
                        ];
                        // literals
                        if (array_key_exists($token, $literals)) {
                            return $literals[$token];
                        }
                        // numbers
                        if (($number = $numberify($token)) !== null) {
                            return $number;
                        }
                        // strings
                        if (($string = $stringify($token)) !== null) {
                            return $string;
                        }
                        if ($options[JSON_BARE_AS_STRING]) {
                            return $token;
                        }
                        throw $this->exception("Bad value", $this);
                }
            }

            private function exception($message, $token)
            {
                if ($token instanceof $this) {
                    $line = substr_count($token->json_string, "\n", 0, $token->begin_position) + 1;
                    $column = $token->begin_position - strrpos($token->json_string, "\n", $token->begin_position - strlen($token->json_string));
                    $word = substr($token->json_string, $token->begin_position, $token->end_position - $token->begin_position);
                }
                else {
                    $line = $token->line;
                    $column = $token->pos - strrpos($this->json_string, "\n", $token->pos - strlen($this->json_string));
                    $word = $token->text;
                }
                return new \ErrorException(sprintf("%s '%s' at line %d column %d of the JSON5 data", $message, $word, $line, $column));
            }
        };

        try {
            return $parser->parse($specials);
        }
        catch (\Throwable $t) {
            if ($specials[JSON_THROW_ON_ERROR]) {
                throw $t;
            }
            // json_last_error を設定する術はないので強制的に Syntax error にする（return することで返り値も統一される）
            return @json_decode('invalid json');
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ltsv_export') || (new \ReflectionFunction('ryunosuke\\ltsv\\ltsv_export'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ltsv_export')) {
    /**
     * 配列を LTSV 的文字列に変換する
     *
     * ラベル文字列に ":" を含む場合は例外を投げる（ラベルにコロンが来るとどうしようもない）。
     *
     * escape オプションで「LTSV 的にまずい文字」がその文字でエスケープされる（具体的には "\n" と "\t"）。
     * デフォルトでは "\\" でエスケープされるので、整合性が崩れることはない。
     *
     * encode オプションで「文字列化できない値」が来たときのその関数を通して出力される（その場合、目印として値の両サイドに ` が付く）。
     * デフォルトでは json_encode される。
     *
     * エンコード機能はおまけに過ぎない（大抵の場合はそんな機能は必要ない）。
     * ので、この実装は互換性を維持せず変更される可能性がある。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * that(ltsv_export([
     *     "label1" => "value1",
     *     "label2" => "value2",
     * ]))->is("label1:value1	label2:value2");
     *
     * // タブや改行文字のエスケープ
     * that(ltsv_export([
     *     "label1" => "val\tue1",
     *     "label2" => "val\nue2",
     * ]))->is("label1:val\\tue1	label2:val\\nue2");
     *
     * // 配列のエンコード
     * that(ltsv_export([
     *     "label1" => "value1",
     *     "label2" => [1, 2, 3],
     * ]))->is("label1:value1	label2:`[1,2,3]`");
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param array $ltsvarray 配列
     * @param array $options オプション配列
     * @return string LTSV 的文字列
     */
    function ltsv_export($ltsvarray, $options = [])
    {
        $options += [
            'escape' => '\\',
            'encode' => fn($v) => json_encode($v, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES),
        ];
        $escape = $options['escape'];
        $encode = $options['encode'];

        $map = [];
        if (strlen($escape)) {
            $map["\\"] = "{$escape}\\";
            $map["\t"] = "{$escape}t";
            $map["\n"] = "{$escape}n";
        }

        $parts = [];
        foreach ($ltsvarray as $label => $value) {
            if (strpos($label, ':')) {
                throw new \InvalidArgumentException('label contains ":".');
            }
            $should_encode = !is_stringable($value);
            if ($should_encode) {
                $value = "`{$encode($value)}`";
            }
            if ($map) {
                $label = strtr($label, $map);
                if (!$should_encode) {
                    $value = strtr($value, $map);
                }
            }
            $parts[] = $label . ':' . $value;
        }
        return implode("\t", $parts);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ltsv_import') || (new \ReflectionFunction('ryunosuke\\ltsv\\ltsv_import'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ltsv_import')) {
    /**
     * LTSV 的文字列を配列に変換する
     *
     * escape オプションで「LTSV 的にまずい文字」がその文字でエスケープされる（具体的には "\n" と "\t"）。
     * デフォルトでは "\\" でエスケープされるので、整合性が崩れることはない。
     *
     * decode オプションで「`` で囲まれた値」が来たときのその関数を通して出力される。
     * デフォルトでは json_decode される。
     *
     * エンコード機能はおまけに過ぎない（大抵の場合はそんな機能は必要ない）。
     * ので、この実装は互換性を維持せず変更される可能性がある。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * that(ltsv_import("label1:value1	label2:value2"))->is([
     *     "label1" => "value1",
     *     "label2" => "value2",
     * ]);
     *
     * // タブや改行文字のエスケープ
     * that(ltsv_import("label1:val\\tue1	label2:val\\nue2"))->is([
     *     "label1" => "val\tue1",
     *     "label2" => "val\nue2",
     * ]);
     *
     * // 配列のデコード
     * that(ltsv_import("label1:value1	label2:`[1,2,3]`"))->is([
     *     "label1" => "value1",
     *     "label2" => [1, 2, 3],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $ltsvstring LTSV 的文字列
     * @param array $options オプション配列
     * @return array 配列
     */
    function ltsv_import($ltsvstring, $options = [])
    {
        $options += [
            'escape' => '\\',
            'decode' => fn($v) => json_decode($v, true),
        ];
        $escape = $options['escape'];
        $decode = $options['decode'];

        $map = [];
        if (strlen($escape)) {
            $map["{$escape}\\"] = "\\";
            $map["{$escape}t"] = "\t";
            $map["{$escape}n"] = "\n";
        }

        $result = [];
        foreach (explode("\t", $ltsvstring) as $part) {
            [$label, $value] = explode(':', $part, 2);
            $should_decode = substr($value, 0, 1) === '`' && substr($value, -1, 1) === '`';
            if ($map) {
                $label = strtr($label, $map);
                if (!$should_decode) {
                    $value = strtr($value, $map);
                }
            }
            if ($should_decode) {
                $value2 = $decode(substr($value, 1, -1));
                // たまたま ` が付いているだけかも知れないので結果で判定する
                if (!is_stringable($value2)) {
                    $value = $value2;
                }
            }
            $result[$label] = $value;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\markdown_list') || (new \ReflectionFunction('ryunosuke\\ltsv\\markdown_list'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\markdown_list')) {
    /**
     * 配列を markdown リスト文字列にする
     *
     * Example:
     * ```php
     * // 最初の "\n" に意味はない（ズレると見づらいので冒頭に足しているだけ）
     * that("\n" . markdown_list([
     *     'dict'        => [
     *         'Key1' => 'Value1',
     *         'Key2' => 'Value2',
     *     ],
     *     'list'        => ['Item1', 'Item2', 'Item3'],
     *     'dict & list' => [
     *         'Key' => 'Value',
     *         ['Item1', 'Item2', 'Item3'],
     *     ],
     * ], ['separator' => ':']))->is("
     * - dict:
     *     - Key1:Value1
     *     - Key2:Value2
     * - list:
     *     - Item1
     *     - Item2
     *     - Item3
     * - dict & list:
     *     - Key:Value
     *         - Item1
     *         - Item2
     *         - Item3
     * ");
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param array $array 配列
     * @param array $option オプション配列
     * @return string markdown リスト文字列
     */
    function markdown_list($array, $option = [])
    {
        $option += [
            'indent'    => '    ',
            'separator' => ': ',
            'liststyle' => '-',
            'ordered'   => false,
            'indexed'   => null,
        ];

        $f = function ($array, $nest) use (&$f, $option) {
            $spacer = str_repeat($option['indent'], $nest);
            $result = [];
            $seq = 0;
            foreach ($array as $k => $v) {
                $indexed = $option['indexed'] ?? is_int($k) && $k === $seq++;
                if (is_iterable($v)) {
                    if (!$indexed) {
                        $result[] = $spacer . $option['liststyle'] . ' ' . $k . $option['separator'];
                    }
                    $result = array_merge($result, $f($v, $nest + 1));
                }
                else {
                    if (!$indexed) {
                        $result[] = $spacer . $option['liststyle'] . ' ' . $k . $option['separator'] . $v;
                    }
                    elseif (!$option['ordered']) {
                        $result[] = $spacer . $option['liststyle'] . ' ' . $v;
                    }
                    else {
                        $result[] = $spacer . $seq . '. ' . $v;
                    }
                }
            }
            return $result;
        };
        return implode("\n", $f($array, 0)) . "\n";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\markdown_table') || (new \ReflectionFunction('ryunosuke\\ltsv\\markdown_table'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\markdown_table')) {
    /**
     * 連想配列の配列を markdown テーブル文字列にする
     *
     * 見出しはキーの和集合で生成され、改行は `<br>` に置換される。
     * 要素が全て数値の場合は右寄せになる。
     *
     * Example:
     * ```php
     * // 最初の "\n" に意味はない（ズレると見づらいので冒頭に足しているだけ）
     * that("\n" . markdown_table([
     *    ['a' => 'a1', 'b' => 'b1'],
     *    ['b' => 'b2', 'c' => '2'],
     *    ['a' => 'a3', 'c' => '3'],
     * ]))->is("
     * | a   | b   |   c |
     * | --- | --- | --: |
     * | a1  | b1  |     |
     * |     | b2  |   2 |
     * | a3  |     |   3 |
     * ");
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param array $array 連想配列の配列
     * @param array $option オプション配列
     * @return string markdown テーブル文字列
     */
    function markdown_table($array, $option = [])
    {
        if (!is_array($array) || is_empty($array)) {
            throw new \InvalidArgumentException('$array must be array of hasharray.');
        }

        $option += [
            'keylabel'  => null,   // 指定すると一番左端にキーの列が生える
            'context'   => 'html', // html:改行がbrになる（html 以外は未定義）
            'stringify' => fn($v) => var_pretty($v, ['return' => true, 'context' => $option['context'], 'table' => false]),
        ];

        $stringify = fn($v) => strtr(trim((is_stringable($v) ? $v : $option['stringify']($v)) ?? ''), ["\t" => '    ']);
        $is_numeric = function ($v) {
            $v = trim($v);
            if (strlen($v) === 0) {
                return true;
            }
            if (is_numeric($v)) {
                return true;
            }
            return preg_match('#^-?[1-9][0-9]{0,2}(,[0-9]{3})*(\.[0-9]+)?$#', $v);
        };

        $rows = [];
        $defaults = [];
        $numerics = [];
        $lengths = [];
        foreach ($array as $n => $fields) {
            assert(is_array($fields), '$array must be array of hasharray.');
            if ($option['keylabel'] !== null) {
                $fields = [$option['keylabel'] => $n] + $fields;
            }
            if ($option['context'] === 'html') {
                $fields = array_map(fn($v) => (array) str_replace(["\r\n", "\r", "\n"], '<br>', $stringify($v)), $fields);
            }
            else {
                $fields = array_map(fn($v) => preg_split("#\r?\n#u", $stringify($v)), $fields);
            }
            foreach ($fields as $k => $v) {
                $defaults[$k] = '';
                foreach ($v as $i => $t) {
                    $e = ansi_strip($t);
                    $rows["{$n}_{$i}"][$k] = $t;
                    $numerics[$k] = ($numerics[$k] ?? true) && $is_numeric($e);
                    $lengths[$k] = max($lengths[$k] ?? 3, mb_monospace(ansi_strip($k)), mb_monospace($e)); // 3 は markdown の最低見出し長
                }
            }
        }

        $linebuilder = function ($fields, $padstr) use ($numerics, $lengths) {
            $line = [];
            foreach ($fields as $k => $v) {
                $ws = str_repeat($padstr, $lengths[$k] - (mb_monospace(ansi_strip($v))));
                $pad = $numerics[$k] ? "$ws$v" : "$v$ws";
                if ($padstr === '-' && $numerics[$k]) {
                    $pad[-1] = ':';
                }
                $line[] = $pad;
            }
            return '| ' . implode(' | ', $line) . ' |';
        };

        $result = [];

        $result[] = $linebuilder(array_combine($keys = array_keys($defaults), $keys), ' ');
        $result[] = $linebuilder($defaults, '-');
        foreach ($rows as $fields) {
            $result[] = $linebuilder(array_replace($defaults, $fields), ' ');
        }

        return implode("\n", $result) . "\n";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\paml_export') || (new \ReflectionFunction('ryunosuke\\ltsv\\paml_export'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\paml_export')) {
    /**
     * 連想配列を paml 的文字列に変換する
     *
     * paml で出力することはまずないのでおまけ（import との対称性のために定義している）。
     *
     * Example:
     * ```php
     * that(paml_export([
     *     'n' => null,
     *     'f' => false,
     *     'i' => 123,
     *     'd' => 3.14,
     *     's' => 'this is string',
     * ]))->isSame('n: null, f: false, i: 123, d: 3.14, s: "this is string"');
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param array $pamlarray 配列
     * @param array $options オプション配列
     * @return string PAML 的文字列
     */
    function paml_export($pamlarray, $options = [])
    {
        $options += [
            'trailing-comma' => false,
            'pretty-space'   => true,
        ];

        $space = $options['pretty-space'] ? ' ' : '';

        $result = [];
        $n = 0;
        foreach ($pamlarray as $k => $v) {
            if (is_array($v)) {
                $inner = paml_export($v, $options);
                if (is_hasharray($v)) {
                    $v = '{' . $inner . '}';
                }
                else {
                    $v = '[' . $inner . ']';
                }
            }
            elseif ($v === null) {
                $v = 'null';
            }
            elseif ($v === false) {
                $v = 'false';
            }
            elseif ($v === true) {
                $v = 'true';
            }
            elseif (is_string($v)) {
                $v = str_quote($v);
            }

            if ($k === $n++) {
                $result[] = "$v";
            }
            else {
                $result[] = "$k:{$space}$v";
            }
        }
        return implode(",$space", $result) . ($options['trailing-comma'] ? ',' : '');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\paml_import') || (new \ReflectionFunction('ryunosuke\\ltsv\\paml_import'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\paml_import')) {
    /**
     * paml 的文字列をパースする
     *
     * paml とは yaml を簡易化したような独自フォーマットを指す（Php Array Markup Language）。
     * ざっくりと下記のような特徴がある。
     *
     * - ほとんど yaml と同じだがフロースタイルのみでキーコロンの後のスペースは不要
     * - yaml のアンカーや複数ドキュメントのようなややこしい仕様はすべて未対応
     * - 配列を前提にしているので、トップレベルの `[]` `{}` は不要
     * - `[]` でいわゆる php の配列、 `{}` で stdClass を表す（オプション指定可能）
     * - bare string で php の定数を表す（クラス定数も完全修飾すれば使用可能）
     *
     * 簡易的な設定の注入に使える（yaml は標準で対応していないし、json や php 配列はクオートの必要やケツカンマ問題がある）。
     * なお、かなり緩くパースしてるので基本的にエラーにはならない。
     *
     * 早見表：
     *
     * - php:  `["n" => null, "f" => false, "i" => 123, "d" => 3.14, "s" => "this is string", "a" => [1, 2, "x" => "X"]]`
     *     - ダブルアローとキーのクオートが冗長
     * - json: `{"n":null, "f":false, "i":123, "d":3.14, "s":"this is string", "a":{"0": 1, "1": 2, "x": "X"}}`
     *     - キーのクオートが冗長だしケツカンマ非許容
     * - yaml: `{n: null, f: false, i: 123, d: 3.14, s: "this is string", a: {0: 1, 1: 2, x: X}}`
     *     - 理想に近いが、コロンの後にスペースが必要だし連想配列が少々難。なにより拡張や外部ライブラリが必要
     * - paml: `n:null, f:false, i:123, d:3.14, s:"this is string", a:[1, 2, x:X]`
     *     - シンプルイズベスト
     *
     * Example:
     * ```php
     * // こういったスカラー型はほとんど yaml と一緒だが、コロンの後のスペースは不要（あってもよい）
     * that(paml_import('n:null, f:false, i:123, d:3.14, s:"this is string"'))->isSame([
     *     'n' => null,
     *     'f' => false,
     *     'i' => 123,
     *     'd' => 3.14,
     *     's' => 'this is string',
     * ]);
     * // 配列が使える（キーは連番なら不要）。ネストも可能
     * that(paml_import('a:[1,2,x:X,3], nest:[a:[b:[c:[X]]]]'))->isSame([
     *     'a'    => [1, 2, 'x' => 'X', 3],
     *     'nest' => [
     *         'a' => [
     *             'b' => [
     *                 'c' => ['X']
     *             ],
     *         ],
     *     ],
     * ]);
     * // bare 文字列で定数が使える。::class も特別扱いで定数とみなす
     * that(paml_import('pv:PHP_VERSION, ao:ArrayObject::STD_PROP_LIST, class:ArrayObject::class'))->isSame([
     *     'pv'    => \PHP_VERSION,
     *     'ao'    => \ArrayObject::STD_PROP_LIST,
     *     'class' => \ArrayObject::class,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $pamlstring PAML 文字列
     * @param array $options オプション配列
     * @return array php 配列
     */
    function paml_import($pamlstring, $options = [])
    {
        $options += [
            'cache'          => true,
            'trailing-comma' => true,
            'stdclass'       => true,
            'expression'     => false,
            'escapers'       => ['"' => '"', "'" => "'", '[' => ']', '{' => '}'],
        ];

        static $caches = [];
        if ($options['cache']) {
            $key = $pamlstring . json_encode($options);
            return $caches[$key] ??= paml_import($pamlstring, ['cache' => false] + $options);
        }

        $resolve = function (&$value, $options) {
            $prefix = $value[0] ?? null;
            $suffix = $value[-1] ?? null;

            if (($prefix === '[' && $suffix === ']') || ($prefix === '{' && $suffix === '}')) {
                $values = paml_import(substr($value, 1, -1), $options);
                $value = ($prefix === '[' || !$options['stdclass']) ? (array) $values : (object) $values;
                return true;
            }

            if ($prefix === '"' && $suffix === '"') {
                //$element = stripslashes(substr($element, 1, -1));
                $value2 = json_decode($value);
                if (json_last_error() === JSON_ERROR_NONE) {
                    $value = $value2;
                    return true;
                }
            }
            if ($prefix === "'" && $suffix === "'") {
                $value = substr($value, 1, -1);
                return true;
            }

            if (ctype_digit(ltrim($value, '+-'))) {
                $value = (int) $value;
                return true;
            }
            if (is_numeric($value)) {
                $value = (double) $value;
                return true;
            }

            if (defined($value)) {
                $value = constant($value);
                return true;
            }
            [$class, $cname] = explode('::', $value, 2) + [1 => ''];
            if (class_exists($class) && strtolower($cname) === 'class') {
                $value = ltrim($class, '\\');
                return true;
            }

            if ($options['expression']) {
                $semicolon = ';';
                if ($prefix === '`' && $suffix === '`') {
                    $value = eval("return " . substr($value, 1, -1) . $semicolon);
                    return true;
                }
                try {
                    $evalue = @eval("return $value$semicolon");
                    if ($value !== $evalue) {
                        $value = $evalue;
                        return true;
                    }
                }
                catch (\ParseError) {
                }
            }

            return false;
        };

        $values = array_map('trim', quoteexplode(',', $pamlstring, null, $options['escapers']));
        if ($options['trailing-comma'] && end($values) === '') {
            array_pop($values);
        }

        $result = [];
        foreach ($values as $value) {
            $key = null;
            if (!$resolve($value, $options)) {
                $kv = array_map('trim', quoteexplode(':', $value, 2, $options['escapers']));
                if (count($kv) === 2) {
                    [$key, $value] = $kv;
                    $resolve($key, ['expression' => false] + $options);
                    $resolve($value, $options);
                }
            }

            array_set($result, $value, is_int($key) ? null : $key);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_alter') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_alter'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_alter')) {
    /**
     * 日付を除外日リストに基づいてずらす
     *
     * 典型的には「祝日前の営業日」「祝日後の営業日」のような代理日を返すイメージ。
     * $follow_count に応じて下記のように返す。
     *
     * - null: 除外日でもずらさないでそのまま返す
     * - -N: 除外日なら最大N日分前倒しした日付を返す
     * - +N: 除外日なら最大N日分先送りした日付を返す
     * - 0: 除外日でもずらさないで null を返す
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string|int|\DateTimeInterface $datetime 調べる日付
     * @param array $excluded_dates 除外日（いわゆる祝休日リスト）
     * @param ?int $follow_count ずらす範囲
     * @param string $format 日付フォーマット（$excluded_dates の形式＋返り値の形式）
     * @return string|null 代替日。除外日 null
     */
    function date_alter($datetime, $excluded_dates, $follow_count, $format = 'Y-m-d')
    {
        $timestamp = date_timestamp($datetime);
        if (!array_key_exists($date = date($format, $timestamp), $excluded_dates)) {
            return $date;
        }
        if ($follow_count === null) {
            return $date;
        }
        $follow_count = (int) $follow_count;
        if ($follow_count < 0) {
            return date_alter($timestamp - 24 * 3600, $excluded_dates, $follow_count + 1, $format);
        }
        if ($follow_count > 0) {
            return date_alter($timestamp + 24 * 3600, $excluded_dates, $follow_count - 1, $format);
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_convert') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_convert'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_convert')) {
    /**
     * 日時文字列をよしなに別のフォーマットに変換する
     *
     * マイクロ秒にも対応している。
     * かなり適当に和暦にも対応している。
     *
     * 拡張書式は下記。
     * - J: 日本元号
     *   - e.g. 平成
     *   - e.g. 令和
     * - b: 日本元号略称
     *   - e.g. H
     *   - e.g. R
     * - k: 日本元号年
     *   - e.g. 平成7年
     *   - e.g. 令和1年
     * - K: 日本元号年（1年が元年）
     *   - e.g. 平成7年
     *   - e.g. 令和元年
     * - x: 日本語曜日
     *   - e.g. 日
     *   - e.g. 月
     * - Q: 月内週番号（商が第N、余が曜日）
     *   - e.g. 6（7 * 0 + 6 第1土曜日）
     *   - e.g. 15（7 * 2 + 1 第3月曜日）
     *
     * php8.2 から x,X が追加されたため上記はあくまで参考となる。
     *
     * Example:
     * ```php
     * // 和暦を Y/m/d H:i:s に変換
     * that(date_convert('Y/m/d H:i:s', '昭和31年12月24日 12時34分56秒'))->isSame('1956/12/24 12:34:56');
     * // 単純に「マイクロ秒が使える date」としても使える
     * $now = 1234567890.123; // テストがしづらいので固定時刻にする
     * that(date_convert('Y/m/d H:i:s.u', $now))->isSame('2009/02/14 08:31:30.122999');
     * // $format に DateTimeInterface 実装クラス名を与えるとそのインスタンスを返す
     * that(date_convert(\DateTimeImmutable::class, $now))->isInstanceOf(\DateTimeImmutable::class);
     * // null は DateTime を意味する
     * that(date_convert(null, $now))->isInstanceOf(\DateTime::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @todo 引数を入れ替えたほうが自然な気がする
     *
     * @param ?string $format フォーマット
     * @param string|int|float|\DateTimeInterface|null $datetimedata 日時データ。省略時は microtime
     * @return string|\DateTimeInterface 日時文字列。$format が null の場合は DateTime
     */
    function date_convert($format, $datetimedata = null)
    {
        $format ??= \DateTime::class;
        $return_object = class_exists($format) && is_subclass_of($format, \DateTimeInterface::class);

        if ($return_object && $datetimedata instanceof \DateTimeInterface) {
            return $datetimedata;
        }

        // 省略時は microtime
        if ($datetimedata === null) {
            $timestamp = microtime(true);
        }
        else {
            $timestamp = date_timestamp($datetimedata);
            if ($timestamp === null) {
                throw new \InvalidArgumentException("parse failed '$datetimedata'");
            }
        }

        if (!$return_object) {
            $era = array_find(JP_ERA, function ($era) use ($timestamp) {
                if ($era['since'] <= $timestamp) {
                    $era['year'] = idate('Y', (int) $timestamp) - idate('Y', $era['since']) + 1;
                    $era['gann'] = $era['year'] === 1 ? '元' : $era['year'];
                    return $era;
                }
            }, false);
            $format = strtr_escaped($format, [
                'J' => fn() => $era ? $era['name'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'b' => fn() => $era ? $era['abbr'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'k' => fn() => $era ? $era['year'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'K' => fn() => $era ? $era['gann'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'x' => fn() => ['日', '月', '火', '水', '木', '金', '土'][idate('w', (int) $timestamp)],
                'Q' => fn() => idate('w', $timestamp) + intdiv(idate('j', $timestamp) - 1, 7) * 7,
            ], '\\');
        }

        if (is_int($timestamp) && !$return_object) {
            return date($format, $timestamp);
        }

        $class = $return_object ? $format : \DateTime::class;
        $dt = new $class();
        $dt = $dt->setTimestamp((int) $timestamp);

        if (is_float($timestamp)) {
            $diff = (int) (($timestamp - (int) $timestamp) * 1000 * 1000);
            $dt = $dt->modify("$diff microsecond");
        }

        if ($return_object) {
            return $dt;
        }
        return $dt->format($format);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_fromto') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_fromto'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_fromto')) {
    /**
     * 日時っぽい文字列とフォーマットを与えると取りうる範囲を返す
     *
     * 与えられた日時の最大の切り捨て日時と最小の切り上げ日時の配列を返す。
     * 日付文字列はある程度よしなに補完される（例えば "2014/12" は"2014年12月01日" と解釈されるし "12/24" は "今年12月24日" と解釈される）。
     *
     * Example:
     * ```php
     * that(date_fromto('Y/m/d H:i:s', '2010/11'))->isSame(["2010/11/01 00:00:00", "2010/12/01 00:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24'))->isSame(["2010/11/24 00:00:00", "2010/11/25 00:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24 13'))->isSame(["2010/11/24 13:00:00", "2010/11/24 14:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24 13:24'))->isSame(["2010/11/24 13:24:00", "2010/11/24 13:25:00"]);
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string $format フォーマット。 null を与えるとタイムスタンプで返す
     * @param string $datetimestring 日時データ
     * @return array|null [from ～ to] な配列。解釈できない場合は null
     */
    function date_fromto($format, $datetimestring)
    {
        $parsed = date_parse($datetimestring);
        if (true
            && $parsed['year'] === false
            && $parsed['month'] === false
            && $parsed['day'] === false
            && $parsed['hour'] === false
            && $parsed['minute'] === false
            && $parsed['second'] === false) {
            return null;
        }

        [$date, $time] = preg_split('#[T\s　]#u', $datetimestring, -1, PREG_SPLIT_NO_EMPTY) + [0 => '', 1 => ''];
        [$y, $m, $d] = preg_split('#[^\d]+#u', $date, -1, PREG_SPLIT_NO_EMPTY) + [0 => null, 1 => null, 2 => null];
        [$h, $i, $s] = preg_split('#[^\d]+#u', $time, -1, PREG_SPLIT_NO_EMPTY) + [0 => null, 1 => null, 2 => null];

        // "2014/12" と "12/24" の区別はつかないので字数で判断
        if (strlen($y ?? '') <= 2) {
            [$y, $m, $d] = [null, $y, $m];
        }
        // 時刻区切りなし
        if (strlen($h ?? '') > 2) {
            [$h, $i, $s] = str_split($h, 2) + [0 => null, 1 => null, 2 => null];
        }

        // 文字列表現で妥当性を検証
        $strtime = sprintf('%04d-%02d-%02d %02d:%02d:%02d', $y ?? 1000, $m ?? 1, $d ?? 1, $h ?? 1, $i ?? 1, $s ?? 1);
        $datetime = date_create_from_format('Y-m-d H:i:s', $strtime);
        if (!$datetime || $datetime->format('Y-m-d H:i:s') !== $strtime) {
            return null;
        }

        $y ??= idate('Y');
        $ld = $d ?? idate('t', mktime(0, 0, 0, $m ?? 12, 1, $y));

        $min = mktime($h ?? 0, $i ?? 0, $s ?? 0, $m ?? 1, $d ?? 1, $y) + $parsed['fraction'];
        $max = mktime($h ?? 23, $i ?? 59, $s ?? 59, $m ?? 12, $d ?? $ld, $y) + 1;
        if ($format === null) {
            return [$min, $max];
        }
        return [date_convert($format, $min), date_convert($format, $max)];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_interval') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_interval'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_interval')) {
    /**
     * ISO8601継続時間文字列を DateInterval に変換する
     *
     * 各要素には負数を与えることができる。
     * 秒にはミリ秒を与えることもできる。
     *
     * Example:
     * ```php
     * // 普通のISO8601継続時間
     * that(date_interval('P1Y2M3DT4H5M6S'))->format('%R%Y-%M-%DT%H:%I:%S.%f')->is('+01-02-03T04:05:06.0');
     * // 負数が使える
     * that(date_interval('P1Y2M3DT4H5M-6S'))->format('%R%Y-%M-%DT%H:%I:%S.%f')->is('+01-02-03T04:05:-6.0');
     * // ミリ秒が使える
     * that(date_interval('P1Y2M3DT4H5M6.789S'))->format('%R%Y-%M-%DT%H:%I:%S.%f')->is('+01-02-03T04:05:06.788999');
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string $interval ISO8601継続時間文字列か相対表記
     * @return \DateInterval DateInterval オブジェクト
     */
    function date_interval($interval)
    {
        if (preg_match('#^(?P<S>[\-+])?P((?P<Y>-?\d+)Y)?((?P<M>-?\d+)M)?((?P<D>-?\d+)D)?(T((?P<h>-?\d+)H)?((?P<m>-?\d+)M)?((?P<s>-?\d+(\.\d+)?)S)?)?$#', $interval, $matches, PREG_UNMATCHED_AS_NULL)) {
            $interval = new \DateInterval('P0Y');
            $interval->y = (int) $matches['Y'];
            $interval->m = (int) $matches['M'];
            $interval->d = (int) $matches['D'];
            $interval->h = (int) $matches['h'];
            $interval->i = (int) $matches['m'];
            $interval->s = (int) $matches['s'];
            $interval->f = (float) $matches['s'] - $interval->s;

            if ($matches['S'] === '-') {
                $interval->y = -$interval->y;
                $interval->m = -$interval->m;
                $interval->d = -$interval->d;
                $interval->h = -$interval->h;
                $interval->i = -$interval->i;
                $interval->s = -$interval->s;
                $interval->f = -$interval->f;
            }
        }
        else {
            $parsed = date_parse($interval);
            if ($parsed['errors'] || !$parsed['relative']) {
                throw new \InvalidArgumentException("$interval is invalid DateInterval string");
            }
            $interval = new \DateInterval('P0Y');
            $interval->y = $parsed['relative']['year'];
            $interval->m = $parsed['relative']['month'];
            $interval->d = $parsed['relative']['day'];
            $interval->h = $parsed['relative']['hour'];
            $interval->i = $parsed['relative']['minute'];
            $interval->s = $parsed['relative']['second'];
        }

        $now = new \DateTimeImmutable();
        if ($now > $now->add($interval)) {
            $interval->invert = 1;
            $interval->y = -$interval->y;
            $interval->m = -$interval->m;
            $interval->d = -$interval->d;
            $interval->h = -$interval->h;
            $interval->i = -$interval->i;
            $interval->s = -$interval->s;
            $interval->f = -$interval->f;
        }
        return $interval;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_interval_second') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_interval_second'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_interval_second')) {
    /**
     * DateInterval を秒に変換する
     *
     * 1ヶ月の間隔は時期によって異なるため、 $basetime 次第で結果が変わることがあるので注意。
     * $interval は DateInterval だけでなく ISO8601 文字列も与えることができる。
     * その際、下記の拡張仕様がある。
     * - 先頭の正負記号（-+）を受け入れる（DateInterval->invert で表現される）
     * - 秒だけは小数表記を受け入れる（DateInterval->f で表現される。元々 ISO8601 の仕様だが DateInterval は対応していないっぽい）
     *
     * Example:
     * ```php
     * // 1分30秒は90秒
     * that(date_interval_second('PT1M30S'))->isSame(90);
     * // 負数が使える
     * that(date_interval_second('-PT1M30S'))->isSame(-90);
     * // 秒は小数が使える
     * that(date_interval_second('-PT1M30.5S'))->isSame(-90.5);
     *
     * // 1980/01/01 からの3ヶ月は 7862400 秒（うるう年なので 91 日）
     * that(date_interval_second('P3M', '1980/01/01'))->isSame(7862400);
     * // 1981/01/01 からの3ヶ月は 7776000 秒（うるう年じゃないので 90 日）
     * that(date_interval_second('P3M', '1981/01/01'))->isSame(7776000);
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param \DateInterval|string|float|int $interval DateInterval インスタンスか間隔を表す ISO8601 文字列
     * @param string|float|int $basetime 基準日時（省略時 1970/01/01 00:00:00）
     * @return float|int 秒（$interval->f を含んでいるとき float で返す）
     */
    function date_interval_second($interval, $basetime = 0)
    {
        if (is_decimal($interval)) {
            return $interval + 0;
        }

        if (!$interval instanceof \DateInterval) {
            $interval = date_interval($interval);
        }

        $datetime = date_convert(\DateTimeImmutable::class, $basetime);
        $difftime = $datetime->add($interval);

        return date_timestamp($difftime) - date_timestamp($datetime);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_interval_string') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_interval_string'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_interval_string')) {
    /**
     * 秒を世紀・年・月・日・時間・分・秒・ミリ秒の各要素に分解する
     *
     * 例えば `60 * 60 * 24 * 900 + 12345.678` （約900日12345秒）は・・・
     *
     * - 2 年（約900日なので）
     * - 5 ヶ月（約(900 - 365 * 2 = 170)日なので）
     * - 18 日（約(170 - 30.416 * 5 = 18)日なので）
     * - 3 時間（約12345秒なので）
     * - 25 分（約(12345 - 3600 * 3 = 1545)秒なので）
     * - 45 秒（約(1545 - 60 * 25 = 45)秒なので）
     * - 678 ミリ秒（.678 部分そのまま）
     *
     * となる（年はうるう年未考慮で365日、月は30.41666666日で換算）。
     *
     * $format を与えると DateInterval::format して文字列で返す。与えないと DateInterval をそのまま返す。
     * $format はクロージャを与えることができる。クロージャを与えた場合、各要素を引数としてコールバックされる。
     * $format は配列で与えることができる。配列で与えた場合、 0 になる要素は省かれる。
     * セパレータを与えたり、pre/suffix を与えたりできるが、難解なので省略する。
     *
     * $limit_type で換算のリミットを指定できる。例えば 'y' を指定すると「2年5ヶ月」となるが、 'm' を指定すると「29ヶ月」となる。
     * 数値を与えるとその範囲でオートスケールする。例えば 3 を指定すると値が大きいとき `ymd` の表示になり、年が 0 になると `mdh` の表示に切り替わるようになる。
     *
     * Example:
     * ```php
     * // 書式文字列指定（%vはミリ秒）
     * that(date_interval_string(60 * 60 * 24 * 900 + 12345.678, '%Y/%M/%D %H:%I:%S.%v'))->isSame('02/05/18 03:25:45.678');
     *
     * // 書式にクロージャを与えるとコールバックされる（引数はスケールの小さい方から）
     * that(date_interval_string(60 * 60 * 24 * 900 + 12345.678, fn() => implode(',', func_get_args())))->isSame('678,45,25,3,18,5,2,0');
     *
     * // リミットを指定（month までしか計算しないので year は 0 になり month は 29になる）
     * that(date_interval_string(60 * 60 * 24 * 900 + 12345.678, '%Y/%M/%D %H:%I:%S.%v', 'm'))->isSame('00/29/18 03:25:45.678');
     *
     * // 書式に配列を与えてリミットに数値を与えるとその範囲でオートスケールする
     * $format = [
     *     'y' => '%y年',
     *     'm' => '%mヶ月',
     *     'd' => '%d日',
     *     ' ',
     *     'h' => '%h時間',
     *     'i' => '%i分',
     *     's' => '%s秒',
     * ];
     * // 数が大きいので年・月・日の3要素のみ
     * that(date_interval_string(60 * 60 * 24 * 900 + 12345, $format, 3))->isSame('2年5ヶ月18日');
     * // 数がそこそこだと日・時間・分の3要素に切り替わる
     * that(date_interval_string(60 * 60 * 24 * 20 + 12345, $format, 3))->isSame('20日 3時間25分');
     * // どんなに数が小さくても3要素以下にはならない
     * that(date_interval_string(1234, $format, 3))->isSame('0時間20分34秒');
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param \DateInterval|string|float|int $interval DateInterval インスタンスか間隔を表す ISO8601 文字列
     * @param string|array|\Closure $format 時刻フォーマット
     * @param string|int $limit_type どこまで換算するか（[c|y|m|d|h|i|s]）
     * @return string|\DateInterval 時間差文字列
     */
    function date_interval_string($interval, $format = null, $limit_type = 'y')
    {
        $ymdhisv = ['c', 'y', 'm', 'd', 'h', 'i', 's', 'v'];
        $map = ['c' => 7, 'y' => 6, 'm' => 5, 'd' => 4, 'h' => 3, 'i' => 2, 's' => 1];
        if (ctype_digit("$limit_type")) {
            $limit = $map['c'];
            $limit_type = (int) $limit_type;
            if (!is_array($format)) {
                throw new \UnexpectedValueException('$format must be array if $limit_type is digit.');
            }
        }
        else {
            $limit = $map[$limit_type] ?? throw new \InvalidArgumentException("limit_type:$limit_type is undefined.");
        }

        $sec = date_interval_second($interval);

        // 各単位を導出
        $mills = $sec * 1000;
        $seconds = $sec;
        $minutes = $seconds / 60;
        $hours = $minutes / 60;
        $days = $hours / 24;
        $months = $days / (365 / 12);
        $years = $days / 365;
        $centurys = $years / 100;

        // $limit に従って値を切り捨てて DateInterval を作成
        // 「以下に示すプロパティが使えるかどうかは、 PHP のバージョンに依存します。 そして、readonly と見なすべきです」
        // とのことで、今は動いているけどいずれ使えなくなると思う
        $interval = new #[\AllowDynamicProperties] class ( 'PT1S' ) extends \DateInterval { };
        $interval->c = $limit < $map['c'] ? 0 : (int) $centurys % 1000;
        $interval->y = $limit < $map['y'] ? 0 : (int) ($limit === $map['y'] ? $years : (int) $years % 100);
        $interval->m = $limit < $map['m'] ? 0 : (int) ($limit === $map['m'] ? $months : (int) $months % 12);
        $interval->d = $limit < $map['d'] ? 0 : (int) ($limit === $map['d'] ? $days : (int) ((int) ($days * 100000000) % (int) (365 / 12 * 100000000) / 100000000));
        $interval->h = $limit < $map['h'] ? 0 : (int) ($limit === $map['h'] ? $hours : (int) $hours % 24);
        $interval->i = $limit < $map['i'] ? 0 : (int) ($limit === $map['i'] ? $minutes : (int) $minutes % 60);
        $interval->s = $limit < $map['s'] ? 0 : (int) ($limit === $map['s'] ? $seconds : (int) $seconds % 60);
        $interval->v = $mills % 1000;

        // クロージャはコールバックする
        if ($format instanceof \Closure) {
            return $format($interval->v, $interval->s, $interval->i, $interval->h, $interval->d, $interval->m, $interval->y, $interval->c);
        }

        // 配列はいろいろとフィルタする
        if (is_array($format)) {
            // 数値ならその範囲でオートスケール
            if (is_int($limit_type)) {
                // 配列を回して値があるやつ + $limit_type の範囲とする
                foreach ($ymdhisv as $n => $key) {
                    // 最低 $limit_type は保持するために isset する
                    if ($interval->$key > 0 || !isset($ymdhisv[$n + $limit_type + 1])) {
                        $pos = [];
                        for ($i = 0; $i < $limit_type; $i++) {
                            if (isset($ymdhisv[$n + $i])) {
                                if (($p = array_pos_key($format, $ymdhisv[$n + $i], -1)) >= 0) {
                                    $pos[] = $p;
                                }
                            }
                        }
                        if (!$pos) {
                            throw new \UnexpectedValueException('$format is empty.');
                        }
                        // 順不同なので min/max から slice しなければならない
                        $min = min($pos);
                        $max = max($pos);
                        $format = array_slice($format, $min, $max - $min + 1);
                        break;
                    }
                }
            }

            // 来ている $format を正規化（日時文字列は配列にするかつ値がないならフィルタ）
            $tmp = [];
            foreach ($format as $key => $fmt) {
                if (isset($interval->$key)) {
                    if (!is_int($limit_type) && $interval->$key === 0) {
                        $tmp[] = ['', '', ''];
                        continue;
                    }
                    $fmt = arrayize($fmt);
                    $fmt = match (count($fmt)) {
                        1 => ['', $fmt[0], ''],
                        2 => ['', $fmt[0], $fmt[1]],
                        3 => array_values($fmt),
                    };
                }
                $tmp[] = $fmt;
            }
            // さらに前後の値がないならフィルタ
            $tmp2 = [];
            foreach ($tmp as $n => $fmt) {
                $prevempty = true;
                for ($i = $n - 1; $i >= 0; $i--) {
                    if (!is_array($tmp[$i])) {
                        break;
                    }
                    if (strlen($tmp[$i][1])) {
                        $prevempty = false;
                        break;
                    }
                }
                $nextempty = true;
                for ($i = $n + 1, $l = count($tmp); $i < $l; $i++) {
                    if (!is_array($tmp[$i])) {
                        break;
                    }
                    if (strlen($tmp[$i][1])) {
                        $nextempty = false;
                        break;
                    }
                }

                if (is_array($fmt)) {
                    if ($prevempty) {
                        $fmt[0] = '';
                    }
                    if ($nextempty) {
                        $fmt[2] = '';
                    }
                }
                elseif ($prevempty || $nextempty) {
                    $fmt = '';
                }
                $tmp2 = array_merge($tmp2, arrayize($fmt));
            }
            $format = implode('', $tmp2);
        }

        $format = strtr_escaped($format, [
            '%c' => $interval->c,
            '%v' => $interval->v,
        ], '%');
        return $interval->format($format);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_match') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_match'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_match')) {
    /**
     * 日時と cron ライクな表記のマッチングを行う
     *
     * YYYY/MM/DD(W) hh:mm:ss のようなパターンを与える。
     *
     * - YYYY: 年を表す（1～9999）
     * - MM: 月を表す（1～12）
     * - DD: 日を表す（1～31, 99,L で末日を表す）
     *   - e.g. 2/99 は 2/28,2/29 を表す（年に依存）
     *   - e.g. 2/L も同様
     * - W: 曜日を表す（0～6, #N で第Nを表す、#o,#e で隔週を表す）
     *   - e.g. 3 は毎水曜日を表す
     *   - e.g. 3#4 は第4水曜日を表す
     *   - e.g. 5#L は最終水曜日を表す
     *   - e.g. 4#o は隔週水曜日を表す（週番号奇数）
     *   - e.g. 4#e は隔週水曜日を表す（週番号偶数）
     * - hh: 時を表す（任意で 0～23）
     * - mm: 分を表す（任意で 0～59）
     * - ss: 秒を表す（任意で 0～59）
     *
     * DD と W は AND 判定される（cron は OR）。
     * また `/`（毎）にあたる表記はない。
     *
     * 9,L は「最後」を意味し、文脈に応じた値に書き換わる。
     *  「最終」が可変である日付と曜日のみ指定可能。
     * 例えば `2012/02/99` は「2014/02/29」になるし、`2012/02/**(3#L)` は「2012/02の最終水曜」になる。
     *
     * 各区切り内の値は下記が許可される。
     *
     * - *: 任意の値を表す（桁合わせのためにいくつあってもよい）
     * - 値: 特定の一つの数値を表す
     * - 数字-数字: 範囲を表す
     * - 数字,数字: いずれかを表す
     *
     * `*` 以外は複合できるので Example を参照。
     *
     * この関数は実験的なので互換性担保に含まれない。
     *
     * Example:
     * ```php
     * // 2014年の12月にマッチする
     * that(date_match('2014/12/24 12:34:56', '2014/12/*'))->isTrue();
     * that(date_match('2014/11/24 12:34:56', '2014/12/*'))->isFalse();
     * that(date_match('2015/12/24 12:34:56', '2014/12/*'))->isFalse();
     * // 2014年の12月20日～25日にマッチする
     * that(date_match('2014/12/24 12:34:56', '2014/12/20-25'))->isTrue();
     * that(date_match('2014/12/26 12:34:56', '2014/12/20-25'))->isFalse();
     * that(date_match('2015/12/24 12:34:56', '2014/12/20-25'))->isFalse();
     * // 2014年の12月10,20,30日にマッチする
     * that(date_match('2014/12/20 12:34:56', '2014/12/10,20,30'))->isTrue();
     * that(date_match('2014/12/24 12:34:56', '2014/12/10,20,30'))->isFalse();
     * that(date_match('2015/12/30 12:34:56', '2014/12/10,20,30'))->isFalse();
     * // 2014年の12月10,20~25,30日にマッチする
     * that(date_match('2014/12/24 12:34:56', '2014/12/10,20-25,30'))->isTrue();
     * that(date_match('2014/12/26 12:34:56', '2014/12/10,20-25,30'))->isFalse();
     * that(date_match('2015/12/26 12:34:56', '2014/12/10,20-25,30'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param mixed $datetime 日時を表す引数
     * @param string $cronlike マッチパターン
     * @return bool マッチしたら true
     */
    function date_match($datetime, $cronlike)
    {
        static $dayofweek = [
            0 => ['日', '日曜', '日曜日', 'sun', 'sunday'],
            1 => ['月', '月曜', '月曜日', 'mon', 'monday'],
            2 => ['火', '火曜', '火曜日', 'tue', 'tuesday'],
            3 => ['水', '水曜', '水曜日', 'wed', 'wednesday'],
            4 => ['木', '木曜', '木曜日', 'thu', 'thursday'],
            5 => ['金', '金曜', '金曜日', 'fri', 'friday'],
            6 => ['土', '土曜', '土曜日', 'sat', 'saturday'],
        ];

        static $reverse_dayofweek = null;
        $reverse_dayofweek ??= (function () use ($dayofweek) {
            $result = [];
            foreach ($dayofweek as $weekno => $texts) {
                $result += array_fill_keys($texts, $weekno);
            }
            return $result;
        })();

        static $dayofweek_pattern = null;
        $dayofweek_pattern ??= (function () use ($dayofweek) {
            $result = [];
            foreach ($dayofweek as $texts) {
                $result = array_merge($result, $texts);
            }
            usort($result, fn($a, $b) => strlen($b) <=> strlen($a));
            return implode('|', $result);
        })();

        $timestamp = date_timestamp($datetime);
        if ($timestamp === null) {
            throw new \InvalidArgumentException("failed to parse '$datetime'");
        }

        // よく使うので変数化しておく
        $weekno = idate('W', $timestamp);
        $firstdate = date('Y-m-1', $timestamp);
        $lastday = idate('t', $timestamp);
        $lastweekdays = []; // range($day, $lastday);
        for ($day = 29; $day <= $lastday; $day++) {
            $lastweekdays[] = $day;
        }

        // マッチング
        $pattern = <<<REGEXP
               (?<Y> \\*+ | (\\d{1,4}(-\\d{1,4})?)(,(\\d{1,4}(-\\d{1,4})?))* )
            (/ (?<M> \\*+ | (\\d{1,2}(-\\d{1,2})?)(,(\\d{1,2}(-\\d{1,2})?))* ))?
            (/ (?<D> \\*+ | ((\\d{1,2}|L)(-(\\d{1,2}|L))?)(,((\\d{1,2}|L)(-(\\d{1,2}|L))?))*))?
            \\s*
            (\((?<W> \\*+ | (([0-6]|$dayofweek_pattern)(\\#(\\d|L|E|O))?(-([0-6]|$dayofweek_pattern)(\\#(\\d|L|E|O))?)?)(,(([0-6]|$dayofweek_pattern)(\\#(\\d|L|E|O))?(-([0-6]|$dayofweek_pattern)(\\#(\\d|L|E|O))?)?))* ) \) )?
            \\s*
               (?<h> \\*+ | (\\d{1,2}(-\\d{1,2})?)(,(\\d{1,2}(-\\d{1,2})?))* )?
            (: (?<m> \\*+ | (\\d{1,2}(-\\d{1,2})?)(,(\\d{1,2}(-\\d{1,2})?))* ))?
            (: (?<s> \\*+ | (\\d{1,2}(-\\d{1,2})?)(,(\\d{1,2}(-\\d{1,2})?))* ))?
            # dummy-comment
        REGEXP;
        if (!preg_match("!^$pattern$!ixu", trim($cronlike), $matches, PREG_UNMATCHED_AS_NULL)) {
            throw new \InvalidArgumentException("failed to parse '$cronlike'");
        }

        $matches = array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);

        // 週の特殊処理
        $matches['W'] = preg_replace_callback("!$dayofweek_pattern!u", fn($m) => $reverse_dayofweek[$m[0]], $matches['W'] ?? '');

        foreach ($matches as $key => &$match) {
            // 9, L 等の特殊処理
            if ($key === 'D') {
                $match = preg_replace('!(L+|9{2,})!', $lastday, $match ?? '');
            }
            else {
                $match = preg_replace('!(L+|9+)!', 'LAST', $match ?? '');
            }

            // 1-4 などを 1,2,3,4 に展開
            $match = preg_replace_callback('!(\d+)-(\d+)!u', fn($m) => implode(',', range($m[1], $m[2])), $match);
        }

        // 週の特殊処理
        $matches['W'] = preg_replace_callback('!(\d{1,2})(#(\d|LAST|e|o))?!ui', function ($m) use ($weekno, $firstdate, $lastweekdays) {
            $n = (int) $m[1];
            $w = $m[3] ?? null;
            if ($w === null || $w === '*') {
                return implode(',', range($n, 34, 7));
            }
            if ($w === 'e') {
                if ($weekno % 2 === 0) {
                    return 'none';
                }
                return implode(',', range($n, 34, 7));
            }
            if ($w === 'o') {
                if ($weekno % 2 === 1) {
                    return 'none';
                }
                return implode(',', range($n, 34, 7));
            }
            if ($w === 'LAST') {
                $w = idate('w', strtotime($firstdate));
                $lasts = array_map(fn($v) => ($v - 29 + $w) % 7, $lastweekdays);
                return $n + (in_array($n, $lasts, true) ? 4 : 3) * 7;
            }
            return $n + ($w - 1) * 7;
        }, $matches['W']);

        // 1,2,3,4,7 などを連想配列に展開する（兼範囲チェック）
        $parse = function ($pattern, $min, $max) {
            $values = [];
            foreach (explode(',', (string) $pattern) as $range) {
                if (strlen(trim($range, '*'))) {
                    $range = (int) $range;
                    if (!($min <= $range && $range <= $max)) {
                        throw new \InvalidArgumentException("$range($min~$max)");
                    }
                    $values[$range] = true;
                }
            }
            return $values;
        };

        // 各要素ごとの処理
        $Ymdwhis = [
            'Y' => $parse($matches['Y'], 1, 9999),
            'n' => $parse($matches['M'], 1, 12),
            'j' => $parse($matches['D'], 1, 31),
            'Q' => $parse($matches['W'], 0, 34),
            'G' => $parse($matches['h'], 0, 24),
            'i' => $parse($matches['m'], 0, 59),
            's' => $parse($matches['s'], 0, 59),
        ];

        $datestring = date_convert(implode(',', array_keys($Ymdwhis)), $timestamp);
        $dateparts = array_combine(array_keys($Ymdwhis), explode(',', $datestring));

        foreach ($dateparts as $key => $value) {
            if ($Ymdwhis[$key] && !isset($Ymdwhis[$key][$value])) {
                return false;
            }
        }

        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_modulate') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_modulate'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_modulate')) {
    /**
     * 日時を加減算する
     *
     * フォーマットを維持しつつ日時文字列の最小単位でよしなに加算する。
     * 具体的には Example を参照。
     *
     * Example:
     * ```php
     * // 年加算
     * that(date_modulate('2014', 1))->isSame('2015');
     * // 月加算
     * that(date_modulate('2014/12', 1))->isSame('2015/01');
     * // 日加算
     * that(date_modulate('2014/12/24', 1))->isSame('2014/12/25');
     * // 時加算
     * that(date_modulate('2014/12/24 12', 1))->isSame('2014/12/24 13');
     * // 分加算
     * that(date_modulate('2014/12/24 12:34', 1))->isSame('2014/12/24 12:35');
     * // 秒加算
     * that(date_modulate('2014/12/24 12:34:56', 1))->isSame('2014/12/24 12:34:57');
     * // ミリ秒加算
     * that(date_modulate('2014/12/24 12:34:56.789', 1))->isSame('2014/12/24 12:34:56.790');
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string $datetimedata 日時文字列
     * @param int|string|\DateInterval $modify 加減算値
     * @return string 加算された日時文字列
     */
    function date_modulate($datetimedata, $modify)
    {
        $format = date_parse_format($datetimedata, $parseinfo);
        if ($format === null) {
            throw new \UnexpectedValueException("failed parse date format ($datetimedata)");
        }

        if (is_string($modify) && !ctype_digit(ltrim($modify, '+-'))) {
            $modify = date_interval($modify);
        }

        $dt = new \DateTime();
        $dt->setDate($parseinfo['Y'] ?? 1, $parseinfo['M'] ?? 1, $parseinfo['D'] ?? 1);
        $dt->setTime($parseinfo['h'] ?? 0, $parseinfo['m'] ?? 0, $parseinfo['s'] ?? 0, ($parseinfo['f'] ?? 0) * 1000);
        if ($modify instanceof \DateInterval) {
            $dt->add($modify);
        }
        else {
            $unitmap = [
                'Y' => 'year',
                'M' => 'month',
                'D' => 'day',
                'h' => 'hour',
                'm' => 'minute',
                's' => 'second',
                'f' => 'millisecond',
            ];
            $unit = $unitmap[array_key_last(array_filter($unitmap, fn($key) => $parseinfo[$key] !== null, ARRAY_FILTER_USE_KEY))];
            $dt->modify("$modify $unit");
        }
        return $dt->format($format);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_parse_format') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_parse_format'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_parse_format')) {
    /**
     * 日時文字列のフォーマットを返す
     *
     * 例えば "2014/12/24 12:34:56" から "Y/m/d H:i:s" を逆算して返す。
     * 精度は非常に低く、相対表現なども未対応（そもそも逆算は一意に決まるものでもない）。
     *
     *  Example:
     * ```php
     * // RFC3339
     * that(date_parse_format('2014-12-24T12:34:56'))->isSame('Y-m-d\TH:i:s');
     * // 日本式
     * that(date_parse_format('2014/12/24 12:34:56'))->isSame('Y/m/d H:i:s');
     * // アメリカ式
     * that(date_parse_format('12/24/2014 12:34:56'))->isSame('m/d/Y H:i:s');
     * // イギリス式
     * that(date_parse_format('24.12.2014 12:34:56'))->isSame('d.m.Y H:i:s');
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string $datetimestring 日時文字列
     * @param array $parsed パースの参考情報が格納される（内部向け）
     * @return ?string フォーマット文字列
     */
    function date_parse_format($datetimestring, &$parsed = [])
    {
        $datetimestring = trim($datetimestring);
        $parsed = (function ($datetimestring) {
            $date_parse = function ($datetimestring) {
                $parsed = date_parse($datetimestring);
                $parsed['datetimestring'] = $datetimestring;
                $parsed += [
                    'has:Y' => $parsed['year'] !== false,
                    'has:M' => $parsed['month'] !== false,
                    'has:D' => $parsed['day'] !== false,
                    'has:h' => $parsed['hour'] !== false,
                    'has:m' => $parsed['minute'] !== false,
                    'has:s' => $parsed['second'] !== false,
                    'has:f' => $parsed['fraction'] !== false,
                    'has:z' => ($parsed['zone'] ?? false) !== false,
                ];
                return $parsed;
            };

            $parsed = $date_parse($datetimestring);

            // エラーがあってもある程度は救うことができる
            if ($parsed['error_count']) {
                // スラッシュの扱いに難があるので統一して再チャレンジ（2014/12 と 2014-12 は扱いがまったく異なる）
                $parsed = $date_parse(str_replace('/', '-', $datetimestring));
                if (!$parsed['error_count']) {
                    $parsed['warnings'][] = 'replace "/" -> "-"';
                    return $parsed;
                }
                // 例えば fraction で誤検知している場合（20140202T123456.789123 は Y:7891 になる）
                if ($parsed['has:Y'] && $parsed['has:M'] && $parsed['has:D'] && $parsed['has:h'] && $parsed['has:m'] && $parsed['has:s'] && $parsed['has:f']) {
                    $rdot = strrpos($datetimestring, '.');
                    if ($rdot !== false) {
                        $parsed = $date_parse(substr($datetimestring, 0, $rdot));
                        if (!$parsed['error_count']) {
                            $parsed['warnings'][] = 'remove fraction';
                            $parsed['fraction'] = '0' . substr($datetimestring, $rdot);
                            return $parsed;
                        }
                    }
                }
                // 例えば minute が足りない場合（20140202T12, 2014-02-02T12 のような分無しはパース自体が失敗する）
                if ($parsed['has:Y'] && $parsed['has:M'] && $parsed['has:D'] && !$parsed['has:h'] && !$parsed['has:m'] && !$parsed['has:s'] && !$parsed['has:f']) {
                    $parsed = $date_parse($datetimestring . ':00');
                    if (!$parsed['error_count']) {
                        $parsed['warnings'][] = 'add minute';
                        return $parsed;
                    }
                }
                return $parsed;
            }

            // 日付ありきとする
            if (!$parsed['has:Y'] && !$parsed['has:M'] && !$parsed['has:D'] && $parsed['has:h'] && $parsed['has:m'] && $parsed['has:s']) {
                // 例えば 201412 は h:20,m:14,s:12 と解釈される
                $parsed = $date_parse($datetimestring . '01T00:00:00');
                if (!$parsed['error_count']) {
                    $parsed['warnings'][] = 'add day';
                    return $parsed;
                }
                // 例えば 2014 は h:20,m:14 と解釈される
                $parsed = $date_parse($datetimestring . '0101T00:00:00');
                if (!$parsed['error_count']) {
                    $parsed['warnings'][] = 'add month,day';
                    return $parsed;
                }
                return $parsed;
            }

            return $parsed;
        })($datetimestring);

        if ($parsed['error_count']) {
            return null;
        }
        // date_parse は妥当でない日付はエラーではなく警告扱い（2015-09-31 等）
        if ($parsed['has:Y'] && $parsed['has:M'] && $parsed['has:D'] && !checkdate($parsed['month'], $parsed['day'], $parsed['year'])) {
            return null;
        }

        // 得られた値でマッチングすれば元となる文字列が取得できる
        $parsed['monthF'] = EN_MONTH_LONG[$parsed['month']] ?? '';
        $parsed['monthM'] = EN_MONTH_SHORT[$parsed['month']] ?? '';
        $parsed['dayS'] = (new \NumberFormatter('en_US', \NumberFormatter::ORDINAL))->format($parsed['day'] ?: 0);
        $parsed['fractionV'] = substr($parsed['fraction'], 2);
        $regex = [
            'Y' => "(?<Y>{$parsed['year']})?          (?<dY>[^0-9a-z]+)?",
            'M' => "(?<M>(0?{$parsed['month']})|({$parsed['monthF']})|({$parsed['monthM']}))? (?<dM>[^0-9]+)?",
            'D' => "(?<D>(0?{$parsed['dayS']})|(0?{$parsed['day']}))?                         (?<dD>[^0-9]+)?",
            'h' => "(?<h>0?{$parsed['hour']})?        (?<dh>[^0-9]+)?",
            'm' => "(?<m>0?{$parsed['minute']})?      (?<dm>[^0-9]+)?",
            's' => "(?<s>0?{$parsed['second']})?      (?<ds>[^0-9]+)?",
            'f' => "(?<f>0?{$parsed['fractionV']}0*)? (?<df>[^0-9]+)?",
            'z' => "(?<z>[+\-]\d{1,2}:?\d{1,2})?      (?<dz>[^0-9]+)?",
        ];
        $formats = [
            'ja-jp' => "^{$regex['Y']}{$regex['M']}{$regex['D']}{$regex['h']}{$regex['m']}{$regex['s']}{$regex['f']}{$regex['z']}$",
            'en-us' => "^{$regex['M']}{$regex['D']}{$regex['Y']}{$regex['h']}{$regex['m']}{$regex['s']}{$regex['f']}{$regex['z']}$",
            'en-gb' => "^{$regex['D']}{$regex['M']}{$regex['Y']}{$regex['h']}{$regex['m']}{$regex['s']}{$regex['f']}{$regex['z']}$",
        ];
        foreach ($formats as $format) {
            if (preg_match("#$format#ixu", $datetimestring, $matches, PREG_UNMATCHED_AS_NULL)) {
                break;
            }
        }
        if (!$matches) {
            $parsed['errors'][] = 'unmatch regex';
            return null;
        }

        $parsed += [
            'Y' => strlen($matches['Y'] ?? '') ? $matches['Y'] : null,
            'M' => strlen($matches['M'] ?? '') ? $matches['M'] : null,
            'D' => strlen($matches['D'] ?? '') ? $matches['D'] : null,
            'h' => strlen($matches['h'] ?? '') ? $matches['h'] : null,
            'm' => strlen($matches['m'] ?? '') ? $matches['m'] : null,
            's' => strlen($matches['s'] ?? '') ? $matches['s'] : null,
            'f' => strlen($matches['f'] ?? '') ? $matches['f'] : null,
            'z' => strlen($matches['z'] ?? '') ? $matches['z'] : null,
        ];

        $parts = array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);
        $parts['Y'] = $parsed['Y'] === null ? '' : 'Y';
        $parts['M'] = $parsed['M'] === null ? '' : [1 => 'n', 2 => 'm', 3 => 'M'][strlen($parts['M'])] ?? 'F';
        $parts['D'] = $parsed['D'] === null ? '' : [1 => 'j', 2 => 'd', 3 => 'jS'][strlen($parts['D'])] ?? 'dS';
        $parts['h'] = $parsed['h'] === null ? '' : (strlen($parts['h']) === 1 ? 'G' : 'H');
        $parts['m'] = $parsed['m'] === null ? '' : 'i'; // ゼロなし分フォーマットは存在しない
        $parts['s'] = $parsed['s'] === null ? '' : 's'; // ゼロなし秒フォーマットは存在しない
        $parts['f'] = $parsed['f'] === null ? '' : (strlen($parts['f']) > 3 ? 'u' : 'v');
        $parts['z'] = $parsed['z'] === null ? '' : (strpos($parts['z'], ':') !== false ? 'P' : 'O');

        foreach (['dY', 'dM', 'dD', 'dh', 'dm', 'ds', 'df', 'dz'] as $d) {
            $parts[$d] = implode('', array_map(fn($v) => ctype_alpha($v) ? "\\$v" : $v, str_split($parts[$d] ?? '')));
        }

        return implode('', $parts);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_timestamp') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_timestamp'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_timestamp')) {
    /**
     * 日時的なものをよしなにタイムスタンプに変換する
     *
     * マイクロ秒にも対応している。つまり返り値は int か float になる。
     * また、相対指定の +1 month の月末問題は起きないようにしてある。
     *
     * かなり適当に和暦にも対応している。
     * さらに必要に迫られてかなり特殊な対応を行っているので Example を参照。
     *
     * Example:
     * ```php
     * // 普通の日時文字列
     * that(date_timestamp('2014/12/24 12:34:56'))->isSame(strtotime('2014/12/24 12:34:56'));
     * // 和暦
     * that(date_timestamp('昭和31年12月24日 12時34分56秒'))->isSame(strtotime('1956/12/24 12:34:56'));
     * // 相対指定
     * that(date_timestamp('2012/01/31 +1 month'))->isSame(strtotime('2012/02/29'));
     * that(date_timestamp('2012/03/31 -1 month'))->isSame(strtotime('2012/02/29'));
     * // マイクロ秒
     * that(date_timestamp('2014/12/24 12:34:56.789'))->isSame(1419392096.789);
     *
     * // ベース日時
     * $baseTimestamp = strtotime('2012/01/31');
     * // ベース日時の25日（strtotime の序数日付は first/last しか対応していないが、この関数は対応している）
     * that(date_timestamp('25th of this month', $baseTimestamp))->isSame(strtotime('2012/01/25'));
     * // ベース日時の第2月曜（strtotime の序数曜日は 1st のような表記に対応していないが、この関数は対応している）
     * that(date_timestamp('2nd monday of this month', $baseTimestamp))->isSame(strtotime('2012/01/09'));
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string|int|float|\DateTimeInterface $datetimedata 日時データ
     * @param int|null $baseTimestamp 日時データ
     * @return int|float|null タイムスタンプ。パース失敗時は null
     */
    function date_timestamp($datetimedata, $baseTimestamp = null)
    {
        if ($datetimedata instanceof \DateTimeInterface) {
            return $datetimedata->getTimestamp() + $datetimedata->format('u') / 1000 / 1000;
        }

        $DAY1 = 60 * 60 * 24;
        $ORDINAL_WORDS = [
            '1st'  => 'first',
            '2nd'  => 'second',
            '3rd'  => 'third',
            '4th'  => 'fourth',
            '5th'  => 'fifth',
            '6th'  => 'sixth',
            '7th'  => 'seventh',
            '8th'  => 'eighth',
            '9th'  => 'ninth',
            '10th' => 'tenth',
            '11th' => 'eleventh',
            '12th' => 'twelfth',
        ];

        $ordinal_day = null;
        $oddeven = null;
        if (is_string($datetimedata) || (is_object($datetimedata) && method_exists($datetimedata, '__toString'))) {
            // 全角を含めた trim
            $chars = "[\\x0-\x20\x7f\xc2\xa0\xe3\x80\x80]";
            $datetimedata = preg_replace("/\A{$chars}++|{$chars}++\z/u", '', $datetimedata);

            // 和暦を西暦に置換
            $jpnames = array_merge(array_column(JP_ERA, 'name'), array_column(JP_ERA, 'abbr'));
            $datetimedata = preg_replace_callback('/^(' . implode('|', $jpnames) . ')(\d{1,2}|元)/u', function ($matches) {
                [, $era, $year] = $matches;
                $eratime = array_find(JP_ERA, function ($v) use ($era) {
                    if (in_array($era, [$v['name'], $v['abbr']], true)) {
                        return $v['since'];
                    }
                }, false);
                return idate('Y', $eratime) + ($year === '元' ? 1 : $year) - 1;
            }, $datetimedata);

            // 単位文字列を置換
            $datetimedata = strtr($datetimedata, [
                '　'    => ' ',
                '西暦' => '',
                '年'   => '/',
                '月'   => '/',
                '日'   => ' ',
                '時'   => ':',
                '分'   => ':',
                '秒'   => '',
            ]);
            $datetimedata = trim($datetimedata, " \t\n\r\0\x0B:/");

            // 1st, 2nd, 3rd, 4th dayname の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+(sun|mon|tues?|wed(nes)?|thu(rs)?|fri|sat(ur)?)day)#u', function ($matches) use ($ORDINAL_WORDS) {
                if (!isset($ORDINAL_WORDS[$matches[1]])) {
                    return $matches[0];
                }

                return $ORDINAL_WORDS[$matches[1]] . $matches[4];
            }, $datetimedata);

            // 1st, 2nd, 3rd, 4th day の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+day)?#ui', function ($matches) use (&$ordinal_day) {
                if ($matches[1] !== (new \NumberFormatter('en', \NumberFormatter::ORDINAL))->format($matches[2])) {
                    return $matches[0];
                }

                $ordinal_day = $matches[2];
                return 'first day';
            }, $datetimedata);

            // odd, even の対応
            $datetimedata = preg_replace_callback('#(odd|even)\s+#ui', function ($matches) use (&$oddeven) {
                $oddeven = $matches[1];
                return 'this ';
            }, $datetimedata);
        }

        // 数値4桁は年と解釈されるように
        if (preg_match('/^[0-9]{4}$/', $datetimedata)) {
            $datetimedata .= '-01-01';
        }

        // 数値系はタイムスタンプとみなす
        if (ctype_digit("$datetimedata")) {
            return (int) $datetimedata;
        }
        if (is_numeric($datetimedata)) {
            return (float) $datetimedata;
        }

        // strtotime と date_parse の合せ技で変換
        $baseTimestamp ??= time();
        $timestamp = strtotime($datetimedata, $baseTimestamp);
        $parts = date_parse($datetimedata);
        if ($timestamp === false || $parts['error_count']) {
            return null;
        }

        if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
            if (!isset($parts['relative'])) {
                return null;
            }
            $parts['year'] = idate('Y', $baseTimestamp);
            $parts['month'] = idate('m', $baseTimestamp);
            $parts['day'] = idate('d', $baseTimestamp);
        }

        if ($ordinal_day) {
            $timestamp += ($ordinal_day - 1) * $DAY1;
        }

        if ($oddeven !== null) {
            $idateW2 = idate('W', $timestamp) % 2;
            if (($oddeven === 'odd' && $idateW2 === 0) || ($oddeven === 'even' && $idateW2 === 1)) {
                $timestamp += $DAY1 * 7;
            }
        }

        $relative = $parts['relative'] ?? [];
        if (true
            && !isset($relative['weekday'])            // 週指定があるとかなり特殊で初日末日が意味を為さない
            && !isset($relative['first_day_of_month']) // first day 指定があるなら初日確定
            && !isset($relative['last_day_of_month'])  // last day 指定があるなら末日確定
        ) {
            if ($relative['year'] ?? false) {
                $parts['year'] += $relative['year'];
            }
            if ($relative['month'] ?? false) {
                $parts['month'] += $relative['month'];
                $parts['year'] += intdiv($parts['month'], 12);
                $parts['month'] %= 12;
                $parts['month'] += $parts['month'] <= 0 ? 12 : 0;
            }

            if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
                $timestamp = strtotime(date('Y-m-t H:i:s', $timestamp - $DAY1 * 4));
            }
        }

        if ($parts['fraction']) {
            $timestamp += ($timestamp >= 0 ? +$parts['fraction'] : -$parts['fraction']);
        }
        return $timestamp;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\date_validate') || (new \ReflectionFunction('ryunosuke\\ltsv\\date_validate'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\date_validate')) {
    /**
     * 日時文字列のバリデーション
     *
     * 存在しない日付・時刻・相対指定などは全て不可。
     * あくまで「2014/12/24 12:34:56」のような形式と妥当性だけでチェックする。
     * $overhour 引数で 27:00 のような拡張時刻も許容させることができる（6 を指定すればいわゆる30時間制になる）。
     *
     * 日時形式は結構複雑なので「正しいはずだがなぜか false になる」という事象が頻発する。
     * その時、調査が大変（どの段階で false になっているか分からない）なので＠で抑制しつつも内部的には user_error を投げている。
     * このエラーは error_get_last で取得可能だが、行儀の悪い（＠抑制を見ない）エラーハンドラが設定されていると例外として送出されることがあるので注意。
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string $datetime_string 日付形式の文字列
     * @param string $format フォーマット文字列
     * @param int $overhour 24時以降をどこまで許すか
     * @return bool valid な日時なら true
     */
    function date_validate($datetime_string, $format = 'Y/m/d H:i:s', $overhour = 0)
    {
        $inrange = fn($value, $min, $max) => $min <= $value && $value <= $max;

        try {
            $parsed = date_parse_from_format($format, $datetime_string);

            if ($parsed['error_count']) {
                throw new \ErrorException(array_sprintf($parsed['errors'], '#%2$s %1$s', "\n"));
            }

            ['year' => $year, 'month' => $month, 'day' => $day] = $parsed;

            if ($year !== false && $month !== false && $day !== false && !checkdate($month, $day, $year)) {
                throw new \ErrorException("invalid date '$year-$month-$day'");
            }
            elseif ($year !== false && !$inrange($year, 0, 9999)) {
                // 現状のパラメ－タで 0~9999 以外の年が来ることはない
                throw new \ErrorException("invalid year '$year'"); // @codeCoverageIgnore
            }
            elseif ($month !== false && !$inrange($month, 1, 12)) {
                throw new \ErrorException("invalid month '$month'");
            }
            elseif ($day !== false && !$inrange($day, 1, 31)) {
                throw new \ErrorException("invalid day '$day'");
            }

            ['hour' => $hour, 'minute' => $minute, 'second' => $second] = $parsed;

            if ($hour !== false && !$inrange($hour, 0, 23 + $overhour)) {
                throw new \ErrorException("invalid hour '$hour'");
            }
            elseif ($minute !== false && !$inrange($minute, 0, 59)) {
                throw new \ErrorException("invalid minute '$minute'");
            }
            elseif ($second !== false && !$inrange($second, 0, 59)) {
                throw new \ErrorException("invalid second '$second'");
            }

            return true;
        }
        catch (\Throwable $t) {
            @trigger_error($t->getMessage());
            return false;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\now') || (new \ReflectionFunction('ryunosuke\\ltsv\\now'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\now')) {
    /**
     * 現在日時を float で返す
     *
     * microtime(true) と同じ。
     * ただし、引数 $persistence を true(デフォルト) にすると以降の呼び出しですべて同じ値を返すようになる。
     *
     * Example:
     * ```php
     * // 現在時刻
     * $now = now();
     * sleep(1);
     * // 1秒経っても同じ値を返す
     * that(now())->is($now);
     * // false を与えると新しい時刻を返す
     * that(now(false))->isNot($now);
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param bool $persistence 固定化フラグ
     * @return float 現在日時
     */
    function now($persistence = true)
    {
        static $now = null;
        if ($now === null || !$persistence) {
            $now = microtime(true);
        }
        return $now;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\add_error_handler') || (new \ReflectionFunction('ryunosuke\\ltsv\\add_error_handler'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\add_error_handler')) {
    /**
     * エラーハンドラを追加する
     *
     * 追加したエラーハンドラが false を返すと標準のエラーハンドラではなく、直近の設定されていたエラーハンドラに移譲される。
     * （直近にエラーハンドラが設定されていなかったら標準ハンドラになる）。
     *
     * 「局所的にエラーハンドラを変更したいけど特定の状況は設定済みハンドラへ流したい」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // @ 付きなら元々のハンドラに移譲、@ なしなら何らかのハンドリングを行う例
     * add_error_handler(function ($errno) {
     *     if (!(error_reporting() & $errno)) {
     *         // この false はマニュアルにある「この関数が FALSE を返した場合は、通常のエラーハンドラが処理を引き継ぎます」ではなく、
     *         // 「さっきまで設定されていたエラーハンドラが処理を引き継ぎます」という意味になる
     *         return false;
     *     }
     *     // do something
     * });
     * // false の扱いが異なるだけでその他の挙動はすべて set_error_handler と同じなので restore_error_handler で戻せる
     * restore_error_handler();
     * ```
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param callable $handler エラーハンドラ
     * @param int $error_types エラータイプ
     * @return callable|null 直近に設定されていたエラーハンドラ（未設定の場合は null）
     */
    function add_error_handler($handler, $error_types = \E_ALL | \E_STRICT)
    {
        $already = set_error_handler(static function () use ($handler, &$already) {
            $result = $handler(...func_get_args());
            if ($result === false && $already !== null) {
                return $already(...func_get_args());
            }
            return $result;
        }, $error_types);
        return $already;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\backtrace') || (new \ReflectionFunction('ryunosuke\\ltsv\\backtrace'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\backtrace')) {
    /**
     * 特定条件までのバックトレースを取得する
     *
     * 第2引数 $options を満たすトレース以降を返す。
     * $options は ['$trace の key' => "条件"] を渡す。
     * 条件は文字列かクロージャで、文字列の場合は緩い一致、クロージャの場合は true を返した場合にそれ以降を返す。
     *
     * Example:
     * ```php
     * function f001 () {return backtrace(0, ['function' => __NAMESPACE__ . '\\f002', 'limit' => 2]);}
     * function f002 () {return f001();}
     * function f003 () {return f002();}
     * $traces = f003();
     * // limit 指定してるので2個
     * that($traces)->count(2);
     * // 「function が f002 以降」を返す
     * that($traces[0])->subsetEquals([
     *     'function' => __NAMESPACE__ . '\\f002'
     * ]);
     * that($traces[1])->subsetEquals([
     *     'function' => __NAMESPACE__ . '\\f003'
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param int $flags debug_backtrace の引数
     * @param array $options フィルタ条件
     * @return array バックトレース
     */
    function backtrace($flags = \DEBUG_BACKTRACE_PROVIDE_OBJECT, $options = [])
    {
        $result = [];
        $traces = debug_backtrace($flags);
        foreach ($traces as $n => $trace) {
            foreach ($options as $key => $val) {
                if (!isset($trace[$key])) {
                    continue;
                }

                if ($val instanceof \Closure) {
                    $break = $val($trace[$key]);
                }
                else {
                    $break = $trace[$key] == $val;
                }
                if ($break) {
                    $result = array_slice($traces, $n);
                    break 2;
                }
            }
        }

        // offset, limit は特別扱いで千切り指定
        if (isset($options['offset']) || isset($options['limit'])) {
            $result = array_slice($result, $options['offset'] ?? 0, $options['limit'] ?? count($result));
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\error') || (new \ReflectionFunction('ryunosuke\\ltsv\\error'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\error')) {
    /**
     * エラー出力する
     *
     * 第1引数 $message はそれらしく文字列化されて出力される。基本的にはあらゆる型を与えて良い。
     *
     * 第2引数 $destination で出力対象を指定する。省略すると error_log 設定に従う。
     * 文字列を与えるとファイル名とみなし、ファイルに追記される。
     * ファイルを開くが、**ファイルは閉じない**。閉じ処理は php の終了処理に身を任せる。
     * したがって閉じる必要がある場合はファイルポインタを渡す必要がある。
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param string|mixed $message 出力メッセージ
     * @param resource|string|mixed $destination 出力先
     * @return int 書き込んだバイト数
     */
    function error($message, $destination = null)
    {
        static $persistences = [];

        $time = date('d-M-Y H:i:s e');
        $content = stringify($message);
        $location = '';
        if (!($message instanceof \Exception || $message instanceof \Throwable)) {
            foreach (debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS) as $trace) {
                if (isset($trace['file'], $trace['line'])) {
                    $location = " in {$trace['file']} on line {$trace['line']}";
                    break;
                }
            }
        }
        $line = "[$time] PHP Log:  $content$location\n";

        if ($destination === null) {
            $destination = blank_if(ini_get('error_log'), 'php://stderr');
        }

        if ($destination === 'syslog') {
            syslog(LOG_INFO, $message);
            return strlen($line);
        }

        if (is_resource($destination)) {
            $fp = $destination;
        }
        elseif (is_string($destination)) {
            if (!isset($persistences[$destination])) {
                $persistences[$destination] = fopen($destination, 'a');
            }
            $fp = $persistences[$destination];
        }

        if (empty($fp)) {
            throw new \InvalidArgumentException('$destination must be resource or string.');
        }

        flock($fp, LOCK_EX);
        fwrite($fp, $line);
        flock($fp, LOCK_UN);

        return strlen($line);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\set_all_error_handler') || (new \ReflectionFunction('ryunosuke\\ltsv\\set_all_error_handler'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\set_all_error_handler')) {
    /**
     * あらゆるエラーをハンドルする
     *
     * 実質的には set_error_handler+set_exception_handler+register_shutdown_function してるだけ。
     * あと小細工して初動エラーも拾うがあまり気にしなくてよい。
     *
     * ハンドラの引数は Throwable 固定（エラーの場合は Error に変換されてコールされる）。
     * ハンドラが true/null を返すと設定前（ない場合は標準）のハンドラがコールされる。
     * 実用上は「ログるかログらないか」くらいの差でしかない。
     *
     * @package ryunosuke\Functions\Package\errorfunc
     * @codeCoverageIgnore カバレッジ不可
     */
    function set_all_error_handler(
        /** 実行されるクロージャ */ \Closure $handler,
        /** エラー抑制演算子をハンドリングするか */ bool $atmark_error = false,
        /** fatal 用に予約するサイズ */ int $reserved_byte = 0,
    ): /** キャンセルする callable */ callable
    {
        $result = new class($handler, $atmark_error, $reserved_byte) {
            private static array  $instances         = [];
            private static string $reservedMemory    = '';
            private static bool   $regsteredShutdown = false;

            private $handler;
            private $error_handler;
            private $exception_handler;

            public function __construct(\Closure $handler, bool $atmark_error, int $reserved_byte)
            {
                self::$instances[spl_object_id($this)] = $this;
                if (strlen(self::$reservedMemory) < $reserved_byte) {
                    self::$reservedMemory = str_repeat('x', $reserved_byte);
                }

                $this->handler = $handler;

                $this->error_handler = set_error_handler(function ($errno, $errstr, $errfile, $errline) use ($atmark_error) {
                    if (!$atmark_error && !(error_reporting() & $errno)) {
                        return false;
                    }

                    $default = ($this->handler)($this->newError($errstr, 0, $errno, $errfile, $errline)) ?? true;
                    if ($default) {
                        return ($this->error_handler)($errno, $errstr, $errfile, $errline);
                    }
                }) ?? fn() => false;

                $this->exception_handler = set_exception_handler(function (\Throwable $t) {
                    $default = ($this->handler)($t) ?? true;
                    if ($default) {
                        return ($this->exception_handler)($t);
                    }
                }) ?? fn($t) => throw $t;

                if (!self::$regsteredShutdown) {
                    self::$regsteredShutdown = true;
                    register_shutdown_function(function () {
                        self::$reservedMemory = '';
                        // php は循環参照を片付けずに memory size エラーを飛ばすのでやっておく意味はある
                        gc_collect_cycles();
                        foreach (self::$instances as $instance) {
                            // 通常の実行時エラーは set_error_handler でハンドリングされているが
                            // - 実行時ではないコンパイル時エラー
                            // - エラーハンドラが呼ばれない実行時エラー（実行メモリ/時間など）
                            // が存在するので個別にハンドリングしないと呼ばれる機会が失われる
                            if (($error = error_get_last()) !== null) {
                                if (false
                                    || in_array($error['type'], [E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR, E_CORE_WARNING, E_COMPILE_WARNING], true)
                                    || strpos($error['message'], 'Allowed memory size') === 0
                                    || strpos($error['message'], 'Maximum execution time') === 0
                                ) {
                                    ($instance->handler)($instance->newError($error['message'], 1, $error['type'], $error['file'], $error['line']));
                                }
                            }
                        }
                    });
                }
            }

            public function __invoke()
            {
                restore_error_handler();
                restore_exception_handler();
                unset(self::$instances[spl_object_id($this)]);
            }

            public function newError($message, $code, $errno, $errfile, $errline, $previous = null)
            {
                return new class($message, $code, $errno, $errfile, $errline, $previous) extends \Error {
                    private int $severity;

                    public function __construct($message, $code, $errno, $errfile, $errline, $previous)
                    {
                        parent::__construct($message, $code, $previous);

                        $this->file = $errfile;
                        $this->line = $errline;

                        $this->severity = $errno;
                    }

                    public function getSeverity(): int
                    {
                        return $this->severity;
                    }
                };
            }
        };

        // 初動エラーが error_get_last() で取得できることがある
        if (($error = error_get_last()) !== null) {
            // 初動エラーはスクリプト無関係なので line:0 で発生される
            if ($error['line'] === 0) {
                $handler($result->newError($error['message'], -1, $error['type'], $error['file'], $error['line']));
                // 以後一度もエラーがないと shutdown で引っかかってしまう
                error_clear_last();
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\set_error_exception_handler') || (new \ReflectionFunction('ryunosuke\\ltsv\\set_error_exception_handler'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\set_error_exception_handler')) {
    /**
     * エラーを ErrorException に変換するハンドラを設定する
     *
     * かなり局所的だが、使用するケースは結構ある。
     * 戻り値として callable を返すので、それを呼べば restore される。
     * あるいは参照が切れれば RAII で restore される。
     *
     * Example:
     * ```php
     * // 呼ぶとエラーが例外に変換されるようになる
     * $restore = set_error_exception_handler();
     * try {
     *     $array = [];
     *     $dummy = $array['undefined'];
     * }
     * catch (\Throwable $t) {
     *     // undefined 例外が飛ぶ
     *     that($t)->isInstanceof(\ErrorException::class);
     * }
     * finally {
     *     // こうするとハンドラが戻る
     *     $restore();
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param int $error_levels エラーレベル
     * @param bool $handle_atmark_error エラー抑制時もハンドリングするか
     * @return callable restore するコールバック
     */
    function set_error_exception_handler($error_levels = \E_ALL, $handle_atmark_error = false)
    {
        set_error_handler(static function ($errno, $errstr, $errfile, $errline) use ($handle_atmark_error) {
            if (!$handle_atmark_error && !(error_reporting() & $errno)) {
                return false;
            }
            throw new \ErrorException($errstr, 0, $errno, $errfile, $errline);
        }, $error_levels);

        return finalize('restore_error_handler');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\set_trace_logger') || (new \ReflectionFunction('ryunosuke\\ltsv\\set_trace_logger'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\set_trace_logger')) {
    /**
     * メソッド呼び出しロガーを仕込む
     *
     * この関数はかなり実験的なもので、互換性を考慮しない。
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param \Psr\Log\LoggerInterface $logger 書き出すファイル名
     * @return mixed
     */
    function set_trace_logger($logger, string $target)
    {
        $GLOBALS['___trace_log_internal'] = function (string $file, int $line, string $class, string $method, array $args) use ($logger) {
            $logger->debug("", [
                'id'     => $_SERVER['UNIQUE_ID'] ?? str_pad($_SERVER['REQUEST_TIME_FLOAT'], 15, STR_PAD_RIGHT),
                'class'  => $class,
                'method' => $method,
                'args'   => $args,
                'file'   => $file,
                'line'   => $line,
            ]);
        };

        return register_autoload_function(function ($classname, $filename, $contents) use ($target) {
            if (preg_match($target, $classname)) {
                $contents ??= file_get_contents($filename);
                $contents = preg_replace_callback('#((final|public|protected|private|static)\s+){0,3}function\s+[_0-9a-z]+?\([^{]+\{#usmi', function ($m) {
                    return $m[0] . "(\$GLOBALS['___trace_log_internal'] ?? fn() => null)(__FILE__, __LINE__ - 1, __CLASS__, __FUNCTION__, func_get_args());";
                }, $contents);
                return $contents;
            }
        });
    }
}

assert(!function_exists('ryunosuke\\ltsv\\stacktrace') || (new \ReflectionFunction('ryunosuke\\ltsv\\stacktrace'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\stacktrace')) {
    /**
     * スタックトレースを文字列で返す
     *
     * `(new \Exception())->getTraceAsString()` と実質的な役割は同じ。
     * ただし、 getTraceAsString は引数が Array になったりクラス名しか取れなかったり微妙に使い勝手が悪いのでもうちょっと情報量を増やしたもの。
     *
     * 第1引数 $traces はトレース的配列を受け取る（`(new \Exception())->getTrace()` とか）。
     * 未指定時は debug_backtrace() で採取する。
     *
     * 第2引数 $option は文字列化する際の設定を指定する。
     * 情報量が増える分、機密も含まれる可能性があるため、 mask オプションで塗りつぶすキーや引数名を指定できる（クロージャの引数までは手出ししないため留意）。
     * limit と format は比較的指定頻度が高いかつ互換性維持のため配列オプションではなく直に渡すことが可能になっている。
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param ?array $traces debug_backtrace 的な配列
     * @param int|string|array $option オプション
     * @return string|array トレース文字列（delimiter オプションに null を渡すと配列で返す）
     */
    function stacktrace($traces = null, $option = [])
    {
        if (is_int($option)) {
            $option = ['limit' => $option];
        }
        elseif (is_string($option)) {
            $option = ['format' => $option];
        }

        $option += [
            'format'    => '%s:%s %s', // 文字列化するときの sprintf フォーマット
            'args'      => true,       // 引数情報を埋め込むか否か
            'limit'     => 16,         // 配列や文字列を千切る長さ
            'delimiter' => "\n",       // スタックトレースの区切り文字（null で配列になる）
            'mask'      => ['#^password#', '#^secret#', '#^credential#', '#^credit#'],
        ];
        $limit = $option['limit'];
        $maskregexs = (array) $option['mask'];
        $mask = static function ($key, $value) use ($maskregexs) {
            if (!is_string($value)) {
                return $value;
            }
            foreach ($maskregexs as $regex) {
                if (preg_match($regex, $key)) {
                    return str_repeat('*', strlen($value));
                }
            }
            return $value;
        };

        $stringify = static function ($value) use ($limit, $mask) {
            // 再帰用クロージャ
            $export = static function ($value, $nest = 0, $parents = []) use (&$export, $limit, $mask) {
                // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
                foreach ($parents as $parent) {
                    if ($parent === $value) {
                        return var_export('*RECURSION*', true);
                    }
                }
                // 配列は連想判定したり再帰したり色々
                if (is_array($value)) {
                    $parents[] = $value;
                    $flat = $value === array_values($value);
                    $kvl = [];
                    foreach ($value as $k => $v) {
                        if (count($kvl) >= $limit) {
                            $kvl[] = sprintf('...(more %d length)', count($value) - $limit);
                            break;
                        }
                        $kvl[] = ($flat ? '' : $k . ':') . $export(call_user_func($mask, $k, $v), $nest + 1, $parents);
                    }
                    return ($flat ? '[' : '{') . implode(', ', $kvl) . ($flat ? ']' : '}');
                }
                // オブジェクトは単にプロパティを配列的に出力する
                elseif (is_object($value)) {
                    $parents[] = $value;
                    return get_class($value) . $export(object_properties($value), $nest, $parents);
                }
                // 文字列はダブルクォート
                elseif (is_string($value)) {
                    if (($strlen = strlen($value)) > $limit) {
                        $value = substr($value, 0, $limit) . sprintf('...(more %d length)', $strlen - $limit);
                    }
                    return str_quote($value);
                }
                // それ以外は stringify
                else {
                    return stringify($value);
                }
            };

            return $export($value);
        };

        $traces ??= array_slice(debug_backtrace(), 1);
        $result = [];
        foreach ($traces as $i => $trace) {
            // メソッド内で関数定義して呼び出したりすると file が無いことがある（かなりレアケースなので無視する）
            if (!isset($trace['file'])) {
                continue; // @codeCoverageIgnore
            }

            $file = $trace['file'];
            $line = $trace['line'];
            if (strpos($trace['file'], "eval()'d code") !== false && ($traces[$i + 1]['function'] ?? '') === 'eval') {
                $file = $traces[$i + 1]['file'];
                $line = $traces[$i + 1]['line'] . "." . $trace['line'];
            }

            if (isset($trace['type'])) {
                $callee = $trace['class'] . $trace['type'] . $trace['function'];
                if ($option['args'] && $maskregexs && method_exists($trace['class'], $trace['function'])) {
                    $ref = new \ReflectionMethod($trace['class'], $trace['function']);
                }
            }
            else {
                $callee = $trace['function'];
                if ($option['args'] && $maskregexs && function_exists($callee)) {
                    $ref = new \ReflectionFunction($trace['function']);
                }
            }
            $args = [];
            if ($option['args']) {
                $args = $trace['args'] ?? [];
                if (isset($ref)) {
                    $params = $ref->getParameters();
                    foreach ($params as $n => $param) {
                        if (array_key_exists($n, $args)) {
                            $args[$n] = $mask($param->getName(), $args[$n]);
                        }
                    }
                }
            }
            $callee .= '(' . implode(', ', array_map($stringify, $args)) . ')';

            $result[] = sprintf($option['format'], $file, $line, $callee);
        }
        if ($option['delimiter'] === null) {
            return $result;
        }
        return implode($option['delimiter'], $result);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\process') || (new \ReflectionFunction('ryunosuke\\ltsv\\process'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\process')) {
    /**
     * proc_open ～ proc_close の一連の処理を行う
     *
     * 標準入出力は文字列で受け渡しできるが、決め打ち実装なのでいわゆる対話型なプロセスは起動できない。
     * また、標準入出力はリソース型を渡すこともできる。
     *
     * Example:
     * ```php
     * // サンプル実行用ファイルを用意
     * $phpfile = sys_get_temp_dir() . '/rf-sample.php';
     * file_put_contents($phpfile, "<?php
     *     fwrite(STDOUT, fgets(STDIN));
     *     fwrite(STDERR, 'err');
     *     exit((int) ini_get('max_file_uploads'));
     * ");
     * // 引数と標準入出力エラーを使った単純な例
     * $rc = process(PHP_BINARY, [
     *     '-d' => 'max_file_uploads=123',
     *     $phpfile,
     * ], 'out', $stdout, $stderr);
     * that($rc)->isSame(123); // -d で与えた max_file_uploads で exit してるので 123
     * that($stdout)->isSame('out'); // 標準出力に標準入力を書き込んでいるので "out" が格納される
     * that($stderr)->isSame('err'); // 標準エラーに書き込んでいるので "err" が格納される
     * ```
     *
     * @package ryunosuke\Functions\Package\exec
     *
     * @param string $command 実行コマンド。php7.4 未満では escapeshellcmd される
     * @param array|string $args コマンドライン引数。php7.4 未満では文字列はそのまま結合され、配列は escapeshellarg された上でキーと結合される
     * @param string|resource $stdin 標準入力（string を渡すと単純に読み取れられる。resource を渡すと fread される）
     * @param string|resource $stdout 標準出力（string を渡すと参照渡しで格納される。resource を渡すと fwrite される）
     * @param string|resource $stderr 標準エラー（string を渡すと参照渡しで格納される。resource を渡すと fwrite される）
     * @param ?string $cwd 作業ディレクトリ
     * @param ?array $env 環境変数
     * @param ?array $options その他の追加オプション
     * @return int リターンコード
     */
    function process($command, $args = [], $stdin = '', &$stdout = '', &$stderr = '', $cwd = null, array $env = null, $options = null)
    {
        $rc = process_async($command, $args, $stdin, $stdout, $stderr, $cwd, $env, $options)();
        if ($rc === -1) {
            // どうしたら失敗するのかわからない
            throw new \RuntimeException("$command exit failed."); // @codeCoverageIgnore
        }
        return $rc;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\process_async') || (new \ReflectionFunction('ryunosuke\\ltsv\\process_async'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\process_async')) {
    /**
     * proc_open ～ proc_close の一連の処理を行う（非同期版）
     *
     * @package ryunosuke\Functions\Package\exec
     * @see process()
     *
     * @param string $command 実行コマンド
     * @param array|string $args コマンドライン引数。文字列はそのまま結合され、配列は escapeshellarg された上でキーと結合される
     * @param string|resource $stdin 標準入力（string を渡すと単純に読み取れられる。resource を渡すと fread される）
     * @param string|resource $stdout 標準出力（string を渡すと参照渡しで格納される。resource を渡すと fwrite される）
     * @param string|resource $stderr 標準エラー（string を渡すと参照渡しで格納される。resource を渡すと fwrite される）
     * @param ?string $cwd 作業ディレクトリ
     * @param ?array $env 環境変数
     * @param ?array $options その他の追加オプション
     * @return \ProcessAsync|object プロセスオブジェクト
     */
    function process_async($command, $args = [], $stdin = '', &$stdout = '', &$stderr = '', $cwd = null, array $env = null, $options = null)
    {
        if (is_array($args)) {
            $statement = [$command];
            foreach ($args as $k => $v) {
                foreach (arrayize($v) as $vv) {
                    if (!is_int($k)) {
                        $statement[] = $k;
                    }
                    $statement[] = $vv;
                }
            }
        }
        else {
            $statement = escapeshellcmd($command) . " $args";
        }

        $options['wait-mode'] ??= DIRECTORY_SEPARATOR === '/' ? 'select' : 'polling';

        // Windows ではノンブロッキングパイプが実装されていない
        // 非常に無駄だがファイルに書き出してその差分をポーリングすることで出力判定を行っている
        if ($options['wait-mode'] === 'polling') {
            $proc = proc_open($statement, [
                0 => is_resource($stdin) ? $stdin : ['pipe', 'r'],
                1 => $out = tmpfile(),
                2 => $err = tmpfile(),
            ], $pipes, $cwd, $env, $options);
            $pipes[1] = $out;
            $pipes[2] = $err;
        }
        else {
            $proc = proc_open($statement, [
                0 => is_resource($stdin) ? $stdin : ['pipe', 'r'],
                1 => ['pipe', 'w'],
                2 => ['pipe', 'w'],
            ], $pipes, $cwd, $env, $options);
        }

        if ($proc === false) {
            // どうしたら失敗するのかわからない
            throw new \RuntimeException("$command start failed."); // @codeCoverageIgnore
        }

        if (!is_resource($stdin)) {
            fwrite($pipes[0], $stdin);
            fclose($pipes[0]);
        }
        if (!is_resource($stdout)) {
            $stdout = '';
        }
        if (!is_resource($stderr)) {
            $stderr = '';
        }

        stream_set_blocking($pipes[1], false);
        stream_set_blocking($pipes[2], false);
        stream_set_read_buffer($pipes[1], 4096);
        stream_set_read_buffer($pipes[2], 4096);

        return new class($proc, $pipes, $stdout, $stderr, $options) {
            private $proc;
            private $pipes;
            private $names;
            private $status;
            private $options;
            private $destructAction;
            private $completeAction;
            private $result;
            public  $stdout;
            public  $stderr;

            public function __construct($proc, $pipes, &$stdout, &$stderr, $options)
            {
                $this->proc = $proc;
                $this->pipes = $pipes;
                $this->stdout = &$stdout;
                $this->stderr = &$stderr;
                $this->options = $options;
                $this->destructAction = 'close';
            }

            public function __destruct()
            {
                if ($this->destructAction === 'close') {
                    $this->__invoke();
                }
                if ($this->destructAction === 'terminate') {
                    $this->terminate();
                }
            }

            public function __invoke()
            {
                if ($this->proc === null) {
                    return $this->result;
                }

                try {
                    /** @noinspection PhpStatementHasEmptyBodyInspection */
                    while ($this->update()) {
                        // noop
                    }
                }
                finally {
                    fclose($this->pipes[1]);
                    fclose($this->pipes[2]);
                    $rc = proc_close($this->proc);
                    assert($rc === $this->status['exitcode']);
                    $this->proc = null;
                }

                if ($this->completeAction) {
                    return $this->result = $this->completeAction->call($this);
                }

                return $this->result = $this->status['exitcode'];
            }

            public function setDestructAction($action): self
            {
                $this->destructAction = $action;
                return $this;
            }

            public function setCompleteAction($action): self
            {
                $this->completeAction = $action;
                return $this;
            }

            public function update(): bool
            {
                if ($this->proc === null) {
                    return false;
                }

                $this->status = proc_get_status($this->proc);

                $fds = [];
                if ($this->options['wait-mode'] === 'polling') {
                    // pipes は FD そのものなので名前管理して file_get_contents せずとも stream_get_contents で直接読めるはず
                    // が、fstat のサイズが変わることは確認できるものの、バッファされているのか fread で読むことはできなかった
                    $this->names ??= (function () {
                        return [
                            stream_get_meta_data($this->pipes[1])['uri'] => [$this->pipes[1], 0],
                            stream_get_meta_data($this->pipes[2])['uri'] => [$this->pipes[2], 0],
                        ];
                    })();
                    foreach ($this->names as $name => [$fp, &$pos]) {
                        /*
                        var_dump([
                            'ftell'    => ftell($fp),
                            'fsize'    => fstat($fp)['size'],
                            'contents' => stream_get_contents($fp),
                        ]);
                         */
                        $buffer = file_get_contents($name, false, null, $pos);
                        if ($len = strlen($buffer)) {
                            $fds[] = [$fp, $buffer];
                            $pos += $len;
                        }
                    }
                    if (!$fds && $this->status['running']) {
                        usleep(100_000);
                    }
                }
                else {
                    $read = [$this->pipes[1], $this->pipes[2]];
                    $write = $except = null;
                    if (stream_select($read, $write, $except, 1) === false) {
                        // （システムコールが別のシグナルによって中断された場合などに起こりえます）
                        throw new \RuntimeException('stream_select failed.'); // @codeCoverageIgnore
                    }
                    foreach ($read as $fp) {
                        $fds[] = [$fp, stream_get_contents($fp)];
                    }
                }

                foreach ($fds as [$fp, $buffer]) {
                    if ($fp === $this->pipes[1]) {
                        if (!is_resource($this->stdout)) {
                            $this->stdout .= $buffer;
                        }
                        else {
                            fwrite($this->stdout, $buffer);
                        }
                    }
                    elseif ($fp === $this->pipes[2]) {
                        if (!is_resource($this->stderr)) {
                            $this->stderr .= $buffer;
                        }
                        else {
                            fwrite($this->stderr, $buffer);
                        }
                    }
                }

                return $this->status['running'];
            }

            public function status(): array
            {
                return $this->status ?? proc_get_status($this->proc);
            }

            public function terminate(): bool
            {
                if ($this->proc === null) {
                    return !$this->status['running'];
                }

                $this->update();

                fclose($this->pipes[1]);
                fclose($this->pipes[2]);
                proc_terminate($this->proc);
                // terminate はシグナルを送るだけなので終了を待つ（さらに SIGTERM なので終わらないかもしれないので1秒ほどで打ち切る）
                for ($i = 0; $i < 100; $i++, usleep(10_000)) {
                    $this->status = proc_get_status($this->proc);
                    if (!$this->status['running']) {
                        break;
                    }
                }
                $this->proc = null;
                return !$this->status['running'];
            }
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\process_closure') || (new \ReflectionFunction('ryunosuke\\ltsv\\process_closure'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\process_closure')) {
    /**
     * クロージャを別プロセスで実行する
     *
     * process_parallel の単一クロージャ特化版。
     * クロージャを別プロセスでバックグラウンド実行して結果を返すオブジェクトを返す。
     * クロージャは独自の方法でエクスポートしてから実行するので可能な限り this bind は外したほうが良い。
     *
     * バックグラウンドで実行するので指定クロージャを実行中に別のことができる。
     * これはマルチコアを活かすのにも有用であるし、IO を伴う処理を効率よく実行できる。
     *
     * Example:
     * ```php
     * $hugefile1 = tempnam(sys_get_temp_dir(), 't');
     * $hugefile2 = tempnam(sys_get_temp_dir(), 't');
     * file_put_contents($hugefile1, str_repeat('x', 1024* 1024)); // もっとでかくないと効果は薄いがテストなのであまり大きくしない
     * file_put_contents($hugefile2, str_repeat('y', 1024* 1024));
     * // 超絶でかいファイルの sha1 を計算してる間に・・・
     * $hash1 = process_closure(static fn() => sha1_file($hugefile1));
     * $hash2 = process_closure(static fn() => sha1_file($hugefile2));
     * // ここで別のことができる（裏で処理は走っている）
     * // doSomething())
     * // 返り値オブジェクトをコールすると結果が得られる（この時、処理が未完なら待たされる）
     * that($hash1())->is('e37f4d5be56713044d62525e406d250a722647d6');
     * that($hash2())->is('2b6a7ad91a60e40a5fd37abe06e165dc7498b24e');
     *
     * // あるいは http リクエストを走らせている間に・・・
     * $start = microtime(true);
     * $response1 = process_closure(static fn($url) => file_get_contents($url), TESTWEBSERVER . '/delay/2');
     * $response2 = process_closure(static fn($url) => file_get_contents($url), TESTWEBSERVER . '/delay/2');
     * // 別のことができる（裏でリクエストは走っている）
     * // doSomething())
     * // 返り値オブジェクトをコールするとレスポンスが得られる
     * that($response1())->isNotEmpty();
     * that($response2())->isNotEmpty();
     * // トータルで2秒程度である（少なくとも 2 * 2 で4秒にはならない）
     * that(microtime(true) - $start)->break()->isBetween(2.0, 4.0);
     * ```
     *
     * @package ryunosuke\Functions\Package\exec
     *
     * @param \Closure $closure 非同期実行するクロージャ
     * @param mixed $args クロージャの引数
     * @param bool|int $throw exitcode で例外を投げるか（現在は bool のみ対応）
     * @param ?array $autoload 実行前に読み込むスクリプト。省略時は自動検出された vendor/autoload.php と function_configure/process.autoload
     * @param ?string $workdir ワーキングディレクトリ。省略時はテンポラリディレクトリ
     * @param ?array $options その他の追加オプション
     * @return \ProcessAsync|object プロセスオブジェクト
     */
    function process_closure($closure, $args = [], $throw = true, $autoload = null, $workdir = null, $env = null, $options = null)
    {
        static $storage = null;
        $storage ??= object_storage(__FUNCTION__);
        $closure_code = $storage[$closure] ??= var_export3($closure, true);

        $autoload = arrayize($autoload ?? array_merge([auto_loader()], function_configure('process.autoload')));
        $workdir ??= (sys_get_temp_dir() . '/rfpc');
        mkdir_p($workdir);

        $namespace = strlen(__CLASS__) ? __CLASS__ . '::' : __NAMESPACE__ . '\\';
        $maincode = '<?php
        $autoload = ' . var_export($autoload, true) . ';
        foreach ($autoload as $file) {
            require_once $file;
        }
        $stdin  = eval(stream_get_contents(STDIN));
        $timer  = ' . $namespace . 'cpu_timer();
        $return = ' . $closure_code . '(...$stdin);
        file_put_contents($argv[1], ' . $namespace . 'var_export3([$return, $timer->result(), memory_get_peak_usage()], ["outmode" => "file"]));
    ';
        file_put_contents($mainscript = sys_get_temp_dir() . '/process-' . sha1($maincode) . '.php', $maincode);

        $return = tempnam($workdir, 'return');

        $options ??= [];
        $ini = arrayize($options['ini'] ?? []);
        unset($options['ini']);

        $ini_args = [];
        foreach ($ini as $key => $value) {
            if (is_int($key)) {
                $ini_args[] = "-d$value";
            }
            else {
                $ini_args[] = "-d$key=$value";
            }
        }

        $process = process_async(php_binary(), [...$ini_args, $mainscript, $return], var_export3(arrayize($args), ["outmode" => "eval"]), $stdout, $stderr, $workdir, $env, $options);
        $process->setDestructAction('terminate');
        $process->setCompleteAction(function () use ($throw, $return) {
            /** @var $this \ProcessAsync */
            // 勝手プロセスじゃなくて php なので Fatal error のとき exitcode が非0なのは保証されている
            if ($throw && $this->status['exitcode']) {
                // が、php は設定次第で標準出力/エラーのどちらにも出力されうるので読み替えなければならない
                throw new \ErrorException(strlen($this->stderr) ? $this->stderr : $this->stdout, $this->status['exitcode']);
            }
            if (!filesize($return)) {
                return null;
            }
            $results = include $return;
            opcache_invalidate($return, true);
            $this->status['cpu'] = $results[1];
            $this->status['memory'] = $results[2];
            return $results[0];
        });
        return $process;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\process_parallel') || (new \ReflectionFunction('ryunosuke\\ltsv\\process_parallel'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\process_parallel')) {
    /**
     * 複数の callable を並列で実行する
     *
     * callable はクロージャも使用できるが、独自の方法でエクスポートしてから実行するので可能な限り this bind は外したほうが良い。
     *
     * Example:
     * ```php
     * # 単一のクロージャを複数の引数で回す
     * $t = microtime(true);
     * $result = process_parallel(static function ($arg1, $arg2) {
     *     usleep(1000 * 1000);
     *     fwrite(STDOUT, "this is stdout");
     *     fwrite(STDERR, "this is stderr");
     *     return $arg1 + $arg2;
     * }, ['a' => [1, 2], 'b' => [2, 3], [3, 4]]);
     * // 1000ms かかる処理を3本実行するが、トータル時間は 3000ms ではなくそれ以下になる（多少のオーバーヘッドはある）
     * that(microtime(true) - $t)->break()->lessThan(2.0);
     * // 実行結果は下記のような配列で返ってくる（その際キーは維持される）
     * that($result)->isSame([
     *     'a' => [
     *         'status' => 0,
     *         'stdout' => "this is stdout",
     *         'stderr' => "this is stderr",
     *         'return' => 3,
     *     ],
     *     'b' => [
     *         'status' => 0,
     *         'stdout' => "this is stdout",
     *         'stderr' => "this is stderr",
     *         'return' => 5,
     *     ],
     *     [
     *         'status' => 0,
     *         'stdout' => "this is stdout",
     *         'stderr' => "this is stderr",
     *         'return' => 7,
     *     ],
     * ]);
     * # 複数のクロージャを複数の引数で回す（この場合、引数のキーは合わせなければならない）
     * $t = microtime(true);
     * $result = process_parallel([
     *     'a' => static function ($arg1, $arg2) {
     *         usleep(300 * 1000);
     *         return $arg1 + $arg2;
     *     },
     *     'b' => static function ($arg1, $arg2) {
     *         usleep(500 * 1000);
     *         return $arg1 * $arg2;
     *     },
     *     static function ($arg) {
     *         usleep(1000 * 1000);
     *         exit($arg);
     *     },
     * ], ['a' => [1, 2], 'b' => [2, 3], [127]]);
     * // 300,500,1000ms かかる処理を3本実行するが、トータル時間は 1800ms ではなくそれ以下になる（多少のオーバーヘッドはある）
     * that(microtime(true) - $t)->break()->lessThan(1.5);
     * // 実行結果は下記のような配列で返ってくる（その際キーは維持される）
     * that($result)->isSame([
     *     'a' => [
     *         'status' => 0,
     *         'stdout' => "",
     *         'stderr' => "",
     *         'return' => 3,
     *     ],
     *     'b' => [
     *         'status' => 0,
     *         'stdout' => "",
     *         'stderr' => "",
     *         'return' => 6,
     *     ],
     *     [
     *         'status' => 127,  // 終了コードが入ってくる
     *         'stdout' => "",
     *         'stderr' => "",
     *         'return' => null,
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\exec
     *
     * @param callable|callable[] $tasks 並列実行する callable. 単一の場合は引数分実行して結果を返す
     * @param array $args 各々の引数。$tasks が配列の場合はそれに対応する引数配列。単一の場合は実行回数も兼ねた引数配列
     * @param ?array $autoload 実行前に読み込むスクリプト。省略時は自動検出された vendor/autoload.php と function_configure/process.autoload
     * @param ?string $workdir ワーキングディレクトリ。省略時はテンポラリディレクトリ
     * @param ?array $options その他の追加オプション
     * @return array 実行結果（['return' => callable の返り値, 'status' => 終了コード, 'stdout' => 標準出力, 'stderr' => 標準エラー]）
     */
    function process_parallel($tasks, $args = [], $autoload = null, $workdir = null, $env = null, $options = null)
    {
        // 単一で来た場合は同じものを異なる引数で呼び出すシングルモードとなる
        if (!is_array($tasks)) {
            $tasks = array_fill_keys(array_keys($args) ?: [0], $tasks);
        }

        // 引数配列は単一の値でも良い
        $args = array_map(fn(...$args) => arrayize(...$args), $args);

        // 実行すれば "ArgumentCountError: Too few arguments" で怒られるがもっと早い段階で気づきたい
        foreach ($tasks as $key => $task) {
            assert(parameter_length($task, true) <= count($args[$key] ?? []), "task $key's arguments are mismatch.");
        }

        // プロセスを準備
        $processes = [];
        foreach ($tasks as $key => $task) {
            $processes[$key] = process_closure($task, $args[$key] ?? [], false, $autoload, $workdir, $env, $options);
        }

        // プロセスを実行兼返り値用に加工
        $results = [];
        foreach ($processes as $key => $process) {
            $return = $process();
            $results[$key] = [
                'status' => $process->status()['exitcode'],
                'stdout' => $process->stdout,
                'stderr' => $process->stderr,
                'return' => $return,
            ];
        }
        return $results;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cp_rf') || (new \ReflectionFunction('ryunosuke\\ltsv\\cp_rf'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cp_rf')) {
    /**
     * ディレクトリのコピー
     *
     * $dst に / を付けると「$dst に自身をコピー」する。付けないと「$dst に中身をコピー」するという動作になる。
     *
     * ディレクトリではなくファイルを与えても動作する（copy とほぼ同じ動作になるが、対象にディレクトリを指定できる点が異なる）。
     *
     * Example:
     * ```php
     * // /tmp/src/hoge.txt, /tmp/src/dir/fuga.txt を作っておく
     * $tmp = sys_get_temp_dir();
     * file_set_contents("$tmp/src/hoge.txt", 'hoge');
     * file_set_contents("$tmp/src/dir/fuga.txt", 'fuga');
     *
     * // "/" を付けないと中身コピー
     * cp_rf("$tmp/src", "$tmp/dst1");
     * that("$tmp/dst1/hoge.txt")->fileEquals('hoge');
     * that("$tmp/dst1/dir/fuga.txt")->fileEquals('fuga');
     * // "/" を付けると自身コピー
     * cp_rf("$tmp/src", "$tmp/dst2/");
     * that("$tmp/dst2/src/hoge.txt")->fileEquals('hoge');
     * that("$tmp/dst2/src/dir/fuga.txt")->fileEquals('fuga');
     *
     * // $src はファイルでもいい（$dst に "/" を付けるとそのディレクトリにコピーする）
     * cp_rf("$tmp/src/hoge.txt", "$tmp/dst3/");
     * that("$tmp/dst3/hoge.txt")->fileEquals('hoge');
     * // $dst に "/" を付けないとそのパスとしてコピー（copy と完全に同じ）
     * cp_rf("$tmp/src/hoge.txt", "$tmp/dst4");
     * that("$tmp/dst4")->fileEquals('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $src コピー元パス
     * @param string $dst コピー先パス。末尾/でディレクトリであることを明示できる
     * @return bool 成功した場合に TRUE を、失敗した場合に FALSE を返します
     */
    function cp_rf($src, $dst)
    {
        $dss = '/' . (DIRECTORY_SEPARATOR === '\\' ? '\\\\' : '');
        $dirmode = preg_match("#[$dss]$#u", $dst);

        // ディレクトリでないなら copy へ移譲
        if (!is_dir($src)) {
            if ($dirmode) {
                mkdir_p($dst);
                return copy($src, $dst . basename($src));
            }
            else {
                mkdir_p(dirname($dst));
                return copy($src, $dst);
            }
        }

        if ($dirmode) {
            return cp_rf($src, $dst . basename($src));
        }

        mkdir_p($dst);

        $rdi = new \FilesystemIterator($src, \FilesystemIterator::SKIP_DOTS | \FilesystemIterator::KEY_AS_PATHNAME | \FilesystemIterator::CURRENT_AS_PATHNAME);

        foreach ($rdi as $file) {
            if (is_dir($file)) {
                cp_rf($file, "$dst/" . basename($file));
            }
            else {
                copy($file, "$dst/" . basename($file));
            }
        }
        return file_exists($dst);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\dir_diff') || (new \ReflectionFunction('ryunosuke\\ltsv\\dir_diff'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\dir_diff')) {
    /**
     * ファイルツリーを比較して配列で返す
     *
     * ファイル名をキーとし、
     * - $path1 にしかないファイルは true
     * - $path2 にしかないファイルは false
     * - 両方にあり、内容が異なる場合はなんらかの文字列（comparator オプション）
     * - 両方にあり、内容が同じ場合は結果に含まれない
     *
     * comparator オプションは両方に存在した場合にコールされるので差分を返したり更新日時を返したリできる。
     * comparator が null を返した場合、その要素は内容が同じとみなされ、結果配列に含まれなくなる。
     *
     * Example:
     * ```php
     * // 適当にファイルツリーを用意
     * $dir1 = sys_get_temp_dir() . '/diff1';
     * $dir2 = sys_get_temp_dir() . '/diff2';
     * file_set_tree([
     *     $dir1 => [
     *         'file1.txt' => 'file1',
     *         'file2.txt' => 'file2',
     *         'sub1' => [
     *             'file.txt' => 'sub1file',
     *         ],
     *         'sub2' => [],
     *     ],
     *     $dir2 => [
     *         'file1.txt' => 'file1',
     *         'file2.txt' => 'FILE2',
     *         'sub1' => [],
     *         'sub2' => [
     *             'file.txt' => 'sub2file',
     *         ],
     *     ],
     * ]);
     * // dir_diff すると下記のような差分が得られる
     * $DS = DIRECTORY_SEPARATOR;
     * that(dir_diff($dir1, $dir2))->is([
     *     // "file1.txt" => "",         // 差分がないので含まれない
     *     "file2.txt" => "",            // 両方に存在して差分あり
     *     "sub1{$DS}file.txt" => true,  // dir1 にのみ存在する
     *     "sub2{$DS}file.txt" => false, // dir2 にのみ存在する
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path1 パス1
     * @param string $path2 パス2
     * @param array $options オプション
     * @return array 比較配列
     */
    function dir_diff($path1, $path2, $options = [])
    {
        $DS = DIRECTORY_SEPARATOR;

        $options += [
            'unixpath'       => false,
            'case-sensitive' => $DS === '/',
        ];
        $filter_condition = ['relative' => true, '!type' => null] + $options;

        $differ = $options['differ'] ?? fn($file1, $file2) => file_equals($file1, $file2) ? null : "";

        $list1 = file_list($path1, $filter_condition);
        if ($list1 === null) {
            throw new \UnexpectedValueException("$path1 does not exists");
        }
        $list2 = file_list($path2, $filter_condition);
        if ($list2 === null) {
            $list2 = [];
        }

        if ($options['unixpath']) {
            $DS = '/';
            $list1 = array_map(fn($file) => strtr($file, [DIRECTORY_SEPARATOR => $DS]), $list1);
            $list2 = array_map(fn($file) => strtr($file, [DIRECTORY_SEPARATOR => $DS]), $list2);
        }

        $files1 = array_combine($list1, $list1);
        $files2 = array_combine($list2, $list2);

        if (!$options['case-sensitive']) {
            $files1 = array_change_key_case($files1, CASE_UPPER);
            $files2 = array_change_key_case($files2, CASE_UPPER);
        }

        $diff1 = array_diff_key($files1, $files2);
        $diff2 = array_diff_key($files2, $files1);
        $commons = array_intersect_key($files1, $files2);

        $result = [];
        $result += array_fill_keys($diff1, true);
        $result += array_fill_keys($diff2, false);

        foreach ($commons as $key => $name) {
            $file1 = $path1 . $DS . $files1[$key];
            $file2 = $path2 . $DS . $files2[$key];

            if (!(is_dir($file1) && is_dir($file2)) && ($diff = $differ($file1, $file2)) !== null) {
                $result[$name] = $diff;
            }
        }

        ksort($result);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\dirmtime') || (new \ReflectionFunction('ryunosuke\\ltsv\\dirmtime'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\dirmtime')) {
    /**
     * ディレクトリの最終更新日時を返す
     *
     * 「ディレクトリの最終更新日時」とは filemtime で得られる結果ではなく、「配下のファイル群で最も新しい日時」を表す。
     * ディレクトリの mtime も検出に含まれるので、ファイルを削除した場合も検知できる。
     *
     * ファイル名を与えると例外を投げる。
     * 空ディレクトリの場合は自身の mtime を返す。
     *
     * Example:
     * ```php
     * $dirname = sys_get_temp_dir() . '/mtime';
     * rm_rf($dirname);
     * mkdir($dirname);
     *
     * // この時点では現在日時（単純に自身の更新日時）
     * that(dirmtime($dirname))->isBetween(time() - 2, time());
     * // ファイルを作って更新するとその時刻
     * touch("$dirname/tmp", time() + 10);
     * that(dirmtime($dirname))->isSame(time() + 10);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname ディレクトリ名
     * @param bool $recursive 再帰フラグ
     * @return int 最終更新日時
     */
    function dirmtime($dirname, $recursive = true)
    {
        if (!is_dir($dirname)) {
            throw new \InvalidArgumentException("'$dirname' is not directory.");
        }

        $rdi = new \RecursiveDirectoryIterator($dirname, \FilesystemIterator::SKIP_DOTS);
        $dirtime = filemtime($dirname);
        foreach ($rdi as $path) {
            /** @var \SplFileInfo $path */
            $mtime = $path->getMTime();
            if ($path->isDir() && $recursive) {
                $mtime = max($mtime, dirmtime($path->getPathname(), $recursive));
            }
            if ($dirtime < $mtime) {
                $dirtime = $mtime;
            }
        }
        return $dirtime;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\dirname_r') || (new \ReflectionFunction('ryunosuke\\ltsv\\dirname_r'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\dirname_r')) {
    /**
     * コールバックが true 相当を返すまで親ディレクトリを辿り続ける
     *
     * コールバックには親ディレクトリが引数として渡ってくる。
     *
     * Example:
     * ```php
     * // //tmp/a/b/file.txt を作っておく
     * $tmp = sys_get_temp_dir();
     * file_set_contents("$tmp/a/b/file.txt", 'hoge');
     * // /a/b/c/d/e/f から開始して「どこかの階層の file.txt を探したい」という状況を想定
     * $callback = fn($path) => realpath("$path/file.txt");
     * that(dirname_r("$tmp/a/b/c/d/e/f", $callback))->isSame(realpath("$tmp/a/b/file.txt"));
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス名
     * @param callable $callback コールバック
     * @return mixed $callback の返り値。頂上まで辿ったら null
     */
    function dirname_r($path, $callback)
    {
        $return = $callback($path);
        if ($return) {
            return $return;
        }

        $dirname = dirname($path);
        if ($dirname === $path) {
            return null;
        }
        return dirname_r($dirname, $callback);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_equals') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_equals'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_equals')) {
    /**
     * ファイルが同じ内容か返す
     *
     * ファイルサイズで比較して一致したら更に内容を読んで判定する。
     * ディレクトリ同士の場合は直下のファイル群を内容とみなして判定する。
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $testpath1 = sys_get_temp_dir() . '/file_equals1.txt';
     * $testpath2 = sys_get_temp_dir() . '/file_equals2.txt';
     * $testpath3 = sys_get_temp_dir() . '/file_equals3.txt';
     * file_put_contents($testpath1, "hoge");
     * file_put_contents($testpath2, "foo");
     * file_put_contents($testpath3, "hoge");
     * // 異なるなら false
     * that(file_equals($testpath1, $testpath2))->isFalse();
     * // 同じなら true
     * that(file_equals($testpath1, $testpath3))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $file1 ファイル名1
     * @param string $file2 ファイル名2
     * @param ?int $chunk_size 読み込みチャンクサイズ
     * @return bool ファイルが同じ内容なら true
     */
    function file_equals($file1, $file2, $chunk_size = null)
    {
        $chunk_size ??= 4096;

        if (!file_exists($file1) || !file_exists($file2)) {
            $files = array_filter([$file1, $file2], 'file_exists');
            throw new \InvalidArgumentException(implode(',', $files) . " does not exist.");
        }

        if (is_dir($file1) xor is_dir($file2)) {
            return false;
        }

        if (is_dir($file1) && is_dir($file2)) {
            $opt = ['relative' => true, 'recursive' => false];
            return file_list($file1, $opt) === file_list($file2, $opt);
        }

        // ファイルサイズが異なるなら異なるファイルなのは間違いない
        if (filesize($file1) !== filesize($file2)) {
            return false;
        }

        // 結局ファイルをすべて読むし衝突の可能性もなくはないのでハッシュ比較は不採用
        //return sha1_file($file1) === sha1_file($file2);

        // 少しづつ読んで比較する
        try {
            $fp1 = fopen($file1, 'r');
            $fp2 = fopen($file2, 'r');

            while (!(feof($fp1) || feof($fp2))) {
                $line1 = fread($fp1, $chunk_size);
                $line2 = fread($fp2, $chunk_size);
                if ($line1 !== $line2) {
                    return false;
                }
            }
            return true;
        }
        finally {
            if (isset($fp1)) {
                fclose($fp1);
            }
            if (isset($fp2)) {
                fclose($fp2);
            }
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_extension') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_extension'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_extension')) {
    /**
     * ファイルの拡張子を変更する。引数を省略すると拡張子を返す
     *
     * pathinfo に準拠。例えば「filename.hoge.fuga」のような形式は「fuga」が変換対象になる。
     *
     * Example:
     * ```php
     * that(file_extension('filename.ext'))->isSame('ext');
     * that(file_extension('filename.ext', 'txt'))->isSame('filename.txt');
     * that(file_extension('filename.ext', ''))->isSame('filename');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 調べるファイル名
     * @param string $extension 拡張子。nullや空文字なら拡張子削除
     * @return string 拡張子変換後のファイル名 or 拡張子
     */
    function file_extension($filename, $extension = '')
    {
        $pathinfo = pathinfo($filename);

        if (func_num_args() === 1) {
            return isset($pathinfo['extension']) ? $pathinfo['extension'] : null;
        }

        if (strlen($extension)) {
            $extension = '.' . ltrim($extension, '.');
        }
        $basename = $pathinfo['filename'] . $extension;

        if ($pathinfo['dirname'] === '.') {
            return $basename;
        }

        return $pathinfo['dirname'] . DIRECTORY_SEPARATOR . $basename;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_get_arrays') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_get_arrays'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_get_arrays')) {
    /**
     * 指定ファイルを拡張子別に php の配列として読み込む
     *
     * 形式は拡張子で自動判別する。
     * その際、2重拡張子で hoge.sjis.csv のように指定するとそのファイルのエンコーディングを指定したことになる。
     *
     * Example:
     * ```php
     * // csv ファイルを読み込んで配列で返す
     * file_put_contents($csvfile = sys_get_temp_dir() . '/hoge.csv', 'a,b,c
     * 1,2,3
     * 4,5,6
     * 7,8,9
     * ');
     * that(file_get_arrays($csvfile))->isSame([
     *     ['a' => '1', 'b' => '2', 'c' => '3'],
     *     ['a' => '4', 'b' => '5', 'c' => '6'],
     *     ['a' => '7', 'b' => '8', 'c' => '9'],
     * ]);
     *
     * // sjis の json ファイルを読み込んで配列で返す
     * file_put_contents($jsonfile = sys_get_temp_dir() . '/hoge.sjis.json', '[
     * {"a": 1, "b": 2, "c": 3},
     * {"a": 4, "b": 5, "c": 6},
     * {"a": 7, "b": 8, "c": 9}
     * ]');
     * that(file_get_arrays($jsonfile))->isSame([
     *     ['a' => 1, 'b' => 2, 'c' => 3],
     *     ['a' => 4, 'b' => 5, 'c' => 6],
     *     ['a' => 7, 'b' => 8, 'c' => 9],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 読み込むファイル名
     * @param array $options 各種オプション
     * @return array レコード配列
     */
    function file_get_arrays($filename, $options = [])
    {
        static $supported_encodings = null;
        if ($supported_encodings === null) {
            $supported_encodings = array_combine(array_map('strtolower', mb_list_encodings()), mb_list_encodings());
        }

        if (!file_exists($filename)) {
            throw new \InvalidArgumentException("$filename is not exists");
        }

        $internal_encoding = mb_internal_encoding();
        $mb_convert_encoding = function ($encoding, $contents) use ($internal_encoding) {
            if ($encoding !== $internal_encoding) {
                $contents = mb_convert_encoding($contents, $internal_encoding, $encoding);
            }
            return $contents;
        };

        $pathinfo = pathinfo($filename);
        $encoding = pathinfo($pathinfo['filename'], PATHINFO_EXTENSION);
        $encoding = $supported_encodings[strtolower($encoding)] ?? $internal_encoding;
        $extension = $pathinfo['extension'] ?? '';

        switch (strtolower($extension)) {
            default:
                throw new \InvalidArgumentException("ext '$extension' is not supported.");
            case 'php':
                return (array) require $filename;
            case 'csv':
                return (array) csv_import($mb_convert_encoding($encoding, file_get_contents($filename)), $options + ['structure' => true]);
            case 'json':
            case 'json5':
                return (array) json_import($mb_convert_encoding($encoding, file_get_contents($filename)), $options);
            case 'jsonl':
            case 'jsonl5':
                return (array) array_map(fn($json) => json_import($json, $options), $mb_convert_encoding($encoding, array_filter(file($filename, FILE_IGNORE_NEW_LINES), 'strlen')));
            case 'yml':
            case 'yaml':
                return (array) yaml_parse($mb_convert_encoding($encoding, file_get_contents($filename)), 0, $ndocs, $options);
            case 'xml':
                throw new \DomainException("ext '$extension' is supported in the future.");
            case 'ltsv':
                return (array) array_map(fn($ltsv) => ltsv_import($ltsv, $options), $mb_convert_encoding($encoding, array_filter(file($filename, FILE_IGNORE_NEW_LINES), 'strlen')));
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_list') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_list'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_list')) {
    /**
     * ファイル一覧を配列で返す
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $DS = DIRECTORY_SEPARATOR;
     * $tmp = sys_get_temp_dir() . "{$DS}file_list";
     * rm_rf($tmp, false);
     * file_set_contents("$tmp/a.txt", 'a');
     * file_set_contents("$tmp/dir/b.txt", 'b');
     * file_set_contents("$tmp/dir/dir/c.txt", 'c');
     * // ファイル一覧が取得できる
     * that(file_list($tmp))->equalsCanonicalizing([
     *     "$tmp{$DS}a.txt",
     *     "$tmp{$DS}dir{$DS}b.txt",
     *     "$tmp{$DS}dir{$DS}dir{$DS}c.txt",
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname 調べるディレクトリ名
     * @param array $filter_condition フィルタ条件
     * @return ?array ファイルの配列
     */
    function file_list($dirname, $filter_condition = [])
    {
        $filter_condition += [
            'unixpath' => false,
            '!type'    => 'dir',

            'recursive' => true,
            'relative'  => false,
            'nesting'   => false,
        ];

        $dirname = path_normalize($dirname);

        $subpath = '';
        while (!is_dir($dirname) && str_exists(basename($dirname), ['*', '?', '!', '{', '}', '[', ']'])) {
            $subpath = basename($dirname) . (strlen($subpath) ? '/' : '') . $subpath;
            $dirname = dirname($dirname);
        }

        if (strlen($subpath)) {
            if (strlen($filter_condition['subpath'] ?? '')) {
                throw new \InvalidArgumentException("both subpath and subpattern are specified");
            }
            $filter_condition['subpath'] = $subpath;
            $filter_condition['fnmflag'] = FNM_PATHNAME;
            $filter_condition['unixpath'] = true;
        }

        if (!file_exists($dirname) || $dirname === dirname($dirname)) {
            return null;
        }

        $match = file_matcher($filter_condition);

        $DS = DIRECTORY_SEPARATOR;
        $opt = \FilesystemIterator::SKIP_DOTS | \FilesystemIterator::KEY_AS_PATHNAME | \FilesystemIterator::CURRENT_AS_SELF;

        if ($filter_condition['unixpath']) {
            $DS = '/';
            $opt |= \FilesystemIterator::UNIX_PATHS;
        }

        $rdi = new \RecursiveDirectoryIterator($dirname, $opt);

        if ($filter_condition['recursive']) {
            $iterator = new \RecursiveIteratorIterator($rdi, \RecursiveIteratorIterator::CHILD_FIRST);
        }
        else {
            $iterator = $rdi;
        }

        $result = [];
        foreach ($iterator as $fullpath => $it) {
            if (!$match($it)) {
                continue;
            }

            $path = $filter_condition['relative'] ? $it->getSubPathName() : $fullpath;
            $path = strtr(is_dir($fullpath) ? $path . $DS : $path, [DIRECTORY_SEPARATOR => $DS]);

            if ($filter_condition['nesting']) {
                $tmp = &$result;
                foreach (array_filter(multiexplode(['/', DIRECTORY_SEPARATOR], $it->getSubPath()), 'strlen') as $subdir) {
                    $tmp = &$tmp[$subdir];
                }
                if ($it->isDir()) {
                    $tmp[$it->getFilename()] = $tmp[$it->getFilename()] ?? [];
                }
                else {
                    $tmp[$it->getFilename()] = $path;
                }
            }
            else {
                $result[] = $path;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_matcher') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_matcher'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_matcher')) {
    /**
     * 各種属性を指定してファイルのマッチングを行うクロージャを返す
     *
     * ※ 内部向け
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param array $filter_condition マッチャーコンディション配列（ソースを参照）
     * @return \Closure ファイルマッチャー
     */
    function file_matcher(array $filter_condition)
    {
        $filter_condition += [
            // common
            'dotfile'    => null,  // switch startWith "."
            'unixpath'   => true,  // convert "\\" -> "/"
            'casefold'   => false, // ignore case
            'fnmflag'    => 0,     // FNM_*
            // by getType (string or [string])
            'type'       => null,
            '!type'      => null,
            // by getPerms (int)
            'perms'      => null,
            '!perms'     => null,
            // by getMTime (int or [int, int])
            'mtime'      => null,
            '!mtime'     => null,
            // by getSize (int or [int, int])
            'size'       => null,
            '!size'      => null,
            // by getPathname (glob or regex)
            'path'       => null,
            '!path'      => null,
            // by getSubPath (glob or regex)
            'subpath'    => null,
            '!subpath'   => null,
            // by getPath or getSubpath (glob or regex)
            'dir'        => null,
            '!dir'       => null,
            // by getFilename (glob or regex)
            'name'       => null,
            '!name'      => null,
            // by getBasename (glob or regex)
            'basename'   => null,
            '!basename'  => null,
            // by getExtension (string or [string])
            'extension'  => null,
            '!extension' => null,
            // by contents (string)
            'contains'   => null,
            '!contains'  => null,
            // by custom condition (callable)
            'filter'     => null,
            '!filter'    => null,
        ];

        foreach ([
            'mtime'  => fn(...$args) => date_timestamp(...$args),
            '!mtime' => fn(...$args) => date_timestamp(...$args),
            'size'   => fn(...$args) => si_unprefix(...$args),
            '!size'  => fn(...$args) => si_unprefix(...$args),
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $range = $filter_condition[$key];
                if (!is_array($range)) {
                    $range = array_fill_keys([0, 1], $range);
                }
                $range = array_map($map, $range);
                $filter_condition[$key] = static function ($value) use ($range) {
                    return (!isset($range[0]) || $value >= $range[0]) && (!isset($range[1]) || $value <= $range[1]);
                };
            }
        }

        foreach ([
            'type'       => null,
            '!type'      => null,
            'extension'  => null,
            '!extension' => null,
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $array = array_flip((array) $filter_condition[$key]);
                if ($filter_condition['casefold']) {
                    $array = array_change_key_case($array, CASE_LOWER);
                }
                $filter_condition[$key] = static function ($value) use ($array) {
                    return isset($array[$value]);
                };
            }
        }

        foreach ([
            'path'      => null,
            '!path'     => null,
            'subpath'   => null,
            '!subpath'  => null,
            'dir'       => null,
            '!dir'      => null,
            'name'      => null,
            '!name'     => null,
            'basename'  => null,
            '!basename' => null,
        ] as $key => $convert) {
            if (isset($filter_condition[$key])) {
                $callback = fn() => false;
                foreach (arrayize($filter_condition[$key]) as $pattern) {
                    preg_match('##', ''); // clear preg_last_error
                    @preg_match($pattern, '');
                    if (preg_last_error() === PREG_NO_ERROR) {
                        $callback = static function ($string) use ($callback, $pattern, $filter_condition) {
                            if ($callback($string)) {
                                return true;
                            }
                            $string = $filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\' ? str_replace('\\', '/', $string) : $string;
                            return !!preg_match($pattern, $string);
                        };
                    }
                    else {
                        $callback = static function ($string) use ($callback, $pattern, $filter_condition) {
                            if ($callback($string)) {
                                return true;
                            }
                            if ($filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\') {
                                $pattern = str_replace('\\', '/', $pattern);
                                $string = str_replace('\\', '/', $string);
                            }
                            $flags = $filter_condition['fnmflag'];
                            $flags |= $filter_condition['casefold'] ? FNM_CASEFOLD : 0;
                            $flags &= ~((strpos($pattern, '**') !== false) ? FNM_PATHNAME : 0);
                            return fnmatch($pattern, $string, $flags);
                        };
                    }
                }
                $filter_condition[$key] = $callback;
            }
        }

        return function ($file) use ($filter_condition) {
            if (!$file instanceof \SplFileInfo) {
                $file = new \SplFileInfo($file);
            }

            if (isset($filter_condition['dotfile']) && !$filter_condition['dotfile'] === (strpos($file->getFilename(), '.') === 0)) {
                return false;
            }

            foreach (['type' => false, '!type' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getType()))) {
                    return false;
                }
            }
            foreach (['perms' => false, '!perms' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === !!($filter_condition[$key] & $file->getPerms()))) {
                    return false;
                }
            }
            foreach (['mtime' => false, '!mtime' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getMTime()))) {
                    return false;
                }
            }
            foreach (['size' => false, '!size' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getSize()))) {
                    return false;
                }
            }
            foreach (['path' => false, '!path' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getPathname())) {
                    return false;
                }
            }
            foreach (['subpath' => false, '!subpath' => true] as $key => $cond) {
                $subpath = $file instanceof \RecursiveDirectoryIterator ? $file->getSubPathname() : $file->getPathname();
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($subpath)) {
                    return false;
                }
            }
            foreach (['dir' => false, '!dir' => true] as $key => $cond) {
                $dirname = $file instanceof \RecursiveDirectoryIterator ? $file->getSubPath() : $file->getPath();
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($dirname)) {
                    return false;
                }
            }
            foreach (['name' => false, '!name' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getFilename())) {
                    return false;
                }
            }
            foreach (['basename' => false, '!basename' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getBasename(concat('.', $file->getExtension())))) {
                    return false;
                }
            }
            foreach (['extension' => false, '!extension' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getExtension())) {
                    return false;
                }
            }
            foreach (['filter' => false, '!filter' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === !!$filter_condition[$key]($file)) {
                    return false;
                }
            }
            foreach (['contains' => false, '!contains' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === (file_pos($file->getPathname(), $filter_condition[$key]) !== null))) {
                    return false;
                }
            }

            return true;
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_mimetype') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_mimetype'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_mimetype')) {
    /**
     * ファイルの mimetype を返す
     *
     * mime_content_type の http 対応版。
     * 変更点は下記。
     *
     * - http(s) に対応（HEAD メソッドで取得する）
     * - 失敗時に false ではなく null を返す
     *
     * Example:
     * ```php
     * that(file_mimetype(__FILE__))->is('text/x-php');
     * that(file_mimetype('http://httpbin.org/get?name=value'))->is('application/json');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename ファイル名（URL）
     * @param array|bool $prefer_extension extension => mimetype のマップ（true を与えると組み込みを使用する）
     * @return string|null MIME タイプ
     */
    function file_mimetype($filename, $prefer_extension = [])
    {
        $mimetypes = GENERAL_MIMETYPE;
        if (is_array($prefer_extension)) {
            $mimetypes = $prefer_extension + $mimetypes;
        }

        $parts = parse_url($filename) ?: [];

        if ($prefer_extension) {
            $extension = strtolower(pathinfo($parts['path'] ?? '', PATHINFO_EXTENSION));
            if (isset($mimetypes[$extension])) {
                return $mimetypes[$extension];
            }
        }

        switch (strtolower($parts['scheme'] ?? '')) {
            default:
            case 'file':
                return mime_content_type($filename) ?: null;

            case 'http':
            case 'https':
                $r = $c = [];
                http_head($filename, [], ['throw' => false], $r, $c);
                if ($c['http_code'] === 200) {
                    return $c['content_type'] ?? null;
                }
                trigger_error("HEAD $filename {$c['http_code']}", E_USER_WARNING);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_pos') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_pos'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_pos')) {
    /**
     * 範囲指定でファイルを読んで位置を返す
     *
     * $needle に配列を与えると OR 的動作で一つでも見つかった時点の位置を返す。
     * このとき「どれが見つかったか？」は得られない（場合によっては不便なので将来の改修対象）。
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $testpath = sys_get_temp_dir() . '/file_pos.txt';
     * file_put_contents($testpath, "hoge\nfuga\npiyo\nfuga");
     * // fuga の位置を返す
     * that(file_pos($testpath, 'fuga'))->is(5);
     * // 2つ目の fuga の位置を返す
     * that(file_pos($testpath, 'fuga', 6))->is(15);
     * // 見つからない場合は false を返す
     * that(file_pos($testpath, 'hogera'))->is(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename ファイル名
     * @param string|array $needle 探す文字列
     * @param int $start 読み込み位置
     * @param int|null $end 読み込むまでの位置。省略時は指定なし（最後まで）。負数は後ろからのインデックス
     * @param int|null $chunksize 読み込みチャンクサイズ。省略時は 4096 の倍数に正規化
     * @return ?int $needle の位置。見つからなかった場合は null
     */
    function file_pos($filename, $needle, $start = 0, $end = null, $chunksize = null)
    {
        if (!is_file($filename)) {
            throw new \InvalidArgumentException("'$filename' is not found.");
        }

        $needle = arrayval($needle, false);
        $maxlength = max(array_map('strlen', $needle));

        if ($start < 0) {
            $start += $filesize ?? $filesize = filesize($filename);
        }
        if ($end === null) {
            $end = $filesize ?? $filesize = filesize($filename);
        }
        if ($end < 0) {
            $end += $filesize ?? $filesize = filesize($filename);
        }
        if ($chunksize === null) {
            $chunksize = 4096 * ($maxlength % 4096 + 1);
        }

        assert(isset($filesize) || !isset($filesize));
        assert($chunksize >= $maxlength);

        $fp = fopen($filename, 'rb');
        try {
            fseek($fp, $start);
            while (!feof($fp)) {
                if ($start > $end) {
                    break;
                }
                $last = $part ?? '';
                $part = fread($fp, $chunksize);
                if (($p = strpos_array($part, $needle))) {
                    $min = min($p);
                    $result = $start + $min;
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                if (($p = strpos_array($last . $part, $needle))) {
                    $min = min($p);
                    $result = $start + $min - strlen($last);
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                $start += strlen($part);
            }
            return null;
        }
        finally {
            fclose($fp);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_rewrite_contents') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_rewrite_contents'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_rewrite_contents')) {
    /**
     * ファイルを読み込んで内容をコールバックに渡して書き込む
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $testpath = sys_get_temp_dir() . '/rewrite.txt';
     * file_put_contents($testpath, 'hoge');
     * // 前後に 'pre-', '-fix' を付与する
     * file_rewrite_contents($testpath, fn($contents, $fp) => "pre-$contents-fix");
     * that($testpath)->fileEquals('pre-hoge-fix');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 読み書きするファイル名
     * @param callable $callback 書き込む内容。引数で $contents, $fp が渡ってくる
     * @param int $operation ロック定数（LOCL_SH, LOCK_EX, LOCK_NB）
     * @return int 書き込まれたバイト数
     */
    function file_rewrite_contents($filename, $callback, $operation = 0)
    {
        /** @var resource $fp */
        try {
            // 開いて
            $fp = fopen($filename, 'c+b') ?: throw new \UnexpectedValueException('failed to fopen.');
            if ($operation) {
                flock($fp, $operation) ?: throw new \UnexpectedValueException('failed to flock.');
            }

            // 読み込んで
            rewind($fp) ?: throw new \UnexpectedValueException('failed to rewind.');
            $contents = false !== ($t = stream_get_contents($fp)) ? $t : throw new \UnexpectedValueException('failed to stream_get_contents.');

            // 変更して
            rewind($fp) ?: throw new \UnexpectedValueException('failed to rewind.');
            ftruncate($fp, 0) ?: throw new \UnexpectedValueException('failed to ftruncate.');
            $contents = $callback($contents, $fp);

            // 書き込んで
            $return = ($r = fwrite($fp, $contents)) !== false ? $r : throw new \UnexpectedValueException('failed to fwrite.');
            fflush($fp) ?: throw new \UnexpectedValueException('failed to fflush.');

            // 閉じて
            if ($operation) {
                flock($fp, LOCK_UN) ?: throw new \UnexpectedValueException('failed to flock.');
            }
            fclose($fp) ?: throw new \UnexpectedValueException('failed to fclose.');

            // 返す
            return $return;
        }
        catch (\Exception $ex) {
            if (isset($fp)) {
                if ($operation) {
                    flock($fp, LOCK_UN);
                }
                fclose($fp);
            }
            throw $ex;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_rotate') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_rotate'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_rotate')) {
    /**
     * ファイルをローテーションする
     *
     * オプションは logrotate に意図的に似せてある。
     * 返り値としてローテーションファイル配列を返す。
     * 基本的に決め打ちな使い方で細かいオプションは実装していない。
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * rm_rf(sys_get_temp_dir() . '/rotate');
     * $logfile = sys_get_temp_dir() . '/rotate/log.txt';
     * file_set_contents($logfile, '');
     * // 5回ローテートしてみる
     * foreach (range(1, 5) as $i) {
     *     file_rotate($logfile, ifempty: true, rotate: 4, compress: 2, dateformat: "-$i"); // dateformat は普通は日付書式文字列（↓の確認がしんどくなるのでここでは連番）
     * }
     * // rotate:4 効果で全部で4世代であり、compress:2 効果でうち2世代は圧縮されている
     * $dirname = dirname($logfile);
     * that(glob("$dirname/log-*"))->is([
     *     "$dirname/log-2.txt.gz",
     *     "$dirname/log-3.txt.gz",
     *     "$dirname/log-4.txt",
     *     "$dirname/log-5.txt",
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     */
    function file_rotate(
        /** 対象ファイル名 */ string $filename,
        /** 空ファイルでもローテーションするか */ bool $ifempty = false,
        /** 同じファイル（inode）を使い続けるか */ bool $copytruncate = false,
        /** 既存ローテーションファイルに追記するか */ bool $append = false,
        /** ローテーションファイルのディレクトリ */ ?string $olddir = null,
        /** ローテーションファイルのサフィックス */ ?string $dateformat = null,
        /** 保持世代数（null で無世代） */ ?int $rotate = null,
        /** 圧縮世代数（例えば 3 を指定すると3世代目から圧縮される） */ ?int $compress = null,
    ): /** ローテーションファイル配列 */ ?array
    {
        /// 共通処理

        assert(!($copytruncate && $append), 'both $copytruncate and $append are true');
        assert($rotate === null || $rotate >= 0, '$rotate is negative number');
        assert($compress === null || $compress >= 0, '$compress is negative number');

        $filename = realpath($filename);
        $pathinfo = pathinfo($filename);

        if ($filename === false) {
            return null;
        }
        if (!$ifempty && !filesize($filename)) {
            return null;
        }

        /// 世代ディレクトリ検出

        $olddir ??= $pathinfo['dirname'];
        if (!path_is_absolute($olddir)) {
            $olddir = "{$pathinfo['dirname']}/$olddir";
        }
        if (!is_dir($olddir)) {
            @mkdir($olddir, 0777, true);
            if (is_dir($olddir) === false) {
                throw new \RuntimeException("failed to mkdir($olddir)");
            }
        }

        /// ローテーション

        $oldfile = "$olddir/{$pathinfo['filename']}" . date($dateformat ?? '-Y-m-d', time()) . ".{$pathinfo['extension']}";
        if ($copytruncate) {
            if (@copy($filename, $oldfile) === false) {
                throw new \RuntimeException("failed to copy($filename, $oldfile)");
            }

            file_put_contents($filename, "");
        }
        elseif ($append) {
            if (@file_put_contents($oldfile, file_get_contents($filename), FILE_APPEND) === false) {
                throw new \RuntimeException("failed to file_put_contents($oldfile, file_get_contents($filename), FILE_APPEND)");
            }

            file_put_contents($filename, "");
        }
        else {
            if (@rename($filename, $oldfile) === false) {
                throw new \RuntimeException("failed to rename($filename, $oldfile)");
            }

            file_put_contents($filename, "");
            if (($perms = fileperms($oldfile)) !== false) {
                chmod($filename, $perms);
            }
            if (($owner = fileowner($oldfile)) !== false) {
                chown($filename, $owner);
            }
            if (($group = filegroup($oldfile)) !== false) {
                chgrp($filename, $group);
            }
        }

        /// 世代管理

        $oldfiles = glob("$olddir/{$pathinfo['filename']}*");
        $oldfiles = array_maps($oldfiles, 'realpath');
        $oldfiles = array_diff($oldfiles, [$filename]);
        rsort($oldfiles);

        // 古い世代を削除
        if ($rotate !== null) {
            foreach (array_slice($oldfiles, $rotate, null, true) as $n => $file) {
                if (unlink($file) !== false) {
                    unset($oldfiles[$n]);
                }
            }
        }

        // 古い世代を圧縮
        if ($compress !== null) {
            foreach (array_slice($oldfiles, $compress, null, true) as $n => $file) {
                if (pathinfo($file, PATHINFO_EXTENSION) !== 'gz') {
                    if (file_put_contents("compress.zlib://$file.gz", file_get_contents($file)) !== false && unlink($file) !== false) {
                        $oldfiles[$n] = "$file.gz";
                    }
                }
            }
        }

        return $oldfiles;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_set_contents') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_set_contents'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_set_contents')) {
    /**
     * ディレクトリも掘る file_put_contents
     *
     * 書き込みは一時ファイルと rename を使用してアトミックに行われる。
     *
     * Example:
     * ```php
     * file_set_contents(sys_get_temp_dir() . '/not/filename.ext', 'hoge');
     * that(file_get_contents(sys_get_temp_dir() . '/not/filename.ext'))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 書き込むファイル名
     * @param string $data 書き込む内容
     * @param int $umask ディレクトリを掘る際の umask
     * @return ?int 書き込まれたバイト数
     */
    function file_set_contents($filename, $data, $umask = 0002)
    {
        if (func_num_args() === 2) {
            $umask = umask();
        }

        $filename = path_normalize($filename);

        if (!is_dir($dirname = dirname($filename))) {
            if (!@mkdir_p($dirname, $umask)) {
                throw new \RuntimeException("failed to mkdir($dirname)");
            }
        }

        error_clear_last();
        $tempnam = @tempnam($dirname, 'tmp');
        if (strpos(error_get_last()['message'] ?? '', "file created in the system's temporary directory") !== false) {
            $result = file_put_contents($filename, $data);
            @chmod($filename, 0666 & ~$umask);
            return $result === false ? null : $result;
        }
        if (($result = file_put_contents($tempnam, $data)) !== false) {
            if (rename($tempnam, $filename)) {
                @chmod($filename, 0666 & ~$umask);
                return $result === false ? null : $result;
            }
            unlink($tempnam);
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_set_tree') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_set_tree'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_set_tree')) {
    /**
     * ツリー構造で file_set_contents する
     *
     * 値が配列の場合はディレクトリ、それ以外の場合はファイルとなる。
     * 値がクロージャーの場合はコールされる。
     * 返り値として書き込んだバイト数のフルパス配列を返す。
     *
     * Example:
     * ```php
     * // 一時ディレクトリにツリー構造でファイルを配置する
     * $root = sys_get_temp_dir();
     * file_set_tree([
     *     $root => [
     *         'hoge.txt' => 'HOGE',
     *         'dir1' => [
     *             'fuga.txt' => 'FUGA',
     *             'dir2'     => [
     *                 'piyo.txt' => 'PIYO',
     *             ],
     *         ],
     *     ],
     * ]);
     * that("$root/hoge.txt")->fileEquals('HOGE');
     * that("$root/dir1/fuga.txt")->fileEquals('FUGA');
     * that("$root/dir1/dir2/piyo.txt")->fileEquals('PIYO');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param array $contents_tree コンテンツツリー
     * @param ?int $umask umask
     * @return array 書き込まれたバイト数配列
     */
    function file_set_tree($contents_tree, $umask = null)
    {
        $umask ??= umask();

        $main = function ($contents_tree, $parent) use (&$main, $umask) {
            $result = [];
            foreach ($contents_tree as $basename => $entry) {
                $fullpath = isset($parent) ? $parent . DIRECTORY_SEPARATOR . $basename : $basename;
                if ($entry instanceof \Closure) {
                    $entry = $entry($fullpath, $parent, $basename);
                }

                if (is_array($entry)) {
                    mkdir_p($fullpath, $umask);
                    $result += $main($entry, $fullpath);
                }
                else {
                    $byte = file_set_contents($fullpath, $entry, $umask);
                    $result[path_normalize($fullpath)] = $byte;
                }
            }
            return $result;
        };
        return $main($contents_tree, null);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_slice') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_slice'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_slice')) {
    /**
     * file の行範囲を指定できる板
     *
     * 原則 file をベースに作成しているが、一部独自仕様がある。
     *
     * - 結果配列は行番号がキーになる
     *   - あくまで行番号なので 1 オリジン
     *   - スキップされた行は歯抜けになる
     * - FILE_SKIP_EMPTY_LINES の動作が FILE_IGNORE_NEW_LINES ありきではない
     *   - file における FILE_SKIP_EMPTY_LINES の単独指定は意味を成さないっぽい
     *     - FILE_IGNORE_NEW_LINES しないと空文字ではなく改行文字が含まれるので空判定にならないようだ
     *   - この関数はその動作を撤廃しており、単独で FILE_SKIP_EMPTY_LINES を指定しても空行が飛ばされる動作になっている
     * - $end_line に負数を指定すると行番号の直指定となる
     *   - `file_slice($filename, 120, -150)` で 120行目から150行目までを読む
     *   - 負数なのは気持ち悪いが、範囲指定のハイフン（120-150）だと思えば割と自然
     *
     * 使用用途としては
     *
     * 1. 巨大ファイルの前半だけ読みたい
     * 2. 1行だけサクッと読みたい
     *
     * が挙げられる。
     *
     * 1 は自明（file は全行読む）だが、終端付近を読む場合は file の方が若干速い。
     * ただし、期待値としてはこの関数の方が格段に低い（file は下手すると何十倍も遅い）。
     *
     * 2 は典型的には「1行目だけ読みたい」場合、fopen+fgets+fclose(finally)という手順を踏む必要があり煩雑になる。
     * この関数を使えばサクッと取得することができる。
     *
     * Example:
     * ```php
     * // 適当にファイルを用意（奇数行は行番号、偶数行は空行）
     * $testpath = sys_get_temp_dir() . '/file_slice.txt';
     * file_put_contents($testpath, implode("\n", array_map(fn($n) => $n % 2 ? $n : "", range(1, 20))));
     * // 3行目から4行を返す
     * that(file_slice($testpath, 3, 4))->is([
     *     3 => "3\n",
     *     4 => "\n",
     *     5 => "5\n",
     *     6 => "\n",
     * ]);
     * // 3行目から6行目までを返す
     * that(file_slice($testpath, 3, -6))->is([
     *     3 => "3\n",
     *     4 => "\n",
     *     5 => "5\n",
     *     6 => "\n",
     * ]);
     * // 改行文字や空行を含めない（キーは保持される）
     * that(file_slice($testpath, 3, 4, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES))->is([
     *     3 => "3",
     *     5 => "5",
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename ファイル名
     * @param int $start_line 開始行。1 オリジン
     * @param ?int $length 終了行。null を指定すると最後まで読む。負数にすると行番号直指定になる
     * @param int $flags file と同じフラグ定数（FILE_IGNORE_NEW_LINES, etc）
     * @param ?resource $context file と同じ context 指定
     * @return array 部分行
     */
    function file_slice($filename, $start_line = 1, $length = null, $flags = 0, $context = null)
    {
        $FILE_USE_INCLUDE_PATH = !!($flags & FILE_USE_INCLUDE_PATH);
        $FILE_IGNORE_NEW_LINES = !!($flags & FILE_IGNORE_NEW_LINES);
        $FILE_SKIP_EMPTY_LINES = !!($flags & FILE_SKIP_EMPTY_LINES);

        assert($start_line > 0, '$start_line must be positive number. because it means line number.');

        if ($length === null) {
            $end_line = null;
        }
        elseif ($length > 0) {
            $end_line = $start_line + $length;
        }
        elseif ($length < 0) {
            $end_line = -$length + 1;
        }

        $fp = fopen($filename, 'r', $FILE_USE_INCLUDE_PATH, $context);
        try {
            $result = [];
            for ($i = 1; ($line = fgets($fp)) !== false; $i++) {
                if (isset($end_line) && $i >= $end_line) {
                    break;
                }
                if ($i >= $start_line) {
                    if ($FILE_IGNORE_NEW_LINES) {
                        $line = rtrim($line);
                    }
                    if ($FILE_SKIP_EMPTY_LINES && trim($line) === '') {
                        continue;
                    }
                    $result[$i] = $line;
                }
            }
            return $result;
        }
        finally {
            fclose($fp);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_suffix') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_suffix'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_suffix')) {
    /**
     * ファイル名にサフィックスを付与する
     *
     * pathinfoに非準拠。例えば「filename.hoge.fuga」のような形式は「filename」が変換対象になる。
     *
     * Example:
     * ```php
     * that(file_suffix('filename.ext', '-min'))->isSame('filename-min.ext');
     * that(file_suffix('filename.ext1.ext2', '-min'))->isSame('filename-min.ext1.ext2');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename パス・ファイル名
     * @param string $suffix 付与するサフィックス
     * @return string サフィックスが付与されたパス名
     */
    function file_suffix($filename, $suffix)
    {
        $pathinfo = pathinfo($filename);
        $dirname = $pathinfo['dirname'];

        $exts = [];
        while (isset($pathinfo['extension'])) {
            $exts[] = '.' . $pathinfo['extension'];
            $pathinfo = pathinfo($pathinfo['filename']);
        }

        $basename = $pathinfo['filename'] . $suffix . implode('', array_reverse($exts));

        if ($dirname === '.') {
            return $basename;
        }

        return $dirname . DIRECTORY_SEPARATOR . $basename;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\file_tree') || (new \ReflectionFunction('ryunosuke\\ltsv\\file_tree'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\file_tree')) {
    /**
     * ディレクトリ階層をツリー構造で返す
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $DS = DIRECTORY_SEPARATOR;
     * $tmp = sys_get_temp_dir() . "{$DS}file_tree";
     * rm_rf($tmp, false);
     * file_set_contents("$tmp/a.txt", 'a');
     * file_set_contents("$tmp/dir/b.txt", 'b');
     * file_set_contents("$tmp/dir/dir/c.txt", 'c');
     * // ファイルツリーが取得できる
     * that(file_tree($tmp))->is([
     *     'file_tree' => [
     *         'a.txt' => "$tmp{$DS}a.txt",
     *         'dir'   => [
     *             'b.txt' => "$tmp{$DS}dir{$DS}b.txt",
     *             'dir'   => [
     *                 'c.txt' => "$tmp{$DS}dir{$DS}dir{$DS}c.txt",
     *             ],
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname 調べるディレクトリ名
     * @param array $filter_condition フィルタ条件
     * @return ?array ツリー構造の配列
     */
    function file_tree($dirname, $filter_condition = [])
    {
        $dirname = path_normalize($dirname);
        if (!file_exists($dirname)) {
            return null;
        }

        $filter_condition += [
            '!type' => 'dir',
        ];
        $match = file_matcher($filter_condition);

        $basedir = basename($dirname);

        $result = [$basedir => []];
        $items = iterator_to_array(new \FilesystemIterator($dirname, \FilesystemIterator::SKIP_DOTS | \FilesystemIterator::CURRENT_AS_FILEINFO));
        usort($items, function (\SplFileInfo $a, \SplFileInfo $b) {
            if ($a->isDir() xor $b->isDir()) {
                return $a->isDir() - $b->isDir();
            }
            return strcmp($a->getPathname(), $b->getPathname());
        });
        foreach ($items as $item) {
            if ($item->isDir()) {
                $result[$basedir] += file_tree($item->getPathname(), $filter_condition);
            }
            else {
                if ($match($item)) {
                    $result[$basedir][$item->getBasename()] = $item->getPathname();
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\fnmatch_and') || (new \ReflectionFunction('ryunosuke\\ltsv\\fnmatch_and'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\fnmatch_and')) {
    /**
     * fnmatch の AND 版
     *
     * $patterns のうちどれか一つでもマッチしなかったら false を返す。
     * $patterns が空だと例外を投げる。
     *
     * Example:
     * ```php
     * // すべてにマッチするので true
     * that(fnmatch_and(['*aaa*', '*bbb*'], 'aaaXbbbX'))->isTrue();
     * // aaa にはマッチするが bbb にはマッチしないので false
     * that(fnmatch_and(['*aaa*', '*bbb*'], 'aaaX'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param array|string $patterns パターン配列（単一文字列可）
     * @param string $string 調べる文字列
     * @param int $flags FNM_***
     * @return bool すべてにマッチしたら true
     */
    function fnmatch_and($patterns, $string, $flags = 0)
    {
        $patterns = is_iterable($patterns) ? $patterns : [$patterns];
        if (is_empty($patterns)) {
            throw new \InvalidArgumentException('$patterns must be not empty.');
        }

        foreach ($patterns as $pattern) {
            if (!fnmatch($pattern, $string, $flags)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\fnmatch_or') || (new \ReflectionFunction('ryunosuke\\ltsv\\fnmatch_or'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\fnmatch_or')) {
    /**
     * fnmatch の OR 版
     *
     * $patterns のうちどれか一つでもマッチしたら true を返す。
     * $patterns が空だと例外を投げる。
     *
     * Example:
     * ```php
     * // aaa にマッチするので true
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'aaaX'))->isTrue();
     * // どれともマッチしないので false
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'cccX'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param array|string $patterns パターン配列（単一文字列可）
     * @param string $string 調べる文字列
     * @param int $flags FNM_***
     * @return bool どれかにマッチしたら true
     */
    function fnmatch_or($patterns, $string, $flags = 0)
    {
        $patterns = is_iterable($patterns) ? $patterns : [$patterns];
        if (is_empty($patterns)) {
            throw new \InvalidArgumentException('$patterns must be not empty.');
        }

        foreach ($patterns as $pattern) {
            if (fnmatch($pattern, $string, $flags)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\globstar') || (new \ReflectionFunction('ryunosuke\\ltsv\\globstar'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\globstar')) {
    /**
     * globstar（再帰パターン有効）な glob
     *
     * file_list でも代替可能だが、もっと手軽にササっとファイル一覧が欲しいこともある。
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $pattern glob パターン。** が使えること以外は glob と同じ
     * @param int $flags glob フラグ
     * @return ?array マッチしたファイル名配列
     */
    function globstar($pattern, $flags = 0)
    {
        $GLOB_NOESCAPE = $flags & GLOB_NOESCAPE;
        $GLOB_NOCHECK = $flags & GLOB_NOCHECK;
        $GLOB_NOSORT = $flags & GLOB_NOSORT;

        // \** は「アスターの後の任意の文字」という意味になるので再帰パターンではない
        // さらに Windows では \* も特別扱いされているようなのでそれに倣う
        // （Windows で "\*" は「エスケープされたアスター」なのか「ディレクトリ区切りの後の *」なのか判断ができないためと思われる）
        $backslash = ($GLOB_NOESCAPE || DIRECTORY_SEPARATOR === '\\') ? '' : '(?<!\\\\)';
        $patterns = preg_split("#$backslash\\*\\*#", $pattern, 2);

        $result = glob($pattern, $flags);

        if (count($patterns) === 1) {
            return $result === false ? null : $result;
        }

        foreach (glob($patterns[0] . '*', $flags & ~GLOB_NOCHECK & ~GLOB_MARK | GLOB_ONLYDIR) as $dir) {
            $subpattern = $dir . DIRECTORY_SEPARATOR . '**' . $patterns[1];
            $children = globstar($subpattern, $flags & ~GLOB_NOCHECK);
            if ($GLOB_NOCHECK && !$children) {
                return [$pattern];
            }

            $result = array_merge($result, $children);
        }

        if (!$GLOB_NOSORT) {
            sort($result);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mkdir_p') || (new \ReflectionFunction('ryunosuke\\ltsv\\mkdir_p'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mkdir_p')) {
    /**
     * ディレクトリを再帰的に掘る
     *
     * 既に存在する場合は何もしない（エラーも出さない）。
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname ディレクトリ名
     * @param int $umask ディレクトリを掘る際の umask
     * @return bool 作成したら true
     */
    function mkdir_p($dirname, $umask = 0002)
    {
        if (func_num_args() === 1) {
            $umask = umask();
        }

        if (file_exists($dirname)) {
            return false;
        }

        return mkdir($dirname, 0777 & (~$umask), true);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\path_is_absolute') || (new \ReflectionFunction('ryunosuke\\ltsv\\path_is_absolute'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\path_is_absolute')) {
    /**
     * パスが絶対パスか判定する
     *
     * Example:
     * ```php
     * that(path_is_absolute('/absolute/path'))->isTrue();
     * that(path_is_absolute('relative/path'))->isFalse();
     * // Windows 環境では下記も true になる
     * if (DIRECTORY_SEPARATOR === '\\') {
     *     that(path_is_absolute('\\absolute\\path'))->isTrue();
     *     that(path_is_absolute('C:\\absolute\\path'))->isTrue();
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス文字列
     * @return bool 絶対パスなら true
     */
    function path_is_absolute($path)
    {
        // スキームが付いている場合は path 部分で判定
        $parts = parse_url($path);
        if (isset($parts['scheme'], $parts['path'])) {
            $path = $parts['path'];
        }
        elseif (isset($parts['scheme'], $parts['host'])) {
            $path = $parts['host'];
        }

        if (substr($path, 0, 1) === '/') {
            return true;
        }

        if (DIRECTORY_SEPARATOR === '\\') {
            if (preg_match('#^([a-z]+:(\\\\|/|$)|\\\\)#i', $path) !== 0) {
                return true;
            }
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\path_normalize') || (new \ReflectionFunction('ryunosuke\\ltsv\\path_normalize'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\path_normalize')) {
    /**
     * パスを正規化する
     *
     * 具体的には ./ や ../ を取り除いたり連続したディレクトリ区切りをまとめたりする。
     * realpath ではない。のでシンボリックリンクの解決などはしない。その代わりファイルが存在しなくても使用することができる。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_normalize('/path/to/something'))->isSame("{$DS}path{$DS}to{$DS}something");
     * that(path_normalize('/path/through/../something'))->isSame("{$DS}path{$DS}something");
     * that(path_normalize('./path/current/./through/../something'))->isSame("path{$DS}current{$DS}something");
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス文字列
     * @return string 正規化されたパス
     */
    function path_normalize($path)
    {
        $DS = DIRECTORY_SEPARATOR;

        // スキームの保護
        $with_scheme = false;
        $scheme = parse_url($path, PHP_URL_SCHEME);
        if (!($scheme === null || $scheme === 'file') && substr($path, strlen($scheme), 3) === '://') {
            $path = substr($path, strlen($scheme) + 3);
            $DS = '/';
            $with_scheme = true;
        }

        $delimiter = '/';
        if ($DS === '\\') {
            $delimiter .= '\\\\';
        }

        $result = [];
        foreach (preg_split("#[$delimiter]+#u", $path) as $part) {
            if ($part === '.') {
                continue;
            }
            if ($part === '..') {
                if (empty($result)) {
                    throw new \InvalidArgumentException("'$path' is invalid as path string.");
                }
                array_pop($result);
                continue;
            }
            $result[] = $part;
        }
        if (count($result) > 2 && $result[count($result) - 1] === '') {
            array_pop($result);
        }

        $path = implode($DS, $result);

        if ($with_scheme) {
            $path = "$scheme://$path";
        }

        return $path;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\path_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\path_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\path_parse')) {
    /**
     * パスをパースする
     *
     * pathinfo の（ほぼ）上位互換で下記の差異がある。
     * - drive: Windows 環境におけるドライブ文字
     * - root: 絶対パスの場合はルートパス
     * - parents: 正規化したディレクトリ名の配列
     * - dirnames: ディレクトリ名の配列（余計なことはしない）
     * - localname: 複数拡張子を考慮した本当のファイル名部分
     * - localpath: ディレクトリ名（余計なことはしない）＋複数拡張子を考慮した本当のファイル名部分（フルパス - 拡張子）
     * - extensions: 複数拡張子の配列（余計なことはしない）
     *
     * 「余計なことはしない」とは空文字をフィルタしたりパスを正規化したりを指す。
     * 結果のキーはバージョンアップで増えることがある（その場合は互換性破壊とはみなさない）。
     *
     * なお、いわゆる URL はサポートしない（スキーム付きを与えた場合の挙動は未定義）。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * // 色々混ぜたサンプル
     * that(path_parse('C:/dir1/.././dir2/file.sjis..min.js'))->is([
     *     "dirname"    => "C:/dir1/.././dir2",
     *     "basename"   => "file.sjis..min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis..min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "C:",
     *     "root"       => "/",                          // 環境依存しない元のルートパス
     *     "parents"    => ["dir2"],                     // 正規化されたディレクトリ配列
     *     "dirnames"   => ["dir1", "..", ".", "dir2"],  // 余計なことをしていないディレクトリ配列
     *     "localname"  => "file",                       // 複数拡張子を考慮した本当のファイル名部分
     *     "localpath"  => "C:/dir1/.././dir2{$DS}file", // ↑にディレクトリ名を付与したもの
     *     "extensions" => ["sjis", "", "min", "js"],    // 余計なことをしていない拡張子配列
     * ]);
     * // linux における絶対パス
     * that(path_parse('/dir1/dir2/file.sjis.min.js'))->is([
     *     "dirname"    => "/dir1/dir2",
     *     "basename"   => "file.sjis.min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis.min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "",                    // 環境を問わず空
     *     "root"       => "/",                   // 絶対パスなので "/"
     *     "parents"    => ["dir1", "dir2"],      // ..等がないので dirnames と同じ
     *     "dirnames"   => ["dir1", "dir2"],      // ディレクトリ配列
     *     "localname"  => "file",
     *     "localpath"  => "/dir1/dir2{$DS}file",
     *     "extensions" => ["sjis", "min", "js"], // 余計なことをしていない拡張子配列
     * ]);
     * // linux における相対パス
     * that(path_parse('dir1/dir2/file.sjis.min.js'))->is([
     *     "dirname"    => "dir1/dir2",
     *     "basename"   => "file.sjis.min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis.min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "",
     *     "root"       => "",                    // 相対パスなので空（ここ以外は絶対パスと同じ）
     *     "parents"    => ["dir1", "dir2"],
     *     "dirnames"   => ["dir1", "dir2"],
     *     "localname"  => "file",
     *     "localpath"  => "dir1/dir2{$DS}file",
     *     "extensions" => ["sjis", "min", "js"],
     * ]);
     * // ディレクトリ無し
     * that(path_parse('file.sjis.min.js'))->is([
     *     "dirname"    => ".",
     *     "basename"   => "file.sjis.min.js",
     *     "extension"  => "js",
     *     "filename"   => "file.sjis.min",
     *     // ここまでオリジナルの pathinfo 結果
     *     "drive"      => "",
     *     "root"       => "",
     *     "parents"    => [], // オリジナルの pathinfo のようにドットが紛れ込んだりはしない
     *     "dirnames"   => [], // オリジナルの pathinfo のようにドットが紛れ込んだりはしない
     *     "localname"  => "file",
     *     "localpath"  => "file",
     *     "extensions" => ["sjis", "min", "js"],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス
     * @return array パス情報
     */
    function path_parse($path)
    {
        $DS = DIRECTORY_SEPARATOR === '\\' ? '\\/' : '/';

        // キーが存在しないことがあるので順番も含めて正規化する
        $pathinfo = array_replace([
            'dirname'   => '',
            'basename'  => '',
            'extension' => '',
            'filename'  => '',
        ], pathinfo($path));

        $result = $pathinfo;

        // pathinfo の直感的でない挙動を補正する（dirname が . を返したり C:/ の結果が曖昧だったり）
        if ($pathinfo['dirname'] === '.') {
            $pathinfo['dirname'] = '';
        }
        if (DIRECTORY_SEPARATOR === '\\' && strlen(rtrim($path, '\\')) === 2) {
            $pathinfo['basename'] = '';
            $pathinfo['extension'] = '';
            $pathinfo['filename'] = '';
        }
        $dirnames = preg_split("#([" . preg_quote($DS) . "]+)#u", $pathinfo['dirname'], -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
        $basenames = explode('.', $pathinfo['basename']);

        $result['drive'] = '';
        if (isset($dirnames[0]) && preg_match('#^[a-z]:$#ui', $dirnames[0])) {
            $result['drive'] = array_shift($dirnames);
        }

        $result['root'] = '';
        if (isset($dirnames[0]) && strpbrk($dirnames[0], $DS) !== false) {
            $result['root'] = array_shift($dirnames);
        }

        $result['parents'] = array_reduce($dirnames, function ($carry, $dirname) use ($DS) {
            if (strpbrk($dirname, $DS) !== false || $dirname === '.') {
                return $carry;
            }
            if ($dirname === '..') {
                return array_slice($carry, 0, -1);
            }
            else {
                return array_merge($carry, [$dirname]);
            }
        }, []);

        $result['dirnames'] = array_reduce($dirnames, function ($carry, $dirname) use ($DS) {
            if (strpbrk($dirname, $DS) === false) {
                return array_merge($carry, [$dirname]);
            }
            else {
                return array_merge($carry, array_pad([], strlen($dirname) - 1, ''));
            }
        }, []);

        $result['localname'] = array_shift($basenames);
        $result['localpath'] = implode(DIRECTORY_SEPARATOR, array_filter([$pathinfo['dirname'], $result['localname']], 'strlen'));
        $result['extensions'] = $basenames;

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\path_relative') || (new \ReflectionFunction('ryunosuke\\ltsv\\path_relative'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\path_relative')) {
    /**
     * パスを相対パスに変換して正規化する
     *
     * $from から $to への相対パスを返す。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_relative('/a/b/c/X', '/a/b/c/d/X'))->isSame("..{$DS}d{$DS}X");
     * that(path_relative('/a/b/c/d/X', '/a/b/c/X'))->isSame("..{$DS}..{$DS}X");
     * that(path_relative('/a/b/c/X', '/a/b/c/X'))->isSame("");
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $from 元パス
     * @param string $to 対象パス
     * @return string 相対パス
     */
    function path_relative($from, $to)
    {
        $DS = DIRECTORY_SEPARATOR;

        $fa = array_filter(explode($DS, path_resolve($from) ?? $from), 'strlen');
        $ta = array_filter(explode($DS, path_resolve($to) ?? $to), 'strlen');

        $compare = fn($a, $b) => $DS === '\\' ? strcasecmp($a, $b) : strcmp($a, $b);
        $ca = array_udiff_assoc($fa, $ta, $compare);
        $da = array_udiff_assoc($ta, $fa, $compare);

        return str_repeat("..$DS", count($ca)) . implode($DS, $da);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\path_resolve') || (new \ReflectionFunction('ryunosuke\\ltsv\\path_resolve'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\path_resolve')) {
    /**
     * パスを絶対パスに変換して正規化する
     *
     * 可変引数で与えられた文字列群を結合して絶対パス化して返す。
     * 出来上がったパスが絶対パスでない場合は PATH 環境変数を使用して解決を試みる。
     * それでも絶対パスにできない場合は null を返す。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_resolve('/absolute/path'))->isSame("{$DS}absolute{$DS}path");
     * that(path_resolve('/absolute/path/through', '../current/./path'))->isSame("{$DS}absolute{$DS}path{$DS}current{$DS}path");
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string ...$paths パス文字列（可変引数）
     * @return ?string 絶対パス
     */
    function path_resolve(...$paths)
    {
        $DS = DIRECTORY_SEPARATOR;

        $path = implode($DS, $paths);

        if (!path_is_absolute($path)) {
            foreach ([getcwd(), getenv('PATH')] as $p) {
                foreach (explode(PATH_SEPARATOR, $p) as $dir) {
                    if (file_exists("$dir/$path")) {
                        return path_normalize("$dir/$path");
                    }
                }
            }
            return null;
        }

        return path_normalize($path);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\rm_rf') || (new \ReflectionFunction('ryunosuke\\ltsv\\rm_rf'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\rm_rf')) {
    /**
     * 中身があっても消せる rmdir
     *
     * Example:
     * ```php
     * mkdir(sys_get_temp_dir() . '/new/make/dir', 0777, true);
     * rm_rf(sys_get_temp_dir() . '/new');
     * that(file_exists(sys_get_temp_dir() . '/new'))->isSame(false);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname 削除するディレクトリ名。glob パターンが使える
     * @param bool $self 自分自身も含めるか。false を与えると中身だけを消す
     * @return bool 成功した場合に TRUE を、失敗した場合に FALSE を返します
     */
    function rm_rf($dirname, $self = true)
    {
        $main = static function ($dirname, $self) {
            if (!file_exists($dirname)) {
                return false;
            }

            $rdi = new \RecursiveDirectoryIterator($dirname, \FilesystemIterator::SKIP_DOTS);
            $rii = new \RecursiveIteratorIterator($rdi, \RecursiveIteratorIterator::CHILD_FIRST);

            foreach ($rii as $it) {
                if ($it->isFile() || $it->isLink()) {
                    unlink($it->getPathname());
                }
                else {
                    rmdir($it->getPathname());
                }
            }

            return !$self || rmdir($dirname);
        };

        if (is_file($dirname) || is_link($dirname)) {
            return unlink($dirname);
        }
        // ↓で glob してるので、ディレクトリ判定しないとリモートファイルに対応できない
        if (is_dir($dirname)) {
            return $main($dirname, $self);
        }

        $result = true;
        $targets = glob($dirname, GLOB_BRACE | GLOB_NOCHECK | ($self ? 0 : GLOB_ONLYDIR));
        foreach ($targets as $target) {
            $result = $main($target, $self) && $result;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\rsync') || (new \ReflectionFunction('ryunosuke\\ltsv\\rsync'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\rsync')) {
    /**
     * php レイヤーで rsync 的なことをする
     *
     * rsync プロトコルを喋ったりオプションを完全網羅していたりはしない（意図的に合わせたりはしているが）。
     * 単純に必要に迫られて実装したものであり、効率も度外視。
     *
     * generator で実装されており、動作ログを generate する。
     * generator は返り値として統計情報を返す。
     *
     * ただの劣化 rsync だが php 実装なのでストリームラッパーさえ実装すればプロトコルを超えることができる。
     * やる気になればリモート間転送も可能（自身経由なので速度は劣悪になるが）。
     * つまり file -> S3 や S3 -> S3 等も可能。
     *
     * generate される文字列は互換性を担保しない。
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $src 送信側ディレクトリ
     * @param string $dst 受信側ディレクトリ
     * @param array $options オプション
     * @return \Generator 動作ログを返す generator
     */
    function rsync($src, $dst, $options = [])
    {
        $rsyncer = new class($options + [
                // important
                'dry-run'          => false,         // 実際には転送せずログのみを出す
                'block-size'       => 4096,          // ファイル比較に使用するチャンクサイズ
                // transmit
                'exclude'          => [],            // 除外パターン（**が使える glob パターン。~始まりで正規表現）
                'include'          => [],            // 許可パターン（除外されていてもこれにマッチすれば転送される）
                'update'           => false,         // 受信側の方が新しい場合は転送しない
                'delete'           => false,         // 送信側にないファイルを削除する
                'delete-excluded'  => false,         // ファイルリスト外のファイルを削除する
                // transfer
                'times'            => true,          // タイムスタンプを維持する
                'perms'            => true,          // パーミッションを維持する
                'owner'            => true,          // ファイルオーナーを維持する
                'group'            => true,          // ファイルグループを維持する
                // output
                'log-format'       => '%-6s %s=>%s, %s=>%s, %s:%s=>%s:%s, %s=>%s', // null 指定で raw な配列で返ってくる（実質的にデバッグ用）
                'diff'             => 'split=1,160', // ファイル差分も合わせて表示するときのオプション（null 指定で差分表示なし）
                'human-readable'   => false,         // 出力を見やすく整形する
                'verbose'          => 0,             // ログの詳細度（0:出力なし, 1:ファイルリストのみ, 2:1+記号, 3:2+詳細）
                'verbose-excluded' => true,          // excluded されたものでも verbose ログに含める
                'ansi'             => null,          // ansi color フラグ
            ]) {
            const DIFF_TIMES   = 1 << 1;
            const DIFF_PERMS   = 1 << 2;
            const DIFF_OWNER   = 1 << 3;
            const DIFF_GROUP   = 1 << 4;
            const DIFF_CONTENT = 1 << 32;

            const OPERATION_SIGNS = [
                'exclude' => '!',
                'mkdir'   => '+',
                'rmdir'   => '-',
                'create'  => '+',
                'delete'  => '-',
                'update'  => '*',
            ];

            const OPERATION_STYLES = [
                'exclude' => 'gray',
                'mkdir'   => 'green',
                'create'  => 'green',
                'update'  => 'yellow',
                'rmdir'   => 'red',
                'delete'  => 'red',
            ];

            private array $options;
            private array $stats = [];

            public function __construct(array $options)
            {
                $options['verbose'] = (int) $options['verbose'];
                $options['ansi'] ??= is_ansi(STDOUT);
                $toregex = function ($pattern) {
                    if ($pattern[0] === '~') {
                        return substr($pattern, 1);
                    }
                    // この動作は rsync に合わせてある
                    $regex = glob2regex($pattern, GLOB_RECURSIVE) . '$';
                    if ($pattern[0] === '/') {
                        return '^' . $regex;
                    }
                    else {
                        return '(^|/)' . $regex;
                    }
                };
                $options['exclude'] = array_map($toregex, (array) $options['exclude']);
                $options['include'] = array_map($toregex, (array) $options['include']);

                $this->options = $options;
            }

            public function __invoke(string $src, string $dst): \Generator
            {
                if (!is_dir($src)) {
                    throw new \UnexpectedValueException("$src is not directory");
                }
                if (is_file($dst)) {
                    throw new \UnexpectedValueException("$dst is not directory");
                }

                $reports = array_fill_keys(['mkdir', 'rmdir', 'create', 'update', 'delete', 'size'], 0);
                $reports += array_fill_keys(array_map(fn($k) => "!$k", array_keys($reports)), 0);
                $reports['errors'] = [];
                $reports['start'] = microtime(true);

                $shortnames = [];
                $fileist = array_filter($this->filelist($src, $dst), function ($diff, $filename) use (&$shortnames) {
                    // 差分がない場合 delete-excluded でない限りはファイルリストとして不要（逆に言えば delete-excluded の時は必要）
                    if ($diff === 0 && !$this->options['delete-excluded']) {
                        return false;
                    }
                    $shortnames[$filename] = mb_ellipsis($filename, 80, '...');
                    return true;
                }, ARRAY_FILTER_USE_BOTH);
                $reports['listing'] = microtime(true);

                $maxlength = max(array_map(fn($v) => mb_monospace($v), $shortnames ?: ['']));

                set_error_handler(function ($errno, $errstr, $errfile, $errline) use (&$reports) {
                    if (!(error_reporting() & $errno)) {
                        return false;
                    }
                    // @codeCoverageIgnoreStart 除外パターン次第でたまにエラーが出るがテストまではしない
                    $reports['errors'][] = [
                        'severity' => $errno,
                        'message'  => $errstr,
                        'filename' => $errfile,
                        'line'     => $errline,
                    ];
                    // @codeCoverageIgnoreEnd
                });
                try {
                    foreach ($fileist as $filename => $diff) {
                        $srcfile = "$src/$filename";
                        $dstfile = "$dst/$filename";

                        $matches = true;
                        foreach ($this->options['exclude'] as $exclude) {
                            if (preg_match("<$exclude>u", "/$filename")) {
                                $matches = false;
                                foreach ($this->options['include'] as $include) {
                                    if (preg_match("<$include>u", "/$filename")) {
                                        $matches = true;
                                        break;
                                    }
                                }
                                break;
                            }
                        }

                        // 自分だけに有る時
                        if ($diff === true) {
                            $operation = ($this->stat($srcfile)['mode'] & 0040_000) ? 'mkdir' : 'create';
                            $excluded = !$matches;
                            $reports[($excluded ? '!' : '') . $operation]++;
                            $reports[($excluded ? '!' : '') . 'size'] += $this->stat($srcfile)['size'];
                        }
                        // 相手だけに有る時
                        elseif ($diff === false) {
                            $operation = ($this->stat($dstfile)['mode'] & 0040_000) ? 'rmdir' : 'delete';
                            $excluded = !$this->options['delete'] || !$matches;
                            $reports[($excluded ? '!' : '') . $operation]++;
                            $reports[($excluded ? '!' : '') . 'size'] += 0;
                        }
                        // 自分にも相手にも有る時
                        else {
                            // マッチしておらず delete-excluded の時は実質的に削除処理（超危険だが rsync はそうなってる）
                            if (!$matches && $this->options['delete-excluded']) {
                                $operation = ($this->stat($dstfile)['mode'] & 0040_000) ? 'rmdir' : 'delete';
                                $excluded = false;
                            }
                            else {
                                $operation = 'update';
                                $excluded = $this->options['update'] && $this->stat($srcfile)['mtime'] < $this->stat($dstfile)['mtime'] || !$matches;
                            }
                            $reports[($excluded ? '!' : '') . $operation]++;
                            $reports[($excluded ? '!' : '') . 'size'] += $this->stat($srcfile)['size'];
                        }

                        yield from $this->sync($shortnames[$filename], $srcfile, $dstfile, $operation, $excluded, $maxlength);
                    }
                }
                finally {
                    restore_error_handler();
                }
                $reports['syncing'] = microtime(true);

                $results = [
                    'time'     => [
                        'total'   => microtime(true) - $reports['start'],
                        'listing' => $reports['listing'] - $reports['start'],
                        'syncing' => $reports['syncing'] - $reports['listing'],
                    ],
                    'count'    => [
                        'files' => count($fileist),
                    ],
                    'transfer' => [
                        'mkdir'  => $reports['mkdir'],
                        'rmdir'  => $reports['rmdir'],
                        'create' => $reports['create'],
                        'update' => $reports['update'],
                        'delete' => $reports['delete'],
                        'size'   => $reports['size'],
                    ],
                    'excluded' => [
                        'mkdir'  => $reports['!mkdir'],
                        'rmdir'  => $reports['!rmdir'],
                        'create' => $reports['!create'],
                        'update' => $reports['!update'],
                        'delete' => $reports['!delete'],
                        'size'   => $reports['!size'],
                    ],
                    'errors'   => $reports['errors'],
                ];

                if ($this->options['log-format'] !== null) {
                    $outstats = function ($data) {
                        return sprintf("mkdir: %s, rmdir: %s, create: %s, update: %s, delete: %s, size: %s",
                            $this->format('int', $data['mkdir']),
                            $this->format('int', $data['rmdir']),
                            $this->format('int', $data['create']),
                            $this->format('int', $data['update']),
                            $this->format('int', $data['delete']),
                            $this->format('byte', $data['size']),
                        );
                    };
                    $results = <<<STATS
                        times total: {$this->format('float', $results['time']['total'])}, listing: {$this->format('float', $results['time']['listing'])}, syncing: {$this->format('float', $results['time']['syncing'])} seconds
                        total file: {$this->format('int', $results['count']['files'])} files
                        transfer {$outstats($results['transfer'])}
                        excluded {$outstats($results['excluded'])}
                        errors: {$this->format('int', count($results['errors']))}
                        STATS;
                }
                return $results;
            }

            private function filelist(string $src, string $dst): array
            {
                // ファイルリスト
                $filelist = dir_diff($src, $dst, [
                    'unixpath' => true,
                    'differ'   => function ($file1, $file2) {
                        $stat1 = $this->stat($file1);
                        $stat2 = $this->stat($file2);

                        // メタ系の差分はメタ系だけで返す（どうせコピーするので中身を比較するまでもない）
                        $meta = 0;
                        $meta |= ($this->options['times'] && $stat1['mtime'] !== $stat2['mtime']) ? self::DIFF_TIMES : 0;
                        $meta |= ($this->options['perms'] && $stat1['mode'] !== $stat2['mode']) ? self::DIFF_PERMS : 0;
                        $meta |= ($this->options['owner'] && $stat1['uid'] !== $stat2['uid']) ? self::DIFF_OWNER : 0;
                        $meta |= ($this->options['group'] && $stat1['gid'] !== $stat2['gid']) ? self::DIFF_GROUP : 0;
                        if ($meta) {
                            return $meta;
                        }

                        if (!file_equals($file1, $file2, $this->options['block-size'])) {
                            return self::DIFF_CONTENT;
                        }
                        return 0;
                    },
                ]);

                // 追加は親から、削除は子からになるように並べ替え
                $filelist = groupsort($filelist, function ($v, $k) {
                    static $current = null;
                    if ($v !== false) {
                        return $current = null;
                    }
                    if ($current === null || strpos($k, $current) === false) {
                        return $current = $k;
                    }
                    return $current; // @codeCoverageIgnore
                }, fn($a, $b, $ak, $bk) => $bk <=> $ak);

                // 受信側に大本が存在しない場合はリストに加える
                if (!$this->stat($dst)) {
                    $filelist = ['/' => true] + $filelist;
                }

                return $filelist;
            }

            private function sync(string $filename, string $srcfile, string $dstfile, string $operation, bool $excluded, int $maxlength)
            {
                $log = null;
                if (!$excluded || $this->options['verbose-excluded']) {
                    if ($this->options['verbose'] >= 1) {
                        $log = [
                            'sign' => null,
                            'src'  => null,
                            'dst'  => null,
                            'diff' => null,
                        ];

                        if ($this->options['verbose'] >= 2) {
                            $log['sign'] = ($excluded ? '!' : '') . self::OPERATION_SIGNS[$operation];
                        }

                        if ($this->options['verbose'] >= 3) {
                            $log['src'] = $this->stat($srcfile);
                            $log['dst'] = $this->stat($dstfile);

                            if ($this->options['diff'] && $operation === 'update') {
                                $log['diff'] = try_close(function ($dstfp, $srcfp) {
                                    return rtrim(str_diff($dstfp, $srcfp, [
                                        'allow-binary' => null,
                                        'stringify'    => $this->options['diff'],
                                    ]));
                                }, fopen($dstfile, 'rb'), fopen($srcfile, 'rb'));
                            }
                        }

                        if ($this->options['log-format'] !== null) {
                            $prefix = $filename;
                            if (isset($log['sign'])) {
                                $prefix = $log['sign'] . $prefix;
                            }
                            $logstring = $this->options['ansi'] ? ansi_colorize($prefix, self::OPERATION_STYLES[$excluded ? 'exclude' : $operation]) : $prefix;

                            if (isset($log['src'], $log['dst'])) {
                                $logstring .= str_repeat(' ', $maxlength - mb_monospace($prefix) + 3);
                                $logstring .= sprintf($this->options['log-format'],
                                    $operation,
                                    $this->format('mode', $log['dst']['mode'] ?? null) ?? '(none)',
                                    $this->format('mode', $log['src']['mode'] ?? null) ?? '(none)',
                                    $this->format('time', $log['dst']['mtime'] ?? null) ?? '(none)',
                                    $this->format('time', $log['src']['mtime'] ?? null) ?? '(none)',
                                    $this->format('owner', $log['dst']['uid'] ?? null) ?? '(none)',
                                    $this->format('group', $log['dst']['gid'] ?? null) ?? '(none)',
                                    $this->format('owner', $log['src']['uid'] ?? null) ?? '(none)',
                                    $this->format('group', $log['src']['gid'] ?? null) ?? '(none)',
                                    $this->format('byte', $log['dst']['size'] ?? null) ?? '(none)',
                                    $this->format('byte', $log['src']['size'] ?? null) ?? '(none)',
                                );
                            }
                            if (strlen($log['diff'] ?? '')) {
                                $logstring .= "\n" . $log['diff'];
                            }
                            $log = $logstring;
                        }
                    }
                }

                if (!$this->options['dry-run'] && !$excluded) {
                    static $functions = null;
                    $functions ??= [
                        'mkdir'  => static fn($src, $dst) => mkdir($dst, 0777, true),
                        'rmdir'  => static fn($src, $dst) => rmdir($dst),
                        'create' => static fn($src, $dst) => copy($src, $dst),
                        'update' => static fn($src, $dst) => copy($src, $dst),
                        'delete' => static fn($src, $dst) => unlink($dst),
                    ];
                    $functions[$operation]($srcfile, $dstfile);

                    // メタだけの変更を検出してメタ変更だけする、ということはしない
                    // 「メタだけの変更」を検出するためには中身を比較して同じである、という検出が必要
                    // そんなことをするくらいなら比較せずコピーしてしまった方がマシまである
                    if (in_array($operation, ['mkdir', 'create', 'update'], true)) {
                        if ($this->options['times']) {
                            touch($dstfile, $this->stat($srcfile)['mtime']);
                        }
                        if ($this->options['perms']) {
                            chmod($dstfile, $this->stat($srcfile)['mode'] & 0777);
                        }
                        if ($this->options['owner']) {
                            chown($dstfile, $this->stat($srcfile)['uid']);
                        }
                        if ($this->options['group']) {
                            chgrp($dstfile, $this->stat($srcfile)['gid']);
                        }
                    }
                }

                return isset($log) ? [$filename => $log] : [];
            }

            private function stat(string $fullpath): array
            {
                // リモートを扱うこともあるので stat を完全にキャッシュする
                $fullpath = strtr($fullpath, [DIRECTORY_SEPARATOR => '/']);
                return $this->stats[$fullpath] ??= (function ($fullpath) {
                    $stat = @stat($fullpath);
                    if ($stat === false) {
                        return [];
                    }
                    // array モードで邪魔なので数値は伏せる
                    $stat = array_filter($stat, fn($k) => !is_int($k), ARRAY_FILTER_USE_KEY);
                    // ディレクトリのサイズ（ブロックサイズ）が得られることがあるが無視して強制0とする
                    if ($stat['mode'] & 0040_000) {
                        $stat['size'] = 0;
                    }
                    return $stat;
                })($fullpath);
            }

            private function format(string $mode, null|int|float $var): ?string
            {
                if ($var === null) {
                    return null;
                }
                if ($this->options['human-readable']) {
                    switch ($mode) {
                        case 'int':
                            return number_format($var);
                        case 'float':
                            return number_format($var, 3);
                        case 'byte':
                            return si_prefix($var, 1024, '%.1f %sbytes');
                        case 'time':
                            return date('Y/m/d H:i:s', $var);
                        case 'mode':
                            return strmode($var);
                        case 'owner':
                            return function_exists('posix_getpwuid') ? posix_getpwuid($var)['name'] : $var;
                        case 'group':
                            return function_exists('posix_getgrgid') ? posix_getgrgid($var)['name'] : $var;
                    }
                }
                else {
                    switch ($mode) {
                        default:
                            return $var;
                        case 'byte':
                            return "$var byte";
                        case 'time':
                            return date('Ymd\THis', $var);
                        case 'mode':
                            return str_pad(decoct($var), 7, '0', STR_PAD_LEFT);
                    }
                }
            }
        };

        return $rsyncer($src, $dst);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strmode') || (new \ReflectionFunction('ryunosuke\\ltsv\\strmode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strmode')) {
    /**
     * 8進数値を ls -l 準拠なパーミッション文字列に変換する
     *
     * 000_0000 のような6桁を想定しているが、 0000 のような3桁でも受け入れる。
     * その場合、ファイル種別のプレフィックスは付与されず、 "rwxrwxrwx" のような9文字を返す。
     *
     * Example:
     * ```php
     * // 通常ファイル 0700
     * that(strmode(010_0700))->is('-rwx------');
     * // ディレクトリ 0770
     * that(strmode(004_0770))->is('drwxrwx---');
     * // ファイル種別はなくても良い
     * that(strmode(0770))->is('rwxrwx---');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param int $octet 8進数
     * @return string パーミッション文字列（ls -l 準拠）
     */
    function strmode($octet)
    {
        if (!ctype_digit("$octet")) {
            throw new \InvalidArgumentException("\$octet must be int ($octet given)");
        }
        $octet = (int) $octet;

        $map = [
            000_0000 => '',
            001_0000 => 'p',
            002_0000 => 'c',
            004_0000 => 'd',
            006_0000 => 'b',
            010_0000 => '-',
            012_0000 => 'l',
            014_0000 => 's',
        ];

        $result = '';

        $type = $octet & 077_0000;
        if (!isset($map[$type])) {
            throw new \InvalidArgumentException("unknown type " . decoct($type));
        }
        $result .= $map[$type];

        // user
        $result .= (($octet & 0400) ? 'r' : '-');
        $result .= (($octet & 0200) ? 'w' : '-');
        $result .= (($octet & 0100) ? (($octet & 0_4000) ? 's' : 'x') : (($octet & 0_4000) ? 'S' : '-'));

        // group
        $result .= (($octet & 0040) ? 'r' : '-');
        $result .= (($octet & 0020) ? 'w' : '-');
        $result .= (($octet & 0010) ? (($octet & 0_2000) ? 's' : 'x') : (($octet & 0_2000) ? 'S' : '-'));

        // other
        $result .= (($octet & 0004) ? 'r' : '-');
        $result .= (($octet & 0002) ? 'w' : '-');
        $result .= (($octet & 0001) ? (($octet & 0_1000) ? 't' : 'x') : (($octet & 0_1000) ? 'T' : '-'));

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strmode2oct') || (new \ReflectionFunction('ryunosuke\\ltsv\\strmode2oct'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strmode2oct')) {
    /**
     * ls -l 準拠なパーミッション文字列を8進数値に変換する
     *
     * drwxrwxrwx のような10文字を想定しているが、 rwxrwxrwx のような9文字でも受け入れる。
     *
     * set や sticky は現時点では未対応。
     *
     * Example:
     * ```php
     * // 通常ファイル rwx------
     * that(strmode2oct('-rwx------'))->is(010_0700);
     * // ディレクトリ rwxrwx---
     * that(strmode2oct('drwxrwx---'))->is(004_0770);
     * // 9文字でも良い
     * that(strmode2oct('rwxrwx---'))->is(0770);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $perms パーミッション文字列（ls -l 準拠）
     * @return int 8進数
     */
    function strmode2oct($perms)
    {
        if (!preg_match('#^(?<type>[pcdb\-ls])?(?<user>[\-r][\-w][\-xsS])(?<group>[\-r][\-w][\-xsS])(?<other>[\-r][\-w][\-xtT])$#', $perms, $matches)) {
            throw new \InvalidArgumentException("$perms is failed to parse. invalid permission");
        }

        $map = [
            'type'  => [
                ''  => 000_0000,
                'p' => 001_0000,
                'c' => 002_0000,
                'd' => 004_0000,
                'b' => 006_0000,
                '-' => 010_0000,
                'l' => 012_0000,
                's' => 014_0000,
            ],
            'user'  => [
                '-' => 000_0000,
                'r' => 000_0400,
                'w' => 000_0200,
                'x' => 000_0100,
                'S' => 000_4000,
                's' => 000_4100,
            ],
            'group' => [
                '-' => 000_0000,
                'r' => 000_0040,
                'w' => 000_0020,
                'x' => 000_0010,
                'S' => 000_2000,
                's' => 000_2010,
            ],
            'other' => [
                '-' => 000_0000,
                'r' => 000_0004,
                'w' => 000_0002,
                'x' => 000_0001,
                'T' => 000_1000,
                't' => 000_1001,
            ],
        ];

        $result = 0;

        foreach (['type', 'user', 'group', 'other'] as $class) {
            foreach (str_split($matches[$class]) as $char) {
                $result += $map[$class][$char];
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\tmpname') || (new \ReflectionFunction('ryunosuke\\ltsv\\tmpname'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\tmpname')) {
    /**
     * 終了時に削除される一時ファイル名を生成する
     *
     * tempnam とほぼ同じで違いは下記。
     *
     * - 引数が逆
     * - 終了時に削除される
     * - 失敗時に false を返すのではなく例外を投げる
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $prefix ファイル名プレフィックス
     * @param ?string $dir 生成ディレクトリ。省略時は sys_get_temp_dir()
     * @return string 一時ファイル名
     */
    function tmpname($prefix = 'rft', $dir = null)
    {
        // デフォルト付きで tempnam を呼ぶ
        $dir = $dir ?: function_configure('cachedir');
        $tempfile = tempnam($dir, $prefix);

        // tempnam が何をしても false を返してくれないんだがどうしたら返してくれるんだろうか？
        if ($tempfile === false) {
            throw new \UnexpectedValueException("tmpname($dir, $prefix) failed.");// @codeCoverageIgnore
        }

        // 生成したファイルを覚えておいて最後に消す
        static $files = [];
        $files[$tempfile] = new class($tempfile) {
            private $tempfile;

            public function __construct($tempfile) { $this->tempfile = $tempfile; }

            public function __destruct() { return $this(); }

            public function __invoke()
            {
                // 明示的に消されたかもしれないので file_exists してから消す
                if (file_exists($this->tempfile)) {
                    // レースコンディションのため @ を付ける
                    @unlink($this->tempfile);
                }
            }
        };

        return $tempfile;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\by_builtin') || (new \ReflectionFunction('ryunosuke\\ltsv\\by_builtin'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\by_builtin')) {
    /**
     * Countable#count, Serializable#serialize などの「ネイティブ由来かメソッド由来か」を判定して返す
     *
     * Countable#count, Serializable#serialize のように「インターフェースのメソッド名」と「ネイティブ関数名」が一致している必要がある。
     *
     * Example:
     * ```php
     * class CountClass implements \Countable
     * {
     *     public function count(): int {
     *         // count 経由なら 1 を、メソッド経由なら 0 を返す
     *         return (int) by_builtin($this, 'count');
     *     }
     * }
     * $counter = new CountClass();
     * that(count($counter))->isSame(1);
     * that($counter->count())->isSame(0);
     * ```
     *
     * のように判定できる。
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param object|string $class
     * @param string $function
     * @return bool ネイティブなら true
     */
    function by_builtin($class, $function)
    {
        $class = is_object($class) ? get_class($class) : $class;

        // 特殊な方法でコールされる名前達(コールスタックの大文字小文字は正規化されるので気にする必要はない)
        $invoker = [
            'call_user_func'       => true,
            'call_user_func_array' => true,
            'invoke'               => true,
            'invokeArgs'           => true,
        ];

        $traces = array_reverse(debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3));
        foreach ($traces as $trace) {
            if (isset($trace['class'], $trace['function']) && $trace['class'] === $class && $trace['function'] === $function) {
                // for $object->func()
                if (isset($trace['file'], $trace['line'])) {
                    return false;
                }
                // for call_user_func([$object, 'func']), (new ReflectionMethod($object, 'func'))->invoke($object)
                elseif (isset($last) && isset($last['function']) && isset($invoker[$last['function']])) {
                    return false;
                }
                // for func($object)
                elseif (isset($last) && isset($last['function']) && $last['function'] === $function) {
                    return true;
                }
            }
            $last = $trace;
        }
        throw new \RuntimeException('failed to search backtrace.');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\chain') || (new \ReflectionFunction('ryunosuke\\ltsv\\chain'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\chain')) {
    /**
     * 関数をメソッドチェーンできるオブジェクトを返す
     *
     * ChainObject という関数をチェーンできるオブジェクトを返す。
     * ChainObject は大抵のグローバル関数がアノテーションされており、コード補完することが出来る（利便性のためであり、IDE がエラーなどを出しても呼び出し自体は可能）。
     * 呼び出しは「第1引数に現在の値が適用」されて実行される（下記の func[X] コールで任意の位置に適用されることもできる）。
     *
     * 下記の特殊ルールにより、特殊な呼び出し方ができる。
     *
     * - nullsafe 設定にすると「値が null の場合は呼び出し自体を行わない」という動作になり null をそのまま返す
     * - array_XXX, str_XXX は省略して XXX で呼び出せる
     *   - 省略した結果、他の関数と被る場合は可能な限り型で一致する呼び出しを行う
     * - func(..., _, ...) で _ で「値があたる位置」を明示できる
     *   - `str_replace('from', 'to', _)` のように呼び出せる
     * - func[1] で「引数1（0 ベースなので要は2番目）に適用して func を呼び出す」ことができる
     *   - func[2], func[3] 等も呼び出し可能
     * - func['E'] で eval される文字列のクロージャを呼べる
     *   - 引数名は `$1`, `$2` のような文字列で指定できる
     *   - `$X` が無いときに限り 最左に `$1` が自動付与される
     * - 引数が1つの呼び出しは () を省略できる
     *
     * この特殊ルールは普通に使う分にはそこまで気にしなくて良い。
     * map や filter を駆使しようとすると必要になるが、イテレーション目的ではなく文字列のチェインなどが目的であればほぼ使うことはない。
     *
     * 上記を含むメソッド呼び出しはすべて自分自身を返すので、最終結果を得たい場合は `invoke` を実行する必要がある。
     * ただし、 IteratorAggregate が実装されているので、配列の場合に限り foreach で直接回すことができる。
     * その他、 Stringable や Countable, JsonSerializable など「値が必要になりそうなインターフェース」が実装されている。
     *
     * 用途は配列のイテレーションを想定しているが、あくまで「チェイン可能にする」が目的なので、ソースが文字列だろうとオブジェクトだろうと何でも呼び出しが可能。
     * ただし、遅延評価も最適化も何もしていないので、 chain するだけでも動作は相当遅くなることに注意。
     *
     * Example:
     * ```php
     * # 1～9 のうち「5以下を抽出」して「値を2倍」して「合計」を出すシチュエーション
     * $n1_9 = range(1, 9);
     * // 素の php で処理したもの。パッと見で何してるか分からないし、処理の順番が思考と逆なので混乱する
     * that(array_sum(array_map(fn($v) => $v * 2, array_filter($n1_9, fn($v) => $v <= 5))))->isSame(30);
     * // chain でクロージャを渡したもの。処理の順番が思考どおりだが、 fn() が微妙にうざい（array_ は省略できるので filter, map, sum のような呼び出しができている）
     * that(chain($n1_9)->filter(fn($v) => $v <= 5)->maps(fn($v) => $v * 2)->sum()())->isSame(30);
     * // func['E'] を介したもの。かなり直感的だが eval なので少し不安
     * that(chain($n1_9)->filter['E']('<= 5')->maps['E']('* 2')->sum()())->isSame(30);
     *
     * # "hello   world" を「" " で分解」して「空文字を除去」してそれぞれに「ucfirst」して「"/" で結合」して「rot13」して「md5」して「大文字化」するシチュエーション
     * $string = 'hello   world';
     * // 素の php で処理したもの。もはやなにがなんだか分からない
     * that(strtoupper(md5(str_rot13(implode('/', array_map('ucfirst', array_filter(explode(' ', $string))))))))->isSame('10AF4DAF67D0D666FCEA0A8C6EF57EE7');
     * // chain だとかなりそれっぽくできる。 explode/implode の第1引数は区切り文字なので func[1] 構文を使用している。また、 rot13 以降は引数がないので () を省略している
     * that(chain($string)->explode[1](' ')->filter()->maps('ucfirst')->implode[1]('/')->rot13->md5->strtoupper()())->isSame('10AF4DAF67D0D666FCEA0A8C6EF57EE7');
     *
     *  # よくある DB レコードをあれこれするシチュエーション
     * $rows = [
     *     ['id' => 1, 'name' => 'hoge', 'sex' => 'F', 'age' => 17, 'salary' => 230000],
     *     ['id' => 3, 'name' => 'fuga', 'sex' => 'M', 'age' => 43, 'salary' => 480000],
     *     ['id' => 7, 'name' => 'piyo', 'sex' => 'M', 'age' => 21, 'salary' => 270000],
     *     ['id' => 9, 'name' => 'hage', 'sex' => 'F', 'age' => 30, 'salary' => 320000],
     * ];
     * // e.g. 男性の平均給料
     * that(chain($rows)->where['E']('sex', '=== "M"')->column('salary')->mean()())->isSame(375000);
     * // e.g. 女性の平均年齢
     * that(chain($rows)->where['E']('sex', '=== "F"')->column('age')->mean()())->isSame(23.5);
     * // e.g. 30歳以上の平均給料
     * that(chain($rows)->where['E']('age', '>= 30')->column('salary')->mean()())->isSame(400000);
     * // e.g. 20～30歳の平均給料
     * that(chain($rows)->where['E']('age', '>= 20')->where['E']('age', '<= 30')->column('salary')->mean()())->isSame(295000);
     * // e.g. 男性の最小年齢
     * that(chain($rows)->where['E']('sex', '=== "M"')->column('age')->min()())->isSame(21);
     * // e.g. 女性の最大給料
     * that(chain($rows)->where['E']('sex', '=== "F"')->column('salary')->max()())->isSame(320000);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param mixed $source 元データ
     * @return \ChainObject
     */
    function chain($source = null)
    {
        if (function_configure('chain.version') === 2) {
            $chain_object = new class($source) implements \Countable, \ArrayAccess, \IteratorAggregate, \JsonSerializable {
                public static  $__CLASS__;
                private static $metadata = [];

                private $data;
                private $callback;

                public function __construct($source)
                {
                    $this->data = $source;
                }

                public function __get($name)
                {
                    $this->data = $this();

                    $this->callback = $this->_resolve($name, $this->data);
                    return $this;
                }

                public function __call($name, $arguments)
                {
                    return $this->$name[0](...$arguments);
                }

                public function __invoke()
                {
                    return $this[0]()->data;
                }

                public function __toString()
                {
                    return (string) $this();
                }

                public function getIterator(): \Traversable
                {
                    yield from $this();
                }

                public function count(): int
                {
                    return count($this());
                }

                public function jsonSerialize(): mixed
                {
                    return $this();
                }

                public function offsetGet($offset): callable
                {
                    return function (...$arguments) use ($offset) {
                        if ($this->callback !== null) {
                            // E モード
                            if ($offset === 'E') {
                                $offset = 0;
                                $expr = array_pop($arguments);
                                $expr = preg_match('#\$\d+#u', $expr) ? $expr : '$1 ' . $expr;
                                $arguments[] = func_eval($expr, '_');
                            }

                            $this->data = $this->_apply($this->callback, $arguments, [$offset => $this->data]);
                            $this->callback = null;
                        }
                        return $this;
                    };
                }

                public function apply($callback, ...$args)
                {
                    $this->data = $callback($this->data, ...$args);
                    return $this;
                }

                // @codeCoverageIgnoreStart

                public function offsetExists($offset): bool { throw new \LogicException(__METHOD__ . ' is not supported'); }

                public function offsetSet($offset, $value): void { throw new \LogicException(__METHOD__ . ' is not supported'); }

                public function offsetUnset($offset): void { throw new \LogicException(__METHOD__ . ' is not supported'); }

                // @codeCoverageIgnoreEnd

                private static function _resolve($name, $data)
                {
                    $isiterable = is_iterable($data);
                    $isstringable = is_stringable($data);
                    if (false
                        // for global
                        || (is_callable($name, false, $fname))
                        || ($isiterable && is_callable("array_$name", false, $fname))
                        || ($isstringable && is_callable("str_$name", false, $fname))
                        // for namespace
                        || (is_callable(__NAMESPACE__ . "\\$name", false, $fname))
                        || ($isiterable && is_callable(__NAMESPACE__ . "\\array_$name", false, $fname))
                        || ($isstringable && is_callable(__NAMESPACE__ . "\\str_$name", false, $fname))
                        // for class
                        || (is_callable([self::$__CLASS__, $name], false, $fname))
                        || ($isiterable && is_callable([self::$__CLASS__, "array_$name"], false, $fname))
                        || ($isstringable && is_callable([self::$__CLASS__, "str_$name"], false, $fname))
                    ) {
                        return $fname;
                    }

                    throw new \BadFunctionCallException("function '$name' is not defined");
                }

                private static function _apply($callback, $arguments, $injections)
                {
                    // 必要なメタデータを採取してキャッシュしておく
                    $metadata = self::$metadata[$callback] ??= (function ($callback) {
                        $reffunc = reflect_callable($callback);
                        $parameters = $reffunc->getParameters();
                        $metadata = [
                            // 可変長パラメータを無限に返す generator（適切に break しないと無限ループしてしまうので 999 個までとしてある）
                            'parameters' => function () use ($parameters) {
                                foreach ($parameters as $parameter) {
                                    if ($parameter->isVariadic()) {
                                        for ($i = 0; 999; $i++) {
                                            yield $parameter->getPosition() + $i => $parameter;
                                        }
                                        throw new \ArgumentCountError("parameter length is too long(>=$i)"); // @codeCoverageIgnore
                                    }
                                    yield $parameter->getPosition() => $parameter;
                                }
                            },
                            'variadic'   => $reffunc->isVariadic(),
                            'nullable'   => [],
                            'positions'  => [],
                            'names'      => [],
                        ];
                        foreach ($parameters as $parameter) {
                            $type = $parameter->getType();
                            $metadata['nullable'][$parameter->getPosition()] = $type ? $type->allowsNull() : null;
                            $metadata['positions'][$parameter->getPosition()] = $parameter->getName();
                            $metadata['names'][$parameter->getName()] = $parameter->getPosition();
                        }
                        return $metadata;
                    })($callback);

                    foreach ($injections as $position => $injection) {
                        // 可変じゃないのに位置引数 or 名前引数が存在しないチェック
                        if (false
                            || is_int($position) && !isset($metadata['positions'][$position]) && !$metadata['variadic']
                            || is_string($position) && !isset($metadata['names'][$position])
                        ) {
                            throw new \InvalidArgumentException("$callback(\$$position) does not exist");
                        }

                        // null セーフモード
                        if ($injection === null && function_configure('chain.nullsafe') && !($metadata['nullable'][$position] ?? false)) {
                            return null;
                        }
                    }

                    // プレースホルダモード
                    if (($placeholder = function_configure('placeholder')) && $placeholders = array_keys($arguments, constant($placeholder), true)) {
                        $arguments = array_replace($arguments, array_fill_keys($placeholders, reset($injections)));
                        $injections = [];
                    }

                    $icount = count($injections);
                    $realargs = [];
                    foreach ($metadata['parameters']() as $pos => $parameter) {
                        $pos -= $icount - count($injections);
                        $nam = $parameter->getName();
                        $variadic = $parameter->isVariadic();

                        if (!$injections && !$arguments) {
                            break;
                        }
                        // inject argument
                        elseif (array_key_exists($i = $pos, $injections) || array_key_exists($i = $nam, $injections)) {
                            $realargs = array_merge($realargs, $variadic && is_array($injections[$i]) ? $injections[$i] : [$injections[$i]]);
                            unset($injections[$i]);
                        }
                        // named or positional argument
                        elseif (array_key_exists($i = $pos, $arguments) || array_key_exists($i = $nam, $arguments)) {
                            $realargs = array_merge($realargs, $variadic && is_array($arguments[$i]) ? $arguments[$i] : [$arguments[$i]]);
                            unset($arguments[$i]);
                        }
                    }
                    return $callback(...$realargs);
                }
            };
            $chain_object::$__CLASS__ = __CLASS__;
            return $chain_object;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\func_eval') || (new \ReflectionFunction('ryunosuke\\ltsv\\func_eval'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\func_eval')) {
    /**
     * 指定コードで eval するクロージャを返す
     *
     * create_function のクロージャ版みたいなもの。
     * 参照渡しは未対応。
     *
     * コード中の `$1`, `$2` 等の文字は `func_get_arg(1)` のような引数関数に変換される。
     *
     * Example:
     * ```php
     * $func_eval = func_eval('$a + $b + $c', 'a', 'b', 'c');
     * that($func_eval(1, 2, 3))->isSame(6);
     *
     * // $X による参照
     * $func_eval = func_eval('$1 + $2 + $3');
     * that($func_eval(1, 2, 3))->isSame(6);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param string $expression eval コード
     * @param mixed ...$variadic 引数名（可変引数）
     * @return \Closure 新しいクロージャ
     */
    function func_eval($expression, ...$variadic)
    {
        static $cache = [];

        $args = array_sprintf($variadic, '$%s', ',');
        $cachekey = "$expression($args)";
        if (!isset($cache[$cachekey])) {
            $tmp = php_parse("<?php $expression");
            array_shift($tmp);
            $stmt = '';
            for ($i = 0; $i < count($tmp); $i++) {
                if (($tmp[$i]->text ?? null) === '$' && $tmp[$i + 1]->id === T_LNUMBER) {
                    $n = $tmp[$i + 1]->text - 1;
                    $stmt .= "func_get_arg($n)";
                    $i++;
                }
                else {
                    $stmt .= $tmp[$i]->text;
                }
            }
            $cache[$cachekey] = eval("return function($args) { return $stmt; };");
        }
        return $cache[$cachekey];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\func_method') || (new \ReflectionFunction('ryunosuke\\ltsv\\func_method'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\func_method')) {
    /**
     * 指定メソッドを呼び出すクロージャを返す
     *
     * この関数を呼ぶとメソッドのクロージャを返す。
     * そのクロージャにオブジェクトを与えて呼び出すとそれはメソッド呼び出しとなる。
     *
     * オプションでデフォルト引数を設定できる（Example を参照）。
     *
     * Example:
     * ```php
     * // 与えられた引数を結合して返すメソッド hoge を持つクラス
     * $object = new class()
     * {
     *     function hoge(...$args) { return implode(',', $args); }
     * };
     * // hoge を呼び出すクロージャ
     * $hoge = func_method('hoge');
     * // ↑を使用して $object の hoge を呼び出す
     * that($hoge($object, 1, 2, 3))->isSame('1,2,3');
     *
     * // デフォルト値付きで hoge を呼び出すクロージャ
     * $hoge789 = func_method('hoge', 7, 8, 9);
     * // ↑を使用して $object の hoge を呼び出す（引数指定してるので結果は同じ）
     * that($hoge789($object, 1, 2, 3))->isSame('1,2,3');
     * // 同上（一部デフォルト値）
     * that($hoge789($object, 1, 2))->isSame('1,2,9');
     * // 同上（全部デフォルト値）
     * that($hoge789($object))->isSame('7,8,9');
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param string $methodname メソッド名
     * @param mixed ...$defaultargs メソッドのデフォルト引数
     * @return \Closure メソッドを呼び出すクロージャ
     */
    function func_method($methodname, ...$defaultargs)
    {
        if ($methodname === '__construct') {
            return fn($object, ...$args) => new $object(...$args + $defaultargs);
        }
        return fn($object, ...$args) => ([$object, $methodname])(...$args + $defaultargs);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\func_new') || (new \ReflectionFunction('ryunosuke\\ltsv\\func_new'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\func_new')) {
    /**
     * 指定クラスのコンストラクタを呼び出すクロージャを返す
     *
     * この関数を呼ぶとコンストラクタのクロージャを返す。
     *
     * オプションでデフォルト引数を設定できる（Example を参照）。
     *
     * Example:
     * ```php
     * // Exception のコンストラクタを呼ぶクロージャ
     * $newException = func_new(\Exception::class, 'hoge');
     * // デフォルト引数を使用して Exception を作成
     * that($newException()->getMessage())->isSame('hoge');
     * // 引数を指定して Exception を作成
     * that($newException('fuga')->getMessage())->isSame('fuga');
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param string $classname クラス名
     * @param mixed ...$defaultargs コンストラクタのデフォルト引数
     * @return \Closure コンストラクタを呼び出すクロージャ
     */
    function func_new($classname, ...$defaultargs)
    {
        return fn(...$args) => new $classname(...$args + $defaultargs);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\func_operator') || (new \ReflectionFunction('ryunosuke\\ltsv\\func_operator'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\func_operator')) {
    /**
     * 演算子のクロージャを返す
     *
     * 関数ベースなので `??` のような言語組み込みの特殊な演算子は若干希望通りにならない（Notice が出る）。
     * 2つ目以降の引数でオペランドを指定できる。
     *
     * Example:
     * ```php
     * $not = func_operator('!');    // 否定演算子クロージャ
     * that(false)->isSame($not(true));
     *
     * $minus = func_operator('-'); // マイナス演算子クロージャ
     * that($minus(2))->isSame(-2);       // 引数1つで呼ぶと1項演算子
     * that($minus(3, 2))->isSame(3 - 2); // 引数2つで呼ぶと2項演算子
     *
     * $cond = func_operator('?:'); // 条件演算子クロージャ
     * that($cond('OK', 'NG'))->isSame('OK' ?: 'NG');               // 引数2つで呼ぶと2項演算子
     * that($cond(false, 'OK', 'NG'))->isSame(false ? 'OK' : 'NG'); // 引数3つで呼ぶと3項演算子
     *
     * $gt5 = func_operator('<=', 5); // 5以下を判定するクロージャ
     * that(array_filter([1, 2, 3, 4, 5, 6, 7, 8, 9], $gt5))->isSame([1, 2, 3, 4, 5]);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param string $operator 演算子
     * @param mixed ...$operands 右オペランド
     * @return \Closure 演算子のクロージャ
     */
    function func_operator($operator, ...$operands)
    {
        static $operators = null;
        $operators = $operators ?: [
            ''           => static fn($v1) => $v1, // こんな演算子はないが、「if ($value) {}」として使えることがある
            '!'          => static fn($v1) => !$v1,
            '+'          => static fn($v1, $v2 = null) => func_num_args() === 1 ? (+$v1) : ($v1 + $v2),
            '-'          => static fn($v1, $v2 = null) => func_num_args() === 1 ? (-$v1) : ($v1 - $v2),
            '~'          => static fn($v1) => ~$v1,
            '++'         => static fn(&$v1) => ++$v1,
            '--'         => static fn(&$v1) => --$v1,
            '?:'         => static fn($v1, $v2, $v3 = null) => func_num_args() === 2 ? ($v1 ?: $v2) : ($v1 ? $v2 : $v3),
            '??'         => static fn($v1, $v2) => $v1 ?? $v2,
            '=='         => static fn($v1, $v2) => $v1 == $v2,
            '==='        => static fn($v1, $v2) => $v1 === $v2,
            '!='         => static fn($v1, $v2) => $v1 != $v2,
            '<>'         => static fn($v1, $v2) => $v1 <> $v2,
            '!=='        => static fn($v1, $v2) => $v1 !== $v2,
            '<'          => static fn($v1, $v2) => $v1 < $v2,
            '<='         => static fn($v1, $v2) => $v1 <= $v2,
            '>'          => static fn($v1, $v2) => $v1 > $v2,
            '>='         => static fn($v1, $v2) => $v1 >= $v2,
            '<=>'        => static fn($v1, $v2) => $v1 <=> $v2,
            '.'          => static fn($v1, $v2) => $v1 . $v2,
            '*'          => static fn($v1, $v2) => $v1 * $v2,
            '/'          => static fn($v1, $v2) => $v1 / $v2,
            '%'          => static fn($v1, $v2) => $v1 % $v2,
            '**'         => static fn($v1, $v2) => $v1 ** $v2,
            '^'          => static fn($v1, $v2) => $v1 ^ $v2,
            '&'          => static fn($v1, $v2) => $v1 & $v2,
            '|'          => static fn($v1, $v2) => $v1 | $v2,
            '<<'         => static fn($v1, $v2) => $v1 << $v2,
            '>>'         => static fn($v1, $v2) => $v1 >> $v2,
            '&&'         => static fn($v1, $v2) => $v1 && $v2,
            '||'         => static fn($v1, $v2) => $v1 || $v2,
            'or'         => static fn($v1, $v2) => $v1 or $v2,
            'and'        => static fn($v1, $v2) => $v1 and $v2,
            'xor'        => static fn($v1, $v2) => $v1 xor $v2,
            'instanceof' => static fn($v1, $v2) => $v1 instanceof $v2,
            'new'        => static fn($v1, ...$v) => new $v1(...$v),
            'clone'      => static fn($v1) => clone $v1,
        ];

        $opefunc = $operators[trim($operator)] ?? throw new \InvalidArgumentException("$operator is not defined Operator.");

        if ($operands) {
            return static fn($v1) => $opefunc($v1, ...$operands);
        }

        return $opefunc;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\func_user_func_array') || (new \ReflectionFunction('ryunosuke\\ltsv\\func_user_func_array'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\func_user_func_array')) {
    /**
     * パラメータ定義数に応じて呼び出し引数を可変にしてコールする
     *
     * デフォルト引数はカウントされない。必須パラメータの数で呼び出す。
     *
     * $callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。
     *
     * php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。
     *
     * Example:
     * ```php
     * // strlen に2つの引数を渡してもエラーにならない
     * $strlen = func_user_func_array('strlen');
     * that($strlen('abc', null))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param callable|null $callback 呼び出すクロージャ
     * @return callable 引数ぴったりで呼び出すクロージャ
     */
    function func_user_func_array($callback)
    {
        // null は第1引数を返す特殊仕様
        if ($callback === null) {
            return fn($v) => $v;
        }
        // クロージャはユーザ定義しかありえないので調べる必要がない
        if ($callback instanceof \Closure) {
            // と思ったが、\Closure::fromCallable で作成されたクロージャは内部属性が伝播されるようなので除外
            if (reflect_callable($callback)->isUserDefined()) {
                return $callback;
            }
        }

        // 上記以外は「引数ぴったりで削ぎ落としてコールするクロージャ」を返す
        $plength = parameter_length($callback, true, true);
        return function (...$args) use ($callback, $plength) {
            if (is_infinite($plength)) {
                return $callback(...$args);
            }
            return $callback(...array_slice($args, 0, $plength));
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\func_wiring') || (new \ReflectionFunction('ryunosuke\\ltsv\\func_wiring'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\func_wiring')) {
    /**
     * 引数の型情報に基づいてワイヤリングしたクロージャを返す
     *
     * $dependency に数値キーの配列を混ぜるとデフォルト値として使用される。
     * 得られたクロージャの呼び出し時に引数を与える事ができる。
     *
     * parameter_wiring も参照。
     *
     * Example:
     * ```php
     * $closure = fn ($a, $b) => func_get_args();
     * $new_closure = func_wiring($closure, [
     *     '$a' => 'a',
     *     '$b' => 'b',
     *     1    => 'B',
     * ]);
     * that($new_closure())->isSame(['a', 'B']);    // 同時指定の場合は数値キー優先
     * that($new_closure('A'))->isSame(['A', 'B']); // 呼び出し時の引数優先
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param callable $callable 対象 callable
     * @param array|\ArrayAccess $dependency 引数候補配列
     * @return \Closure 引数を確定したクロージャ
     */
    function func_wiring($callable, $dependency)
    {
        $params = parameter_wiring($callable, $dependency);
        return fn(...$args) => $callable(...$args + $params);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\function_alias') || (new \ReflectionFunction('ryunosuke\\ltsv\\function_alias'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\function_alias')) {
    /**
     * 関数のエイリアスを作成する
     *
     * 単に移譲するだけではなく、参照渡し・参照返しも模倣される。
     * その代わり、単純なエイリアスではなく別定義で吐き出すので「エイリアス」ではなく「処理が同じな別関数」と思ったほうがよい。
     *
     * 静的であればクラスメソッドも呼べる。
     *
     * Example:
     * ```php
     * // trim のエイリアス
     * function_alias('trim', 'trim_alias');
     * that(trim_alias(' abc '))->isSame('abc');
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param callable $original 元となる関数
     * @param string $alias 関数のエイリアス名
     */
    function function_alias($original, $alias)
    {
        // クロージャとか __invoke とかは無理なので例外を投げる
        if (is_object($original)) {
            throw new \InvalidArgumentException('$original must not be object.');
        }
        // callname の取得と非静的のチェック
        is_callable($original, true, $calllname);
        $calllname = ltrim($calllname, '\\');
        $ref = reflect_callable($original);
        if ($ref instanceof \ReflectionMethod && !$ref->isStatic()) {
            throw new \InvalidArgumentException("$calllname is non-static method.");
        }
        // エイリアスが既に存在している
        if (function_exists($alias)) {
            throw new \InvalidArgumentException("$alias is already declared.");
        }

        // キャッシュ指定有りなら読み込むだけで eval しない
        $cachefile = function_configure('cachedir') . '/' . rawurlencode(__FUNCTION__ . '-' . $calllname . '-' . $alias) . '.php';
        if (!file_exists($cachefile)) {
            $parts = explode('\\', ltrim($alias, '\\'));
            $reference = $ref->returnsReference() ? '&' : '';
            $funcname = $reference . array_pop($parts);
            $namespace = implode('\\', $parts);

            $params = function_parameter($ref);
            $prms = implode(', ', array_values($params));
            $args = implode(', ', array_keys($params));
            if ($ref->isInternal()) {
                $args = "array_slice([$args] + func_get_args(), 0, func_num_args())";
            }
            else {
                $args = "[$args]";
            }

            $code = <<<CODE
                namespace $namespace {
                    function $funcname($prms) {
                        \$return = $reference \\$calllname(...$args);
                        return \$return;
                    }
                }
                CODE;
            file_put_contents($cachefile, "<?php\n" . $code);
        }
        require_once $cachefile;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\function_shorten') || (new \ReflectionFunction('ryunosuke\\ltsv\\function_shorten'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\function_shorten')) {
    /**
     * 関数の名前空間部分を除いた短い名前を取得する
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param string $function 短くする関数名
     * @return string 短い関数名
     */
    function function_shorten($function)
    {
        $parts = explode('\\', $function);
        return array_pop($parts);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_bindable_closure') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_bindable_closure'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_bindable_closure')) {
    /**
     * $this を bind 可能なクロージャか調べる
     *
     * Example:
     * ```php
     * that(is_bindable_closure(function () {}))->isTrue();
     * that(is_bindable_closure(static function () {}))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param \Closure $closure 調べるクロージャ
     * @return bool $this を bind 可能なクロージャなら true
     */
    function is_bindable_closure(\Closure $closure)
    {
        return !!@$closure->bindTo(new \stdClass());
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_callback') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_callback'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_callback')) {
    /**
     * callable のうち、関数文字列を false で返す
     *
     * 歴史的な経緯で php の callable は多岐に渡る。
     *
     * 1. 単純なコールバック: `"strtolower"`
     * 2. staticメソッドのコール: `["ClassName", "method"]`
     * 3. オブジェクトメソッドのコール: `[$object, "method"]`
     * 4. staticメソッドのコール: `"ClassName::method"`
     * 5. 相対指定によるstaticメソッドのコール: `["ClassName", "parent::method"]`
     * 6. __invoke実装オブジェクト: `$object`
     * 7. クロージャ: `fn() => something()`
     *
     * 上記のうち 1 を callable とはみなさず false を返す。
     * 現代的には `Closure::fromCallable`, `$object->method(...)` などで callable == Closure という概念が浸透しているが、そうでないこともある。
     * 本ライブラリでも `preg_splice` や `array_sprintf` などで頻出しているので関数として定義する。
     *
     * 副作用はなく、クラスのロードや関数の存在チェックなどは行わない。あくまで型と形式で判定する。
     * 引数は callable でなくても構わない。その場合単に false を返す。
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param mixed $callable 対象 callable
     * @return bool 関数呼び出しの callable なら false
     */
    function is_callback($callable)
    {
        // 大前提（不要に思えるが invoke や配列 [1, 2, 3] などを考慮すると必要）
        if (!is_callable($callable, true)) {
            return false;
        }

        // 変なオブジェクト・配列は↑で除かれている
        if (is_object($callable) || is_array($callable)) {
            return true;
        }

        // 文字列で :: を含んだら関数呼び出しではない
        if (is_string($callable) && strpos($callable, '::') !== false) {
            return true;
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ansi_colorize') || (new \ReflectionFunction('ryunosuke\\ltsv\\ansi_colorize'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ansi_colorize')) {
    /**
     * 文字列に ANSI Color エスケープシーケンスを埋め込む
     *
     * - "blue" のような小文字色名は文字色
     * - "BLUE" のような大文字色名は背景色
     * - "bold" のようなスタイル名は装飾
     *
     * となる。その区切り文字は現在のところ厳密に定めていない（`fore+back|bold` のような形式で定めることも考えたけどメリットがない）。
     * つまり、アルファベット以外で分割するので、
     *
     * - `blue|WHITE@bold`: 文字青・背景白・太字
     * - `blue WHITE bold underscore`: 文字青・背景白・太字・下線
     * - `italic|bold,blue+WHITE  `: 文字青・背景白・太字・斜体
     *
     * という動作になる（記号で区切られていれば形式はどうでも良いということ）。
     * ただ、この指定方法は変更が入る可能性が高いのでスペースあたりで区切っておくのがもっとも無難。
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param string $string 対象文字列
     * @param string $color 色とスタイル文字列
     * @return string エスケープシーケンス付きの文字列
     */
    function ansi_colorize($string, $color)
    {
        // see https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
        // see https://misc.flogisoft.com/bash/tip_colors_and_formatting
        $ansicodes = [
            // forecolor
            'default'    => [39, 39],
            'black'      => [30, 39],
            'red'        => [31, 39],
            'green'      => [32, 39],
            'yellow'     => [33, 39],
            'blue'       => [34, 39],
            'magenta'    => [35, 39],
            'cyan'       => [36, 39],
            'white'      => [97, 39],
            'gray'       => [90, 39],
            // backcolor
            'DEFAULT'    => [49, 49],
            'BLACK'      => [40, 49],
            'RED'        => [41, 49],
            'GREEN'      => [42, 49],
            'YELLOW'     => [43, 49],
            'BLUE'       => [44, 49],
            'MAGENTA'    => [45, 49],
            'CYAN'       => [46, 49],
            'WHITE'      => [47, 49],
            'GRAY'       => [100, 49],
            // style
            'bold'       => [1, 22],
            'faint'      => [2, 22], // not working ?
            'italic'     => [3, 23],
            'underscore' => [4, 24],
            'blink'      => [5, 25],
            'reverse'    => [7, 27],
            'conceal'    => [8, 28],
        ];

        $names = array_flip(preg_split('#[^a-z]#i', $color));
        $styles = array_intersect_key($ansicodes, $names);
        $setters = implode(';', array_column($styles, 0));
        $unsetters = implode(';', array_column($styles, 1));
        return "\033[{$setters}m{$string}\033[{$unsetters}m";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ansi_strip') || (new \ReflectionFunction('ryunosuke\\ltsv\\ansi_strip'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ansi_strip')) {
    /**
     * ANSI エスケープ文字を取り除く
     *
     * Example:
     * ```php
     * $ansi_string = ansi_colorize('hoge', 'bold red');
     * // エスケープ文字も含めて 19 文字
     * that(strlen($ansi_string))->isSame(19);
     * // ansi_strip すると本来の hoge がえられる
     * that(ansi_strip($ansi_string))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param string $string 対象文字列
     * @return string ANSI エスケープ文字が取り除かれた文字
     */
    function ansi_strip($string)
    {
        return preg_replace('#\\e\\[.+?(;.+?)*(?<!;)[a-z]#ui', '', $string);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arguments') || (new \ReflectionFunction('ryunosuke\\ltsv\\arguments'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arguments')) {
    /**
     * コマンドライン引数をパースして引数とオプションを返す
     *
     * 少しリッチな {@link http://php.net/manual/function.getopt.php getopt} として使える（shell 由来のオプション構文(a:b::)はどうも馴染みにくい）。
     * ただし「値が必須なオプション」はサポートしない。
     * もっとも、オプションとして空文字が来ることはほぼ無いのでデフォルト値を空文字にすることで対応可能。
     *
     * $rule に従って `--noval filename --opt optval` のような文字列・配列をパースする。
     * $rule 配列の仕様は下記。
     *
     * - キーは「オプション名」を指定する。ただし・・・
     *     - 数値キーは「引数」を意味する
     *     - スペースの後に「ショート名」を与えられる
     * - 値は「デフォルト値」を指定する。ただし・・・
     *     - `[]` は「複数値オプション」を意味する（配列にしない限り同オプションの多重指定は許されない）
     *     - `null` は「値なしオプション」を意味する（スイッチングオプション）
     * - 空文字キーは解釈自体のオプションを与える
     *     - 今のところ throw のみの実装。配列ではなく bool を与えられる
     *
     * 上記の仕様でパースして「引数は数値連番、オプションはオプション名をキーとした配列」を返す。
     * なお、いわゆる「引数」はどこに来ても良い（前オプション、後オプションの区別がない）。
     *
     * $argv には配列や文字列が与えられるが、ほとんどテスト用に近く、普通は未指定で $argv を使うはず。
     *
     * Example:
     * ```php
     * // いくつか織り交ぜたスタンダードな例
     * $rule = [
     *     'opt'       => 'def',    // 基本的には「デフォルト値」を表す
     *     'longopt l' => '',       // スペース区切りで「ショート名」を意味する
     *     1           => 'defarg', // 数値キーは「引数」を意味する
     * ];
     * that(arguments($rule, '--opt optval arg1 -l longval'))->isSame([
     *     'opt'     => 'optval',  // optval と指定している
     *     'longopt' => 'longval', // ショート名指定でも本来の名前で返ってくる
     *     'arg1',   // いわゆるコマンドライン引数（optval は opt に飲まれるので含まれない）
     *     'defarg', // いわゆるコマンドライン引数（与えられていないが、ルールの 1 => 'defarg' が活きている）
     * ]);
     *
     * // 「値なしオプション」と「複数値オプション」の例
     * $rule = [
     *     'noval1 l'  => null, // null は「値なしオプション」を意味する（指定されていれば true されていなければ false を返す）
     *     'noval2 m'  => null, // 同上
     *     'noval3 n'  => null, // 同上
     *     'opts o' => [],      // 配列を与えると「複数値オプション」を表す
     * ];
     * that(arguments($rule, '--opts o1 -ln arg1 -o o2 arg2 --opts o3'))->isSame([
     *     'noval1' => true,  // -ln で同時指定されているので true
     *     'noval2' => false, // -ln で同時指定されてないので false
     *     'noval3' => true,  // -ln の同時指定されているので true
     *     'opts'   => ['o1', 'o2', 'o3'], // ロング、ショート混在でも OK
     *     'arg1', // 一見 -ln のオプション値に見えるが、 noval は値なしなので引数として得られる
     *     'arg2', // 前オプション、後オプションの区別はないのでどこに居ようと引数として得られる
     * ]);
     *
     * // 空文字で解釈自体のオプションを与える
     * $rule = [
     *     ''  => false, // 定義されていないオプションが来ても例外を投げずに引数として処理する
     * ];
     * that(arguments($rule, '--long A -short B'))->isSame([
     *     '--long', // 明らかにオプション指定に見えるが、 long というオプションは定義されていないので引数として解釈される
     *     'A',      // 同上。long のオプション値に見えるが、ただの引数
     *     '-short', // 同上。short というオプションは定義されていない
     *     'B',      // 同上。short のオプション値に見えるが、ただの引数
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param array $rule オプションルール
     * @param array|string|null $argv パースするコマンドライン引数。未指定時は $argv が使用される
     * @return array コマンドライン引数＋オプション
     */
    function arguments($rule, $argv = null)
    {
        $opt = array_unset($rule, '', []);
        if (is_bool($opt)) {
            $opt = ['thrown' => $opt];
        }
        $opt += [
            'thrown' => true,
        ];

        if ($argv === null) {
            $argv = array_slice($_SERVER['argv'], 1); // @codeCoverageIgnore
        }
        if (is_string($argv)) {
            $argv = quoteexplode([" ", "\t"], $argv);
            $argv = array_filter($argv, 'strlen');
        }
        $argv = array_values($argv);

        $shortmap = [];
        $argsdefaults = [];
        $optsdefaults = [];
        foreach ($rule as $name => $default) {
            if (is_int($name)) {
                $argsdefaults[$name] = $default;
                continue;
            }
            [$longname, $shortname] = preg_split('#\s+#u', $name, -1, PREG_SPLIT_NO_EMPTY) + [1 => ''];
            if (strlen($shortname)) {
                if (array_key_exists($shortname, $shortmap)) {
                    throw new \InvalidArgumentException("duplicated short option name '$shortname'");
                }
                $shortmap[$shortname] = $longname;
            }
            if (array_key_exists($longname, $optsdefaults)) {
                throw new \InvalidArgumentException("duplicated option name '$shortname'");
            }
            $optsdefaults[$longname] = $default;
        }

        $n = 0;
        $already = [];
        $result = array_map(fn($v) => $v === null ? false : $v, $optsdefaults);
        while (($token = array_shift($argv)) !== null) {
            if (strlen($token) >= 2 && $token[0] === '-') {
                if ($token[1] === '-') {
                    $optname = substr($token, 2);
                    if (!$opt['thrown'] && !array_key_exists($optname, $optsdefaults)) {
                        $result[$n++] = $token;
                        continue;
                    }
                }
                else {
                    $shortname = substr($token, 1);
                    if (!$opt['thrown'] && !array_keys_exist(str_split($shortname, 1), $shortmap)) {
                        $result[$n++] = $token;
                        continue;
                    }
                    if (strlen($shortname) > 1) {
                        array_unshift($argv, '-' . substr($shortname, 1));
                        $shortname = substr($shortname, 0, 1);
                    }
                    if (!isset($shortmap[$shortname])) {
                        throw new \InvalidArgumentException("undefined short option name '$shortname'.");
                    }
                    $optname = $shortmap[$shortname];
                }

                if (!array_key_exists($optname, $optsdefaults)) {
                    throw new \InvalidArgumentException("undefined option name '$optname'.");
                }
                if (isset($already[$optname]) && !is_array($result[$optname])) {
                    throw new \InvalidArgumentException("'$optname' is specified already.");
                }
                $already[$optname] = true;

                if ($optsdefaults[$optname] === null) {
                    $result[$optname] = true;
                }
                else {
                    if (!isset($argv[0]) || strpos($argv[0], '-') === 0) {
                        throw new \InvalidArgumentException("'$optname' requires value.");
                    }
                    if (is_array($result[$optname])) {
                        $result[$optname][] = array_shift($argv);
                    }
                    else {
                        $result[$optname] = array_shift($argv);
                    }
                }
            }
            else {
                $result[$n++] = $token;
            }
        }

        array_walk_recursive($result, function (&$v) {
            if (is_string($v)) {
                $v = trim(str_replace('\\"', '"', $v), '"');
            }
        });
        return $result + $argsdefaults;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cpu_timer') || (new \ReflectionFunction('ryunosuke\\ltsv\\cpu_timer'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cpu_timer')) {
    /**
     * CPU 時間を計れるオブジェクトを返す
     *
     * コンストラクタ（あるいは start）時点から stop までの下記を返す。
     *
     * - real: 実際の経過時間
     * - time: CPU時間（user + system）
     * - user: ユーザー時間
     * - system: システム時間
     * - idle: アイドル時間（real - time）
     * - time%: CPU使用率（time / real）
     * - user%: ユーザー使用率（user / time）
     * - system%: システム使用率（system / time）
     * - idle%: アイドル率（idle / real）
     *
     * 要するに POSIX の time コマンドとほぼ同じで、計算から導出できる値がちょっと増えただけ。
     *
     * - user が大きい場合（time と user が近い場合）、ユーザーランドの処理が多かったことを表す
     * - system が大きい場合（time と system が近い場合）、システムコールが多かったことを表す
     * - idle が大きい場合（real と time が離れている場合）、ネットワークや IO 等で CPU が遊んでいたことを表す
     *   - もっとも、コア数によってはその限りではない（単に他のプロセスを捌いていただけ、もあり得る）
     *   - linux 版 getrusage だとコンテキストスイッチが取れるので傾向は表せるけど…正確には無理だし Windows が対応していないので未対応
     *
     * Example:
     * ```php
     * $timer = cpu_timer();
     * foreach (range(0, 999) as $i) {
     *    // ファイル IO を伴う sha1 なら user,system,idle を程よく使うはず
     *    $hash = sha1_file(__FILE__);
     * }
     * //var_dump($timer->result());
     * //{
     * //  real: 0.13377594947814941,
     * //  user: 0.078125,
     * //  system: 0.046875,
     * //  time: 0.125,
     * //  idle: 0.008775949478149414,
     * //  user%: 62.5,
     * //  system%: 37.5,
     * //  time%: 93.4398152191154,
     * //  idle%: 6.560184780884589,
     * //}
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @return \CpuTimer|object タイマーオブジェクト
     */
    function cpu_timer()
    {
        return new class() {
            private float $start;
            private array $rusage;

            public function __construct()
            {
                $this->start();
            }

            public function start(): void
            {
                $this->start = microtime(true);
                $this->rusage = $this->getrusage();
            }

            public function result(): array
            {
                $real = microtime(true) - $this->start;
                $rusage = $this->getrusage();

                $utime = $rusage['ru_utime'] - $this->rusage['ru_utime'];
                $stime = $rusage['ru_stime'] - $this->rusage['ru_stime'];
                $time = $utime + $stime;
                $idle = $real - $time;

                return [
                    'real'    => $real,
                    'user'    => $utime,
                    'system'  => $stime,
                    'time'    => $time,
                    'idle'    => $idle,
                    'user%'   => $time === 0.0 ? NAN : ($utime / $time * 100),
                    'system%' => $time === 0.0 ? NAN : ($stime / $time * 100),
                    'time%'   => $real === 0.0 ? NAN : ($time / $real * 100),
                    'idle%'   => $real === 0.0 ? NAN : ($idle / $real * 100),
                ];
            }

            public function __invoke($callback): array
            {
                $this->start();

                $callback();

                return $this->result();
            }

            private function getrusage()
            {
                $rusage = getrusage();
                $rusage['ru_utime'] = $rusage['ru_utime.tv_sec'] + $rusage['ru_utime.tv_usec'] / 1000 / 1000;
                $rusage['ru_stime'] = $rusage['ru_stime.tv_sec'] + $rusage['ru_stime.tv_usec'] / 1000 / 1000;
                return $rusage;
            }
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\finalize') || (new \ReflectionFunction('ryunosuke\\ltsv\\finalize'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\finalize')) {
    /**
     * 自身が死ぬときに指定 callable を呼ぶオブジェクトを返す
     *
     * invoke を実装しているので明示的にも呼べる。
     * 明示的だろうと暗黙的だろうと必ず1回しか呼ばれない。
     *
     * Example:
     * ```php
     * $called = 0;
     * $finalizer = finalize(function()use(&$called){$called++;});
     * that($called)->is(0); // まだ呼ばれていない
     *
     * // コールすると・・・
     * $finalizer();
     * that($called)->is(1); // 呼ばれている
     *
     * // unset（GC）でも呼ばれる
     * unset($finalizer);
     * that($called)->is(1); // が、一度しか呼ばれないので呼ばれない
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param callable $finalizer 実行する php コード
     * @return callable GC 時に $finalizer を実行する callable
     */
    function finalize(callable $finalizer)
    {
        return new class($finalizer) {
            public function __construct(private $finalizer) { }

            public function __destruct() { $this->__invoke(); }

            public function __invoke()
            {
                if (isset($this->finalizer)) {
                    ($this->finalizer)();
                    unset($this->finalizer);
                    gc_collect_cycles();
                }
            }
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\get_modified_files') || (new \ReflectionFunction('ryunosuke\\ltsv\\get_modified_files'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\get_modified_files')) {
    /**
     * 初回読み込み時から変更のあったファイル配列を返す
     *
     * 初回呼び出し時は必ず空配列を返し、以後の呼び出しで変更のあったファイルを返す。
     * 削除されたファイルも変更とみなす。
     *
     * 用途的には「php で書かれたデーモンで、変更感知して自動で再起動する（systemd に任せる）」がある。
     *
     * Example:
     * ```php
     * // 別プロセスで3秒後に自分自身を触る
     * $p = process_async(PHP_BINARY, ['-r' => 'sleep(3);touch($argv[1]);', __FILE__]);
     *
     * $time = microtime(true);
     * foreach (range(1, 10) as $i) {
     *     // 何らかのデーモン（完全に wait する系ではなく時々処理が戻ってくる必要がある）
     *     sleep(1);
     *
     *     // 自身の変更を感知したら break なり exit なりで抜ける（大抵はそのまま終了する。起動は systemd に丸投げする）
     *     if (get_modified_files(__FILE__)) {
     *         break;
     *     }
     * }
     * // 全ループすると10秒かかるが、大体3秒程度で抜けているはず
     * that(microtime(true) - $time)->break()->lt(3.9);
     * unset($p);
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param string|array $target_pattern 対象ファイルパターン（マッチしないものは無視される）
     * @param string|array $ignore_pattern 除外ファイルパターン（マッチしたものは無視される）
     * @return array 変更のあったファイル名配列
     */
    function get_modified_files($target_pattern = '*.php', $ignore_pattern = '*.phtml')
    {
        static $file_mtimes = [];

        $modified = [];
        foreach (get_included_files() as $filename) {
            $mtime = file_exists($filename) ? filemtime($filename) : time();

            // 対象外でも引数違いの呼び出しのために入れておかなければならない
            if (!fnmatch_or($target_pattern, $filename, FNM_NOESCAPE) || fnmatch_or($ignore_pattern, $filename, FNM_NOESCAPE)) {
                $file_mtimes[$filename] ??= $mtime;
                continue;
            }

            if (!isset($file_mtimes[$filename])) {
                $file_mtimes[$filename] = $mtime;
            }
            elseif ($mtime > $file_mtimes[$filename]) {
                $modified[] = $filename;
            }
        }

        return $modified;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\get_uploaded_files') || (new \ReflectionFunction('ryunosuke\\ltsv\\get_uploaded_files'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\get_uploaded_files')) {
    /**
     * $_FILES の構造を組み替えて $_POST などと同じにする
     *
     * $_FILES の配列構造はバグとしか思えないのでそれを是正する関数。
     * 第1引数 $files は指定可能だが、大抵は $_FILES であり、指定するのはテスト用。
     *
     * サンプルを書くと長くなるので例は{@source \ryunosuke\Test\Package\UtilityTest::test_get_uploaded_files() テストファイル}を参照。
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param ?array $files $_FILES の同じ構造の配列。省略時は $_FILES
     * @return array $_FILES を $_POST などと同じ構造にした配列
     */
    function get_uploaded_files($files = null)
    {
        $result = [];
        foreach (($files ?: $_FILES) as $name => $file) {
            if (is_array($file['name'])) {
                $file = get_uploaded_files(array_each($file['name'], function (&$carry, $dummy, $subkey) use ($file) {
                    $carry[$subkey] = array_lookup($file, $subkey);
                }, []));
            }
            $result[$name] = $file;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\getenvs') || (new \ReflectionFunction('ryunosuke\\ltsv\\getenvs'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\getenvs')) {
    /**
     * 連想配列を元に環境変数を取得する
     *
     * 配列のキーで取得するキーを指定できる。
     * 連番の場合は元の環境変数名がキーとして使用される。
     *
     * 環境変数が存在しない場合、false ではなく null になる。
     * 環境変数名に配列を与えた場合、順に取得を試みて、見つからなかった場合に null になる。
     *
     * キーが指定されておらず、さらに環境変数候補数が1以外で環境変数が見つからない場合は例外を投げる。
     * （返すキーが一意に定まらない場合に例外を投げる）。
     *
     * Example:
     * ```php
     * putenv('ENV1=env_1');
     * putenv('ENV2=env_2');
     * putenv('ENV3=env_3');
     *
     * that(getenvs([
     *     'ENV1',                           // キー指定がない
     *     'e2' => 'ENV2',                   // キー指定がある
     *     'e3' => ['ENV4', 'ENV3', 'ENV2'], // 配列の左から取得を試みる
     *     'e8' => 'ENV8',                   // 存在しない環境変数
     *     'e9' => ['ENV9', 'ENV8', 'ENV7'], // 存在しない環境変数配列
     * ]))->is([
     *     'ENV1' => 'env_1', // キー指定がない場合、環境変数名がキーになる
     *     'e2'   => 'env_2', // キー指定がある場合、それがキーになる
     *     'e3'   => 'env_3', // ENV3 が見つかった
     *     'e8'   => null,    // ENV8 が見つからないので null
     *     'e9'   => null,    // ENV9, ENV8, ENV7 のどれも見つからないので null
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param iterable $env_vars [キー => 環境変数名]
     * @return array 環境変数
     */
    function getenvs($env_vars)
    {
        $result = [];
        foreach ($env_vars as $key => $varname) {
            $varname = arrayize($varname);
            foreach ($varname as $name) {
                $alias = is_int($key) ? $name : $key;
                $val = getenv($name, true);

                if ($val !== false) {
                    $result[$alias] = $val;
                    continue 2;
                }
            }

            if (is_int($key)) {
                if (count($varname) !== 1) {
                    throw new \InvalidArgumentException('environment variable name is ambiguous');
                }
                $result[reset($varname)] = null;
            }
            else {
                $result[$key] = null;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ini_sets') || (new \ReflectionFunction('ryunosuke\\ltsv\\ini_sets'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ini_sets')) {
    /**
     * 複数の php.ini の設定をまとめて設定する
     *
     * 返り値として「もとに戻すためのクロージャ」を返すので、復元するためにはそのクロージャを呼ぶだけで良い。
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param array $values ini のエントリ名と値の配列
     * @return callable ini を元に戻す callable
     */
    function ini_sets($values)
    {
        $main = static function ($values) {
            $currents = [];
            foreach ($values as $name => $value) {
                $current = ini_set($name, $value);
                if ($current !== false) {
                    $currents[$name] = $current;
                }
            }
            return $currents;
        };
        $currents = $main($values);
        return finalize(fn() => $main($currents));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_ansi') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_ansi'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_ansi')) {
    /**
     * リソースが ansi color に対応しているか返す
     *
     * パイプしたりリダイレクトしていると false を返す。
     *
     * @package ryunosuke\Functions\Package\info
     * @see https://github.com/symfony/console/blob/v4.2.8/Output/StreamOutput.php#L98
     *
     * @param resource $stream 調べるリソース
     * @return bool ansi color に対応しているなら true
     */
    function is_ansi($stream)
    {
        // テスト用に隠し引数で DS を取っておく
        $DIRECTORY_SEPARATOR = DIRECTORY_SEPARATOR;
        assert(!!$DIRECTORY_SEPARATOR = func_num_args() > 1 ? func_get_arg(1) : $DIRECTORY_SEPARATOR);

        if ('Hyper' === getenv('TERM_PROGRAM')) {
            return true;
        }

        if ($DIRECTORY_SEPARATOR === '\\') {
            return (\function_exists('sapi_windows_vt100_support') && @sapi_windows_vt100_support($stream))
                || false !== getenv('ANSICON')
                || 'ON' === getenv('ConEmuANSI')
                || 'xterm' === getenv('TERM');
        }

        return @stream_isatty($stream);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\php_binary') || (new \ReflectionFunction('ryunosuke\\ltsv\\php_binary'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\php_binary')) {
    /**
     * php-cli のパスを返す
     *
     * 見つからない場合は null を返す。
     * 実質的には PHP_BINARY と同じと考えてよい。
     * ただ PHP_BINARY は SAPI によって異なるので fpm 時にはこの関数を用いて php-cli のパスを得る必要がある。
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @return string|null php-cli のパス
     */
    function php_binary()
    {
        if (PHP_SAPI === 'cli' && !defined('PHPUNIT')) {
            return PHP_BINARY; // @codeCoverageIgnore
        }

        $phpdir = dirname(PHP_BINARY);
        $targets = ['php', 'php.exe', 'php.bat'];
        foreach ($targets as $target) {
            if (file_exists($bin = $phpdir . DIRECTORY_SEPARATOR . $target)) {
                return $bin;
            }
        }

        return null; // @codeCoverageIgnore
    }
}

assert(!function_exists('ryunosuke\\ltsv\\setenvs') || (new \ReflectionFunction('ryunosuke\\ltsv\\setenvs'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\setenvs')) {
    /**
     * 連想配列を元に環境変数を設定する
     *
     * 値に null を渡すと環境変数の削除動作となる。
     * 返り値として成否配列を返すが、この返り値の形式は互換性を維持せず、変更になる可能性がある。
     *
     * Example:
     * ```php
     * setenvs([
     *     'ENV1' => 'e1',
     *     'ENV2' => 'e2',
     *     'ENV3' => null,
     * ]);
     * that(getenv('ENV1'))->isSame('e1');
     * that(getenv('ENV2'))->isSame('e2');
     * that(getenv('ENV3'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param iterable $env_vars [環境変数名 => 値]
     * @return array 成否配列
     */
    function setenvs($env_vars)
    {
        $result = [];
        foreach ($env_vars as $envname => $val) {
            if ($val === null) {
                $result[$envname] = putenv("$envname");
            }
            else {
                $result[$envname] = putenv("$envname=$val");
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\sys_set_temp_dir') || (new \ReflectionFunction('ryunosuke\\ltsv\\sys_set_temp_dir'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\sys_set_temp_dir')) {
    /**
     * sys_get_temp_dir が返すディレクトリを変更する
     *
     * ただし、sys_get_temp_dir は一度でも呼ぶと内部的にキャッシュされるので、必ず呼ぶ前に設定しなければならない。
     * 相対パスを指定すると標準設定からの相対になる。
     *
     * $check_settled はデバッグ用なので運用では使わないこと。
     *
     * @see https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/main/php_open_temporary_file.c
     *
     * Example:
     * ```php
     * // 標準一時ディレクトリ/systemname で一時ディレクトリを設定してかつ作成する
     * sys_set_temp_dir("systemname", true);
     * //that(sys_get_temp_dir())->is(...); // 上記が設定されている
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param string $directory 一時ディレクトリ
     * @param bool $creates 設定すると同時に作成するか
     * @return bool 成功時に true
     */
    function sys_set_temp_dir($directory, $creates = true, $check_settled = true)
    {
        $envname = ['\\' => 'TMP', '/' => 'TMPDIR'][DIRECTORY_SEPARATOR];
        $current = getenv($envname);

        // sys_temp_dir が指定されているならそこからの相対とする
        $sys_temp_dir = ini_get('sys_temp_dir');
        $sys_temp_dir = strlen($sys_temp_dir) ? $sys_temp_dir : $current;
        if (strlen($sys_temp_dir) && !path_is_absolute($directory)) {
            $directory = $sys_temp_dir . DIRECTORY_SEPARATOR . $directory;
        }

        // 各プラットフォームの環境変数を変更して sys_get_temp_dir で確定させる（環境変数を変更したままは行儀が悪いので確定したら元に戻す）
        putenv("$envname=$directory");
        $tmpdir = sys_get_temp_dir();
        putenv("$envname=$current");

        // 設定できてないなら何かがおかしい
        if ($check_settled && $tmpdir !== path_normalize($directory)) {
            return false;
        }

        // 作成する場合は作ってその結果を返り値とする
        if ($creates) {
            @mkdir($tmpdir, 0777, true);
            return is_dir($tmpdir);
        }

        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\iterator_chunk') || (new \ReflectionFunction('ryunosuke\\ltsv\\iterator_chunk'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\iterator_chunk')) {
    /**
     * イテレータも使える array_chunk
     *
     * Generator を返す Generator を返す。
     * foreach で使う分には普通の配列と遜色なく使うことができる。
     *
     * 大本 Generator は return 値として総数を返す。
     * 各種 Generator は return 値として要素数を返す。
     *
     * Example:
     * ```php
     * // 要素7の Generator を3つに分割
     * $generator = (function () {
     *     yield 'a';
     *     yield 'b';
     *     yield 'c';
     *     yield 'd';
     *     yield 'e';
     *     yield 'f';
     *     yield 'g';
     * })();
     * $generators = iterator_chunk($generator, 3);
     *
     * // 3要素
     * that(iterator_to_array($generators->current()))->is(['a', 'b', 'c']);
     * that($generators->current()->getReturn())->is(3);
     * // 3要素
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['d', 'e', 'f']);
     * that($generators->current()->getReturn())->is(3);
     * // 1要素
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['g']);
     * that($generators->current()->getReturn())->is(1);
     * // 大本の Generator は総数を返す
     * $generators->next();
     * that($generators->getReturn())->is(7);
     *
     * // ハイフンが来るたびに分割（クロージャ内で next しているため、ハイフン自体は結果に含まれない）
     * $generator = (function () {
     *     yield 'a';
     *     yield 'b';
     *     yield '-';
     *     yield 'c';
     *     yield 'd';
     *     yield 'e';
     *     yield 'f';
     *     yield '-';
     *     yield 'g';
     * })();
     * $generators = iterator_chunk($generator, function ($v, $k, $n, $c, $it) {
     *     if ($v === '-') {
     *         $it->next();
     *         return false;
     *     }
     *     return true;
     * });
     *
     * that(iterator_to_array($generators->current()))->is(['a', 'b']);
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['c', 'd', 'e', 'f']);
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['g']);
     * ```
     *
     * @package ryunosuke\Functions\Package\iterator
     *
     * @param iterable $iterator イテレータ
     * @param int|\Closure $length チャンクサイズ。クロージャを渡すと毎ループ(値, キー, ステップ, チャンク番号, イテレータ)でコールされて false を返すと1チャンク終了となる
     * @param bool $preserve_keys キーの保存フラグ
     * @return \Generator[]|\Generator チャンク化された Generator
     */
    function iterator_chunk($iterator, $length, $preserve_keys = false)
    {
        if (!$length instanceof \Closure) {
            if ($length <= 0) {
                throw new \InvalidArgumentException("\$length must be > 0 ($length)");
            }
            $length = fn($v, $k, $n, $chunk, $iterator) => $n < $length;
        }

        // Generator は Iterator であるが Iterator は Generator ではないので変換する
        if (is_iterable($iterator)) {
            /** @var \Iterator $iterator */
            $iterator = (fn() => yield from $iterator)();
        }

        $chunk = 0;
        $total = 0;
        while ($iterator->valid()) {
            yield $g = (function () use ($iterator, $length, $preserve_keys, $chunk) {
                $n = 0;
                while ($iterator->valid()) {
                    $k = $iterator->key();
                    $v = $iterator->current();

                    if (!$length($v, $k, $n, $chunk, $iterator)) {
                        break;
                    }

                    if ($preserve_keys) {
                        yield $k => $v;
                    }
                    else {
                        yield $v;
                    }

                    $n++;
                    $iterator->next();
                }
                return $n;
            })();
            $chunk++;

            // 回しきらないと無限ループする
            while ($g->valid()) {
                $g->next();
            }
            $total += $g->getReturn();
        }

        return $total;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\iterator_combine') || (new \ReflectionFunction('ryunosuke\\ltsv\\iterator_combine'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\iterator_combine')) {
    /**
     * キーと値のイテレータから キー => 値 なイテレータを作る
     *
     * 要するに array_combine のイテレータ版。
     * 数が一致しないと array_combine と同様例外を投げるが、呼び出し時点では投げられず、ループ後に呼ばれることに注意。
     *
     * Example:
     * ```php
     * // 配列から key => value なイテレータを作る
     * $it = iterator_combine(['a', 'b', 'c'], [1, 2, 3]);
     * that(iterator_to_array($it))->isSame(['a' => 1, 'b' => 2, 'c' => 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\iterator
     *
     * @param iterable $keys キー
     * @param iterable $values 値
     * @return \Iterator $key => $value なイテレータ
     */
    function iterator_combine($keys, $values)
    {
        /** @var \Iterator $itK */
        /** @var \Iterator $itV */
        $itK = is_array($keys) ? (fn() => yield from $keys)() : $keys;
        $itV = is_array($values) ? (fn() => yield from $values)() : $values;

        $multi = new \MultipleIterator(\MultipleIterator::MIT_KEYS_NUMERIC | \MultipleIterator::MIT_NEED_ALL);
        $multi->attachIterator($itK);
        $multi->attachIterator($itV);

        foreach ($multi as $it) {
            yield $it[0] => $it[1];
        }

        // どちらかが回し切れていない≒数が一致していない
        if ($itK->valid() || $itV->valid()) {
            throw new \ValueError("Both parameters should have an equal number of iterators");
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\iterator_join') || (new \ReflectionFunction('ryunosuke\\ltsv\\iterator_join'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\iterator_join')) {
    /**
     * 複数の iterator を一括して回せる iterator を返す。
     *
     * 要するにほぼ AppendIterator のラッパーだが、$iterable には配列も渡すことができるし、キーも振り直すことができる。
     *
     * Example:
     * ```php
     * $iterator = iterator_join([
     *     ['A'],                     // ただの配列
     *     new \ArrayIterator(['B']), // Iterator
     *     (fn() => yield 'C')(),     // Generator
     * ], false);
     * // 上記を回すと 1 ループで全要素を回せる
     * that(iterator_to_array($iterator))->is(['A', 'B', 'C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\iterator
     *
     * @param iterable $iterables 結合する iterable
     * @return \Iterator 一括で回せる iterator
     */
    function iterator_join($iterables, $preserve_keys = true)
    {
        $iterator = new \AppendIterator();
        foreach ($iterables as $iterable) {
            $iterator->append(is_array($iterable) ? (fn() => yield from $iterable)() : $iterable);
        }

        $n = 0;
        foreach ($iterator as $k => $it) {
            if ($preserve_keys) {
                yield $k => $it;
            }
            else {
                yield $n++ => $it;
            }
        }
        return $iterator;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\iterator_map') || (new \ReflectionFunction('ryunosuke\\ltsv\\iterator_map'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\iterator_map')) {
    /**
     * array_map の iterator 版
     *
     * 基本的に array_map と同じ動作にしてあるが、下記の点が異なる。
     *
     * - $callback に null, $iterables に1つだけ渡したときも zip 的動作をする
     *   - array_map は1つの時の一貫性がなく、やや非直感的な動作をする
     * - 値だけではなくキーも渡ってくる
     *   - 例えば $iterables が2つの場合 `($v1, $v2, $k1, $k2)` の4引数が渡ってくる
     *
     * 数が不一致の場合、(v, k) の組が共に null で渡ってくる。
     *
     * Example:
     * ```php
     * // いわゆる zip 操作
     * $it = iterator_map(null, (function () {
     *     yield 1;
     *     yield 2;
     *     yield 3;
     * })(), (function () {
     *     yield 7;
     *     yield 8;
     *     yield 9;
     * })());
     * that(iterator_to_array($it))->isSame([[1, 7], [2, 8], [3, 9]]);
     *
     * // キーも渡ってくる
     * $it = iterator_map(fn($v1, $v2, $k1, $k2) => "$k1:$v1, $k2:$v2", (function () {
     *     yield 'a' => 1;
     *     yield 'b' => 2;
     *     yield 'c' => 3;
     * })(), (function () {
     *     yield 'g' => 7;
     *     yield 'h' => 8;
     *     yield 'i' => 9;
     * })());
     * that(iterator_to_array($it))->isSame(["a:1, g:7", "b:2, h:8", "c:3, i:9"]);
     * ```
     *
     * @package ryunosuke\Functions\Package\iterator
     *
     * @param ?callable $callback コールバック
     * @param iterable ...$iterables iterable
     * @return \Iterator コールバックを適用した iterable
     */
    function iterator_map($callback, ...$iterables)
    {
        $multi = new \MultipleIterator(\MultipleIterator::MIT_KEYS_NUMERIC | \MultipleIterator::MIT_NEED_ANY);
        foreach ($iterables as $iterable) {
            $multi->attachIterator(is_array($iterable) ? (fn() => yield from $iterable)() : $iterable);
        }

        foreach ($multi as $keys => $values) {
            if ($callback === null) {
                yield $values;
            }
            else {
                yield $callback(...$values, ...$keys);
            }
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\iterator_maps') || (new \ReflectionFunction('ryunosuke\\ltsv\\iterator_maps'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\iterator_maps')) {
    /**
     * iterable にコールバック（複数）を適用した Iterator を返す
     *
     * 指定したコールバックで複数回回してマップする。
     * 引数は (値, キー, 連番) が渡ってくる。
     *
     * Example:
     * ```php
     * // Generator の値を2乗してから3を足す
     * $it = iterator_maps((function () {
     *     yield 1;
     *     yield 2;
     *     yield 3;
     * })(), fn($v) => $v ** 2, fn($v) => $v + 3);
     * that(iterator_to_array($it))->isSame([4, 7, 12]);
     * ```
     *
     * @package ryunosuke\Functions\Package\iterator
     *
     * @param iterable $iterable iterable
     * @param callable ...$callbacks コールバック
     * @return \Iterator コールバックを適用した iterable
     */
    function iterator_maps($iterable, ...$callbacks)
    {
        $n = 0;
        foreach ($iterable as $k => $v) {
            foreach ($callbacks as $callback) {
                $callback = func_user_func_array($callback);
                $v = $callback($v, $k, $n);
            }
            yield $k => $v;
            $n++;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\iterator_split') || (new \ReflectionFunction('ryunosuke\\ltsv\\iterator_split'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\iterator_split')) {
    /**
     * iterator から頭何件かを取り出してチャンク化して返す
     *
     * rewind できない iterator から頭1件だけ取り出して rewind して再ループしたい、という状況が稀によくある。
     * この関数と iterator_join と組み合わせればそれが容易に実現できる。
     *
     * $iterable には配列も渡すことができる。
     *
     * Example:
     * ```php
     * $generator = function () {
     *     yield 'a';
     *     yield 'b';
     *     yield 'c';
     *     yield 'd';
     *     yield 'e';
     *     yield 'f';
     *     yield 'g';
     * };
     * // 要素7の Generator から頭1,2件を取り出す
     * [$one, $two, $gen] = iterator_split($generator(), [1, 2]);
     * // 最初の要素は1件
     * that($one)->is(['a']);
     * // 次の要素は2件
     * that($two)->is(['b', 'c']);
     * // かならず最後の要素に元の iterator が来る
     * that($gen)->isInstanceOf(\Iterator::class);
     *
     * // $chunk_sizes の配列のキーは返り値のキーになる
     * ['one' => $one, 'two' => $two, 0 => $gen] = iterator_split($generator(), ['one' => 1, 'two' => 2]);
     * // one は1件
     * that($one)->is(['a']);
     * // two は2件
     * that($two)->is(['b', 'c']);
     * // かならず最後の要素に元の iterator が来る
     * that($gen)->isInstanceOf(\Iterator::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\iterator
     *
     * @param iterable $iterable 対象 iterator
     * @param array $chunk_sizes 各チャンクの数を指定する
     * @param bool $preserve_keys キーを保存するか
     * @return array $chunk_sizes の数+1 の iterable 配列
     */
    function iterator_split($iterable, $chunk_sizes, $preserve_keys = false)
    {
        $iterable = new \NoRewindIterator(is_array($iterable) ? (fn() => yield from $iterable)() : $iterable);

        $results = [];

        foreach ($chunk_sizes as $name => $chunk_size) {
            $n = 0;
            $result = [];
            foreach ($iterable as $key => $val) {
                if ($preserve_keys) {
                    $result[$key] = $val;
                }
                else {
                    $result[] = $val;
                }

                if (++$n === (int) $chunk_size) {
                    $iterable->next();
                    break;
                }
            }
            $results[$name] = $result;
        }

        $results[] = $iterable;

        return $results;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\average') || (new \ReflectionFunction('ryunosuke\\ltsv\\average'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\average')) {
    /**
     * 引数の意味平均値を返す
     *
     * - 3座標の重心座標とか日付の平均とかそういうもの
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 意味平均値
     */
    function average(...$variadic)
    {
        // 用意したはいいが統一的なうまい実装が思いつかない（関数ベースじゃ無理だと思う）
        // average は意味平均、mean は相加平均を明示するために定義は残しておく
        assert(is_array($variadic));
        throw new \DomainException('not implement yet.');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\base_convert_array') || (new \ReflectionFunction('ryunosuke\\ltsv\\base_convert_array'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\base_convert_array')) {
    /**
     * 配列を対象とした base_convert
     *
     * 配列の各要素を数値の桁とみなして基数を変換する。
     *
     * Example:
     * ```php
     * // 123(10進)を7B(16進)に変換
     * that(base_convert_array([1, 2, 3], 10, 16))->isSame([7, 11]);
     * // つまりこういうこと（10 * 10^2 + 20 * 10^1 + 30 * 10^0 => 4 * 16^2 + 12 * 16^1 + 14 * 16^0）
     * that(base_convert_array([10, 20, 30], 10, 16))->isSame([4, 12, 14]);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @copyright 2011 Anthony Ferrara
     * @copyright 2016-2021 Mika Tuupola
     * @see https://github.com/tuupola/base62/blob/2.x/LICENSE
     *
     * @param array $array 対象配列
     * @param int $from_base 変換元基数
     * @param int $to_base 変換先基数
     * @return array 基数変換後の配列
     */
    function base_convert_array($array, $from_base, $to_base)
    {
        assert($from_base > 0);
        assert($to_base > 0);

        // 隠し第4引数が false の場合は gmp を使わない（ロジックのテスト用なので実運用で渡してはならない）
        if (extension_loaded('gmp') && !(func_num_args() === 4 && func_get_arg(3) === false)) {
            $array = array_values(array_reverse($array));
            $bigint = array_reduce(array_keys($array), fn($carry, $i) => $carry + $array[$i] * gmp_pow($from_base, $i), 0);
            $result = [];
            while (gmp_cmp($bigint, 0)) {
                [$bigint, $result[]] = gmp_div_qr($bigint, $to_base);
            }
            return array_reverse(array_map(fn($v) => gmp_intval($v), $result));
        }

        $result = [];
        while ($array) {
            $remainder = 0;
            $quotients = [];
            foreach ($array as $v) {
                $accumulator = $v + $remainder * $from_base;
                $remainder = $accumulator % $to_base;
                $quotient = ($accumulator - ($accumulator % $to_base)) / $to_base;

                if ($quotient || count($quotients)) {
                    $quotients[] = $quotient;
                }
            }
            $result[] = $remainder;
            $array = $quotients;
        }
        return array_reverse($result);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\calculate_formula') || (new \ReflectionFunction('ryunosuke\\ltsv\\calculate_formula'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\calculate_formula')) {
    /**
     * 数式を計算して結果を返す
     *
     * 内部的には eval で計算するが、文字列や関数呼び出しなどは受け付けないため原則としてセーフティ。
     * 許可されるのは定数・数値リテラルと演算子のみ。
     * 定数を許可しているのは PI(3.14) や HOUR(3600) などの利便性のため。
     * 定数値が非数値の場合、強制的に数値化して警告を促す。
     *
     * Example:
     * ```php
     * that(calculate_formula('1 + 2 - 3 * 4'))->isSame(-9);
     * that(calculate_formula('1 + (2 - 3) * 4'))->isSame(-3);
     * that(calculate_formula('PHP_INT_SIZE * 3'))->isSame(PHP_INT_SIZE * 3);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param string $formula 計算式
     * @return int|float 計算結果
     */
    function calculate_formula($formula)
    {
        // TOKEN_PARSE を渡せばシンタックスチェックも行ってくれる
        $tokens = php_parse("<?php ($formula);", [
            'flags' => TOKEN_PARSE,
        ]);
        array_shift($tokens);
        array_pop($tokens);

        $constants = [T_STRING, T_DOUBLE_COLON, T_NS_SEPARATOR, T_NAME_QUALIFIED, T_NAME_FULLY_QUALIFIED, T_NAME_RELATIVE];
        $operands = [T_LNUMBER, T_DNUMBER];
        $operators = ['(', ')', '+', '-', '*', '/', '%', '**'];

        $constant = '';
        $expression = '';
        foreach ($tokens as $token) {
            if (in_array($token->id, [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT], true)) {
                continue;
            }
            if (in_array($token->id, $constants, true)) {
                $constant .= $token->text;
            }
            elseif (in_array($token->id, $operands, true) || in_array($token->text, $operators, true)) {
                if (strlen($constant)) {
                    $expression .= constant($constant) + 0;
                    $constant = '';
                }
                $expression .= $token->text;
            }
            else {
                throw new \ParseError(sprintf("syntax error, unexpected '%s' in  on line %d", $token->text, $token->line));
            }
        }
        return evaluate("return $expression;");
    }
}

assert(!function_exists('ryunosuke\\ltsv\\clamp') || (new \ReflectionFunction('ryunosuke\\ltsv\\clamp'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\clamp')) {
    /**
     * 値を一定範囲に収める
     *
     * $circulative に true を渡すと値が循環する。
     * ただし、循環的な型に限る（整数のみ？）。
     *
     * Example:
     * ```php
     * // 5～9 に収める
     * that(clamp(4, 5, 9))->isSame(5); // 4 は [5～9] の範囲外なので 5 に切り上げられる
     * that(clamp(5, 5, 9))->isSame(5); // 範囲内なのでそのまま
     * that(clamp(6, 5, 9))->isSame(6); // 範囲内なのでそのまま
     * that(clamp(7, 5, 9))->isSame(7); // 範囲内なのでそのまま
     * that(clamp(8, 5, 9))->isSame(8); // 範囲内なのでそのまま
     * that(clamp(9, 5, 9))->isSame(9); // 範囲内なのでそのまま
     * that(clamp(10, 5, 9))->isSame(9); // 10 は [5～9] の範囲外なので 9 に切り下げられる
     *
     * // 5～9 に収まるように循環する
     * that(clamp(4, 5, 9, true))->isSame(9); // 4 は [5～9] の範囲外なので循環して 9 になる
     * that(clamp(5, 5, 9, true))->isSame(5); // 範囲内なのでそのまま
     * that(clamp(6, 5, 9, true))->isSame(6); // 範囲内なのでそのまま
     * that(clamp(7, 5, 9, true))->isSame(7); // 範囲内なのでそのまま
     * that(clamp(8, 5, 9, true))->isSame(8); // 範囲内なのでそのまま
     * that(clamp(9, 5, 9, true))->isSame(9); // 範囲内なのでそのまま
     * that(clamp(10, 5, 9, true))->isSame(5); // 10 は [5～9] の範囲外なので循環して 5 になる
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param int|mixed $value 対象の値
     * @param int|mixed $min 最小値
     * @param int|mixed $max 最大値
     * @param bool $circulative true だと切り詰めるのではなく循環する
     * @return int 一定範囲に収められた値
     */
    function clamp($value, $min, $max, $circulative = false)
    {
        if (!$circulative) {
            return max($min, min($max, $value));
        }

        if ($value < $min) {
            return $max + ($value - $max) % ($max - $min + 1);
        }
        if ($value > $max) {
            return $min + ($value - $min) % ($max - $min + 1);
        }
        return $value;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\decimal') || (new \ReflectionFunction('ryunosuke\\ltsv\\decimal'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\decimal')) {
    /**
     * 数値を指定桁数に丸める
     *
     * 感覚的には「桁数指定できる ceil/floor」に近い。
     * ただし、正の方向(ceil)、負の方向(floor)以外にも0の方向、無限大の方向も実装されている（さらに四捨五入もできる）。
     *
     * - 0   : 0 に近づく方向： 絶対値が必ず減る
     * - null: 0 から離れる方向： 絶対値が必ず増える
     * - -INF: 負の無限大の方向： 数値として必ず減る
     * - +INF : 正の無限大の方向： 数値として必ず増える
     *
     * のように「持っていきたい方向（の数値）」を指定すれば良い（正負自動だけ null で特殊だが）。
     *
     * Example:
     * ```php
     * that(decimal(-3.14, 1, 0))->isSame(-3.1);    // 0 に近づく方向
     * that(decimal(-3.14, 1, null))->isSame(-3.2); // 0 から離れる方向
     * that(decimal(-3.14, 1, -INF))->isSame(-3.2); // 負の無限大の方向
     * that(decimal(-3.14, 1, +INF))->isSame(-3.1); // 正の無限大の方向
     *
     * that(decimal(3.14, 1, 0))->isSame(3.1);    // 0 に近づく方向
     * that(decimal(3.14, 1, null))->isSame(3.2); // 0 から離れる方向
     * that(decimal(3.14, 1, -INF))->isSame(3.1); // 負の無限大の方向
     * that(decimal(3.14, 1, +INF))->isSame(3.2); // 正の無限大の方向
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param int|float $value 丸める値
     * @param int $precision 有効桁数
     * @param mixed $mode 丸めモード（0 || null || ±INF || PHP_ROUND_HALF_XXX）
     * @return float 丸めた値
     */
    function decimal($value, $precision = 0, $mode = 0)
    {
        $precision = (int) $precision;

        if ($precision === 0) {
            if ($mode === 0) {
                return (float) (int) $value;
            }
            if ($mode === INF) {
                return ceil($value);
            }
            if ($mode === -INF) {
                return floor($value);
            }
            if ($mode === null) {
                return $value > 0 ? ceil($value) : floor($value);
            }
            if (in_array($mode, [PHP_ROUND_HALF_UP, PHP_ROUND_HALF_DOWN, PHP_ROUND_HALF_EVEN, PHP_ROUND_HALF_ODD], true)) {
                return round($value, $precision, $mode);
            }
            throw new \InvalidArgumentException('$precision must be either null, 0, INF, -INF');
        }

        if ($precision > 0 && 10 ** PHP_FLOAT_DIG <= abs($value)) {
            trigger_error('it exceeds the valid values', E_USER_WARNING);
        }

        $k = 10 ** $precision;
        return decimal($value * $k, 0, $mode) / $k;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\maximum') || (new \ReflectionFunction('ryunosuke\\ltsv\\maximum'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\maximum')) {
    /**
     * 引数の最大値を返す
     *
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * that(maximum(-1, 0, 1))->isSame(1);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 最大値
     */
    function maximum(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        return max($args);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mean') || (new \ReflectionFunction('ryunosuke\\ltsv\\mean'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mean')) {
    /**
     * 引数の相加平均値を返す
     *
     * - is_numeric でない値は除外される（計算結果に影響しない）
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * that(mean(1, 2, 3, 4, 5, 6))->isSame(3.5);
     * that(mean(1, '2', 3, 'noize', 4, 5, 'noize', 6))->isSame(3.5);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return int|float 相加平均値
     */
    function mean(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        $args = array_filter($args, 'is_numeric') or throw new \LengthException("argument's must be contain munber.");
        return array_sum($args) / count($args);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\median') || (new \ReflectionFunction('ryunosuke\\ltsv\\median'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\median')) {
    /**
     * 引数の中央値を返す
     *
     * - 要素数が奇数の場合は完全な中央値/偶数の場合は中2つの平均。「平均」という概念が存在しない値なら中2つの後の値
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * // 偶数個なので中2つの平均
     * that(median(1, 2, 3, 4, 5, 6))->isSame(3.5);
     * // 奇数個なのでど真ん中
     * that(median(1, 2, 3, 4, 5))->isSame(3);
     * // 偶数個だが文字列なので中2つの後
     * that(median('a', 'b', 'c', 'd'))->isSame('c');
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 中央値
     */
    function median(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        $count = count($args);
        $center = (int) ($count / 2);
        sort($args);
        // 偶数で共に数値なら平均値
        if ($count % 2 === 0 && (is_numeric($args[$center - 1]) && is_numeric($args[$center]))) {
            return ($args[$center - 1] + $args[$center]) / 2;
        }
        // 奇数なら単純に中央値
        else {
            return $args[$center];
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\minimum') || (new \ReflectionFunction('ryunosuke\\ltsv\\minimum'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\minimum')) {
    /**
     * 引数の最小値を返す
     *
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * that(minimum(-1, 0, 1))->isSame(-1);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 最小値
     */
    function minimum(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        return min($args);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mode') || (new \ReflectionFunction('ryunosuke\\ltsv\\mode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mode')) {
    /**
     * 引数の最頻値を返す
     *
     * - 等価比較は文字列で行う。小数時は注意。おそらく php.ini の precision に従うはず
     * - 等価値が複数ある場合の返り値は不定
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * that(mode(0, 1, 2, 2, 3, 3, 3))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 最頻値
     */
    function mode(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        $vals = array_map(function ($v) {
            if (is_object($v)) {
                // ここに特別扱いのオブジェクトを列挙していく
                if ($v instanceof \DateTimeInterface) {
                    return $v->getTimestamp();
                }
                // それ以外は stringify へ移譲（__toString もここに含まれている）
                return stringify($v);
            }
            return (string) $v;
        }, $args);
        $args = array_combine($vals, $args);
        $counts = array_count_values($vals);
        arsort($counts);
        reset($counts);
        return $args[key($counts)];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\sum') || (new \ReflectionFunction('ryunosuke\\ltsv\\sum'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\sum')) {
    /**
     * 引数の合計値を返す
     *
     * - is_numeric でない値は除外される（計算結果に影響しない）
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * that(sum(1, 2, 3, 4, 5, 6))->isSame(21);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 合計値
     */
    function sum(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        $args = array_filter($args, 'is_numeric') or throw new \LengthException("argument's must be contain munber.");
        return array_sum($args);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\annotation_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\annotation_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\annotation_parse')) {
    /**
     * アノテーションっぽい文字列をそれっぽくパースして返す
     *
     * $annotation にはリフレクションオブジェクトも渡せる。
     * その場合、getDocComment や getFilename, getNamespaceName などを用いてある程度よしなに名前解決する。
     * もっとも、@Class(args) 形式を使わないのであれば特に意味はない。
     *
     * $schame で「どのように取得するか？」のスキーマ定義が渡せる。
     * スキーマ定義は連想配列で各アノテーションごとに下記のような定義を指定でき、連想配列でない場合はすべてのアノテーションにおいて指定したとみなされる。
     *
     * - true: 余計なことはせず、アノテーションの文字列をそのまま返す
     * - false: 下記にようによしなに変換して返す
     * - []: 複数値モードを強制する
     * - null: 単一値モードを強制する
     *
     * アノテーションの仕様は下記（すべて $schema が false であるとする）。
     *
     * - @から行末まで（1行に複数のアノテーションは含められない）
     *     - ただし行末が `({[` のいずれかであれば次の `]})` までブロックを記載する機会が与えられる
     *     - ブロックを見つけたときは本来値となるべき値がキーに、ブロックが値となり、結果は必ず配列化される
     * - 同じアノテーションを複数見つけたときは配列化される
     * - `@hogera`: 値なしは null を返す
     * - `@hogera v1 "v2 v3"`: ["v1", "v2 v3"] という配列として返す
     * - `@hogera {key: 123}`: ["key" => 123] という（連想）配列として返す
     * - `@hogera [123, 456]`: [123, 456] という連番配列として返す
     * - `@hogera ("2019/12/23")`: hogera で解決できるクラス名で new して返す（$filename 引数の指定が必要）
     * - 下3つの形式はアノテーション区切りのスペースはあってもなくても良い
     *
     * $schema が true だと上記のような変換は一切行わず、素朴な文字列で返す。
     * あくまで簡易実装であり、本格的に何かをしたいなら専用のパッケージを導入したほうが良い。
     *
     * Example:
     * ```php
     * $annotations = annotation_parse('
     *
     * @noval
     * @single this is value
     * @closure this is value
     * @array this is value
     * @hash {key: 123}
     * @list [1, 2, 3]
     * @ArrayObject([1, 2, 3])
     * @block message {
     *     this is message1
     *     this is message2
     * }
     * @same this is same value1
     * @same this is same value2
     * @same this is same value3
     * ', [
     *     'single'  => true,
     *     'closure' => fn($value) => explode(' ', strtoupper($value)),
     * ]);
     * that($annotations)->is([
     *     'noval'       => null,                        // 値なしは null になる
     *     'single'      => 'this is value',             // $schema 指定してるので文字列になる
     *     'closure'     => ['THIS', 'IS', 'VALUE'],     // $schema 指定してそれがクロージャだとコールバックされる
     *     'array'       => ['this', 'is', 'value'],     // $schema 指定していないので配列になる
     *     'hash'        => ['key' => '123'],            // 連想配列になる
     *     'list'        => [1, 2, 3],                   // 連番配列になる
     *     'ArrayObject' => new \ArrayObject([1, 2, 3]), // new されてインスタンスになる
     *     "block"       => [                            // ブロックはブロック外をキーとした連想配列になる（複数指定でキーは指定できるイメージ）
     *         "message" => ["this is message1\n    this is message2"],
     *     ],
     *     'same'        => [                            // 複数あるのでそれぞれの配列になる
     *         ['this', 'is', 'same', 'value1'],
     *         ['this', 'is', 'same', 'value2'],
     *         ['this', 'is', 'same', 'value3'],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string|\Reflector $annotation アノテーション文字列
     * @param array|mixed $schema スキーマ定義
     * @param string|array $nsfiles ファイル名 or [ファイル名 => 名前空間名]
     * @return array アノテーション配列
     */
    function annotation_parse($annotation, $schema = [], $nsfiles = [])
    {
        if ($annotation instanceof \Reflector) {
            $reflector = $annotation;
            /** @noinspection PhpPossiblePolymorphicInvocationInspection */
            $annotation = $reflector->getDocComment();

            // クラスメンバーリフレクションは getDeclaringClass しないと名前空間が取れない
            if (false
                || $reflector instanceof \ReflectionClassConstant
                || $reflector instanceof \ReflectionProperty
                || $reflector instanceof \ReflectionMethod
            ) {
                $reflector = $reflector->getDeclaringClass();
            }

            // 無名クラスに名前空間という概念はない（無くはないが普通に想起される名前空間ではない）
            $namespaces = [];
            if (!($reflector instanceof \ReflectionClass && $reflector->isAnonymous())) {
                $namespaces[] = $reflector->getNamespaceName();
            }
            $nsfiles[$reflector->getFileName()] = $nsfiles[$reflector->getFileName()] ?? $namespaces;

            // doccomment 特有のインデントを削除する
            $annotation = preg_replace('#(\\R)[ \\t]+\\*[ \\t]?#u', '$1', str_chop($annotation, '/**', '*/'));
        }

        $result = [];
        $multiples = [];

        $brace = [
            '(' => ')',
            '{' => '}',
            '[' => ']',
        ];
        for ($i = 0, $l = strlen($annotation); $i < $l; $i++) {
            $i = strpos_quoted($annotation, '@', $i);
            if ($i === null) {
                break;
            }

            $seppos = min(strpos_array($annotation, [" ", "\t", "\n", '[', '{', '('], $i + 1) ?: [false]);
            $name = substr($annotation, $i + 1, $seppos - $i - 1);
            $i += strlen($name);
            $name = trim($name);

            $key = null;
            $brkpos = strpos_quoted($annotation, "\n", $seppos) ?: strlen($annotation);
            if (isset($brace[$annotation[$brkpos - 1]])) {
                $s = $annotation[$brkpos - 1];
                $e = $brace[$s];
                $brkpos--;
                $key = trim(substr($annotation, $seppos, $brkpos - $seppos));
                $value = $s . str_between($annotation, $s, $e, $brkpos) . $e;
                $i = $brkpos;
            }
            else {
                $endpos = strpos_quoted($annotation, "@", $seppos) ?: strlen($annotation);
                $value = substr($annotation, $seppos, $endpos - $seppos);
                $i += strlen($value);
                $value = trim($value);
            }

            $rawmode = $schema;
            if (is_array($rawmode)) {
                $rawmode = array_key_exists($name, $rawmode) ? $rawmode[$name] : false;
            }
            if ($rawmode instanceof \Closure) {
                $value = $rawmode($value, $key);
            }
            elseif ($rawmode) {
                if (is_string($key)) {
                    $value = substr($value, 1, -1);
                }
            }
            else {
                if (is_array($rawmode)) {
                    $multiples[$name] = true;
                }
                if (is_null($rawmode)) {
                    $multiples[$name] = false;
                }
                if ($value === '') {
                    $value = null;
                }
                elseif (in_array($value[0] ?? null, ['('], true)) {
                    $class = namespace_resolve($name, $nsfiles, 'alias') ?? $name;
                    $value = new $class(...paml_import(substr($value, 1, -1)));
                }
                elseif (in_array($value[0] ?? null, ['{', '['], true)) {
                    $value = (array) paml_import($value)[0];
                }
                else {
                    $value = array_values(array_filter(quoteexplode([" ", "\t"], $value), "strlen"));
                }
            }

            if (array_key_exists($name, $result) && !isset($multiples[$name])) {
                $multiples[$name] = true;
                $result[$name] = [$result[$name]];
            }
            if (strlen($key ?? '')) {
                $multiples[$name] = true;
                $result[$name][$key] = $value;
            }
            elseif (isset($multiples[$name]) && $multiples[$name] === true) {
                $result[$name][] = $value;
            }
            else {
                $result[$name] = $value;
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\console_log') || (new \ReflectionFunction('ryunosuke\\ltsv\\console_log'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\console_log')) {
    /**
     * js の console に値を吐き出す
     *
     * script タグではなく X-ChromeLogger-Data を使用する。
     * したがってヘッダ送信前に呼ぶ必要がある。
     *
     * @package ryunosuke\Functions\Package\misc
     * @see https://craig.is/writing/chrome-logger/techspecs
     *
     * @param mixed ...$values 出力する値（可変引数）
     */
    function console_log(...$values)
    {
        // X-ChromeLogger-Data ヘッダを使うので送信済みの場合は不可
        if (headers_sent($file, $line)) {
            throw new \UnexpectedValueException("header is already sent. $file#$line");
        }

        // データ行（最後だけ書き出すので static で保持する）
        static $rows = [];

        // 最終データを一度だけヘッダで吐き出す（replace を false にしても多重で表示してくれないっぽい）
        if (!$rows && $values) {
            // header_register_callback はグローバルで1度しか登録できないのでライブラリ内部で使うべきではない
            // ob_start にコールバックを渡すと ob_end～ の時に呼ばれるので、擬似的に header_register_callback 的なことができる
            ob_start(function () use (&$rows) {
                $header = base64_encode(mb_convert_encoding(json_encode([
                    'version' => '1.0.0',
                    'columns' => ['log', 'backtrace', 'type'],
                    'rows'    => $rows,
                ]), 'UTF-8', 'ISO-8859-1'));
                header('X-ChromeLogger-Data: ' . $header);
                return false;
            });
        }

        foreach ($values as $value) {
            $rows[] = [[$value], null, 'log'];
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\evaluate') || (new \ReflectionFunction('ryunosuke\\ltsv\\evaluate'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\evaluate')) {
    /**
     * eval のプロキシ関数
     *
     * 一度ファイルに吐いてから require した方が opcache が効くので抜群に速い。
     * また、素の eval は ParseError が起こったときの表示がわかりにくすぎるので少し見やすくしてある。
     *
     * 関数化してる以上 eval におけるコンテキストの引き継ぎはできない。
     * ただし、引数で変数配列を渡せるようにしてあるので get_defined_vars を併用すれば基本的には同じ（$this はどうしようもない）。
     *
     * 短いステートメントだと opcode が少ないのでファイルを経由せず直接 eval したほうが速いことに留意。
     * 一応引数で指定できるようにはしてある。
     *
     * Example:
     * ```php
     * $a = 1;
     * $b = 2;
     * $phpcode = ';
     * $c = $a + $b;
     * return $c * 3;
     * ';
     * that(evaluate($phpcode, get_defined_vars()))->isSame(9);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode 実行する php コード
     * @param array $contextvars コンテキスト変数配列
     * @param int $cachesize キャッシュするサイズ
     * @return mixed eval の return 値
     */
    function evaluate($phpcode, $contextvars = [], $cachesize = 256)
    {
        $cachefile = null;
        if ($cachesize && strlen($phpcode) >= $cachesize) {
            $cachefile = function_configure('storagedir') . '/' . rawurlencode(__FUNCTION__) . '-' . sha1($phpcode) . '.php';
            if (!file_exists($cachefile)) {
                file_put_contents($cachefile, "<?php $phpcode", LOCK_EX);
            }
        }

        try {
            if ($cachefile) {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return require func_get_arg(0);
                })($cachefile, $contextvars);
            }
            else {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return eval(func_get_arg(0));
                })($phpcode, $contextvars);
            }
        }
        catch (\ParseError $ex) {
            $errline = $ex->getLine();
            $errline_1 = $errline - 1;
            $codes = preg_split('#\\R#u', $phpcode);
            $codes[$errline_1] = '>>> ' . $codes[$errline_1];

            $N = 5; // 前後の行数
            $message = $ex->getMessage();
            $message .= "\n" . implode("\n", array_slice($codes, max(0, $errline_1 - $N), $N * 2 + 1));
            if ($cachefile) {
                $message .= "\n in " . realpath($cachefile) . " on line " . $errline . "\n";
            }
            throw new \ParseError($message, $ex->getCode(), $ex);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\namespace_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\namespace_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\namespace_parse')) {
    /**
     * php ファイルをパースして名前空間配列を返す
     *
     * ファイル内で use/use const/use function していたり、シンボルを定義していたりする箇所を検出して名前空間単位で返す。
     *
     * Example:
     * ```php
     * // このような php ファイルをパースすると・・・
     * file_set_contents(sys_get_temp_dir() . '/namespace.php', '
     * <?php
     * namespace NS1;
     * use ArrayObject as AO;
     * use function strlen as SL;
     * function InnerFunc(){}
     * class InnerClass{}
     * define("OUTER\\\\CONST", "OuterConst");
     *
     * namespace NS2;
     * use RuntimeException as RE;
     * use const COUNT_RECURSIVE as CR;
     * class InnerClass{}
     * const InnerConst = 123;
     * ');
     * // このような名前空間配列が得られる
     * that(namespace_parse(sys_get_temp_dir() . '/namespace.php'))->isSame([
     *     'NS1' => [
     *         'const'    => [],
     *         'function' => [
     *             'SL'        => 'strlen',
     *             'InnerFunc' => 'NS1\\InnerFunc',
     *         ],
     *         'alias'    => [
     *             'AO'         => 'ArrayObject',
     *             'InnerClass' => 'NS1\\InnerClass',
     *         ],
     *     ],
     *     'OUTER' => [
     *         'const'    => [
     *             'CONST' => 'OUTER\\CONST',
     *         ],
     *         'function' => [],
     *         'alias'    => [],
     *     ],
     *     'NS2' => [
     *         'const'    => [
     *             'CR'         => 'COUNT_RECURSIVE',
     *             'InnerConst' => 'NS2\\InnerConst',
     *         ],
     *         'function' => [],
     *         'alias'    => [
     *             'RE'         => 'RuntimeException',
     *             'InnerClass' => 'NS2\\InnerClass',
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $filename ファイル名
     * @param array $options オプション配列
     * @return array 名前空間配列
     */
    function namespace_parse($filename, $options = [])
    {
        $filename = realpath($filename);
        $filemtime = filemtime($filename);
        $options += [
            'cache' => null,
        ];
        if ($options['cache'] === null) {
            $options['cache'] = cache($filename, fn() => $filemtime, 'filemtime') >= $filemtime;
        }
        if (!$options['cache']) {
            cache($filename, null, 'filemtime');
            cache($filename, null, __FUNCTION__);
        }
        return cache($filename, function () use ($filename) {
            $stringify = function ($tokens) {
                return trim(implode('', array_column(array_filter($tokens, function ($token) {
                    return in_array($token->id, [T_NAME_QUALIFIED, T_NAME_FULLY_QUALIFIED, T_NAME_RELATIVE, T_STRING], true);
                }), 'text')), '\\');
            };

            $keys = [
                null        => 'alias', // for use
                T_CLASS     => 'alias',
                T_INTERFACE => 'alias',
                T_TRAIT     => 'alias',
                T_STRING    => 'const', // for define
                T_CONST     => 'const',
                T_FUNCTION  => 'function',
            ];

            $contents = file_get_contents($filename);
            $namespace = '';
            $tokens = [-1 => null];
            $result = [];
            while (true) {
                $tokens = php_parse($contents, [
                    'flags'  => TOKEN_PARSE,
                    'begin'  => ["define", T_NAMESPACE, T_USE, T_CONST, T_FUNCTION, T_CLASS, T_INTERFACE, T_TRAIT],
                    'end'    => ['{', ';', '(', T_EXTENDS, T_IMPLEMENTS],
                    'offset' => last_key($tokens) + 1,
                ]);
                if (!$tokens) {
                    break;
                }
                $token = reset($tokens);
                // define は現在の名前空間とは無関係に名前空間定数を宣言することができる
                if ($token->id === T_STRING && $token->text === "define") {
                    $tokens = php_parse($contents, [
                        'flags'  => TOKEN_PARSE,
                        'begin'  => [T_CONSTANT_ENCAPSED_STRING],
                        'end'    => [T_CONSTANT_ENCAPSED_STRING],
                        'offset' => last_key($tokens),
                    ]);
                    $cname = substr(implode('', array_column($tokens, 'text')), 1, -1);
                    $define = trim(json_decode("\"$cname\""), '\\');
                    [$ns, $nm] = namespace_split($define);
                    if (!isset($result[$ns])) {
                        $result[$ns] = [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                    }
                    $result[$ns][$keys[$token->id]][$nm] = $define;
                }
                switch ($token->id) {
                    case T_NAMESPACE:
                        $namespace = $stringify($tokens);
                        $result[$namespace] = [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                        break;
                    case T_USE:
                        $tokenCorF = array_find($tokens, fn($token) => ($token->id === T_CONST || $token->id === T_FUNCTION) ? $token->id : 0, false);

                        $prefix = '';
                        if (end($tokens)->text === '{') {
                            $prefix = $stringify($tokens);
                            $tokens = php_parse($contents, [
                                'flags'  => TOKEN_PARSE,
                                'begin'  => ['{'],
                                'end'    => ['}'],
                                'offset' => last_key($tokens),
                            ]);
                        }

                        $multi = array_explode($tokens, fn($token) => $token->text === ',');
                        foreach ($multi as $ttt) {
                            $as = array_explode($ttt, fn($token) => $token->id === T_AS);

                            $alias = $stringify($as[0]);
                            if (isset($as[1])) {
                                $result[$namespace][$keys[$tokenCorF]][$stringify($as[1])] = concat($prefix, '\\') . $alias;
                            }
                            else {
                                $result[$namespace][$keys[$tokenCorF]][namespace_split($alias)[1]] = concat($prefix, '\\') . $alias;
                            }
                        }
                        break;
                    case T_CONST:
                    case T_FUNCTION:
                    case T_CLASS:
                    case T_INTERFACE:
                    case T_TRAIT:
                        $alias = $stringify($tokens);
                        if (strlen($alias)) {
                            $result[$namespace][$keys[$token->id]][$alias] = concat($namespace, '\\') . $alias;
                        }
                        // ブロック内に興味はないので進めておく（function 内 function などはあり得るが考慮しない）
                        if ($token->id !== T_CONST) {
                            $tokens = php_parse($contents, [
                                'flags'  => TOKEN_PARSE,
                                'begin'  => ['{'],
                                'end'    => ['}'],
                                'offset' => last_key($tokens),
                            ]);
                            break;
                        }
                }
            }
            return $result;
        }, __FUNCTION__);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\namespace_resolve') || (new \ReflectionFunction('ryunosuke\\ltsv\\namespace_resolve'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\namespace_resolve')) {
    /**
     * エイリアス名を完全修飾名に解決する
     *
     * 例えばあるファイルのある名前空間で `use Hoge\Fuga\Piyo;` してるときの `Piyo` を `Hoge\Fuga\Piyo` に解決する。
     *
     * Example:
     * ```php
     * // このような php ファイルがあるとして・・・
     * file_set_contents(sys_get_temp_dir() . '/symbol.php', '
     * <?php
     * namespace vendor\NS;
     *
     * use ArrayObject as AO;
     * use function strlen as SL;
     *
     * function InnerFunc(){}
     * class InnerClass{}
     * ');
     * // 下記のように解決される
     * that(namespace_resolve('AO', sys_get_temp_dir() . '/symbol.php'))->isSame('ArrayObject');
     * that(namespace_resolve('SL', sys_get_temp_dir() . '/symbol.php'))->isSame('strlen');
     * that(namespace_resolve('InnerFunc', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerFunc');
     * that(namespace_resolve('InnerClass', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerClass');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $shortname エイリアス名
     * @param string|array $nsfiles ファイル名 or [ファイル名 => 名前空間名]
     * @param array $targets エイリアスタイプ（'const', 'function', 'alias' のいずれか）
     * @return string|null 完全修飾名。解決できなかった場合は null
     */
    function namespace_resolve(string $shortname, $nsfiles, $targets = ['const', 'function', 'alias'])
    {
        // 既に完全修飾されている場合は何もしない
        if (($shortname[0] ?? null) === '\\') {
            return $shortname;
        }

        // use Inner\Space のような名前空間の use の場合を考慮する
        $parts = explode('\\', $shortname, 2);
        $prefix = isset($parts[1]) ? array_shift($parts) : null;

        if (is_string($nsfiles)) {
            $nsfiles = [$nsfiles => []];
        }

        $targets = (array) $targets;
        foreach ($nsfiles as $filename => $namespaces) {
            $namespaces = array_flip(array_map(fn($n) => trim($n, '\\'), (array) $namespaces));
            foreach (namespace_parse($filename) as $namespace => $ns) {
                /** @noinspection PhpIllegalArrayKeyTypeInspection */
                if (!$namespaces || isset($namespaces[$namespace])) {
                    if (isset($ns['alias'][$prefix])) {
                        return $ns['alias'][$prefix] . '\\' . implode('\\', $parts);
                    }
                    foreach ($targets as $target) {
                        if (isset($ns[$target][$shortname])) {
                            return $ns[$target][$shortname];
                        }
                    }
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\php_highlight') || (new \ReflectionFunction('ryunosuke\\ltsv\\php_highlight'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\php_highlight')) {
    /**
     * php のコードをハイライトする
     *
     * SAPI に応じて自動でハイライトする（html タグだったり ASCII color だったり）。
     * highlight_string の CLI 対応版とも言える。
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode ハイライトする php コード
     * @param array|int $options オプション
     * @return string ハイライトされた php コード
     */
    function php_highlight($phpcode, $options = [])
    {
        $options += [
            'context' => null,
        ];

        $context = $options['context'];

        if ($context === null) {
            $context = 'html'; // SAPI でテストカバレッジが辛いので if else ではなくデフォルト代入にしてある
            if (PHP_SAPI === 'cli') {
                $context = is_ansi(STDOUT) ? 'cli' : 'plain';
            }
        }

        $colorize = static function ($value, $style) use ($context) {
            switch ($context) {
                default:
                    throw new \InvalidArgumentException("'$context' is not supported.");
                case 'plain':
                    return $value;
                case 'cli':
                    return ansi_colorize($value, $style);
                case 'html':
                    $names = array_flip(preg_split('#[^a-z]#i', $style));
                    $keys = [
                        'bold'       => 'font-weight:bold',
                        'faint'      => '',
                        'italic'     => 'font-style:italic',
                        'underscore' => 'text-decoration:underline',
                        'blink'      => '',
                        'reverse'    => '',
                        'conceal'    => '',
                    ];
                    $colors = array_keys(array_diff_key($names, $keys));
                    $styles = array_intersect_key($keys, $names);
                    $styles[] = 'color:' . reset($colors);
                    $style = implode(';', $styles);
                    return "<span style='$style'>" . htmlspecialchars($value, ENT_QUOTES) . '</span>';
            }
        };

        $type = 'bold';
        $keyword = 'magenta|bold';
        $symbol = 'green|italic';
        $literal = 'red';
        $variable = 'underscore';
        $comment = 'blue|italic';

        $rules = [
            'null'                     => $type,
            'false'                    => $type,
            'true'                     => $type,
            'iterable'                 => $type,
            'bool'                     => $type,
            'float'                    => $type,
            'int'                      => $type,
            'string'                   => $type,
            T_ABSTRACT                 => $keyword,
            T_ARRAY                    => $keyword,
            T_CALLABLE                 => $keyword,
            T_CLASS_C                  => $keyword,
            T_DIR                      => $keyword,
            T_FILE                     => $keyword,
            T_FUNC_C                   => $keyword,
            T_LINE                     => $keyword,
            T_METHOD_C                 => $keyword,
            T_NS_C                     => $keyword,
            T_TRAIT_C                  => $keyword,
            T_AS                       => $keyword,
            T_BOOLEAN_AND              => $keyword,
            T_BOOLEAN_OR               => $keyword,
            T_BREAK                    => $keyword,
            T_CASE                     => $keyword,
            T_CATCH                    => $keyword,
            T_CLASS                    => $keyword,
            T_CLONE                    => $keyword,
            T_CONST                    => $keyword,
            T_CONTINUE                 => $keyword,
            T_DECLARE                  => $keyword,
            T_DEFAULT                  => $keyword,
            T_DO                       => $keyword,
            T_ELSE                     => $keyword,
            T_ELSEIF                   => $keyword,
            T_ENDDECLARE               => $keyword,
            T_ENDFOR                   => $keyword,
            T_ENDFOREACH               => $keyword,
            T_ENDIF                    => $keyword,
            T_ENDSWITCH                => $keyword,
            T_ENDWHILE                 => $keyword,
            T_END_HEREDOC              => $keyword,
            T_EXIT                     => $keyword,
            T_EXTENDS                  => $keyword,
            T_FINAL                    => $keyword,
            T_FINALLY                  => $keyword,
            T_FOR                      => $keyword,
            T_FOREACH                  => $keyword,
            T_ECHO                     => $keyword,
            T_FUNCTION                 => $keyword,
            T_GLOBAL                   => $keyword,
            T_GOTO                     => $keyword,
            T_IF                       => $keyword,
            T_IMPLEMENTS               => $keyword,
            T_INSTANCEOF               => $keyword,
            T_INSTEADOF                => $keyword,
            T_INTERFACE                => $keyword,
            T_LOGICAL_AND              => $keyword,
            T_LOGICAL_OR               => $keyword,
            T_LOGICAL_XOR              => $keyword,
            T_NAMESPACE                => $keyword,
            T_NEW                      => $keyword,
            T_PRIVATE                  => $keyword,
            T_PUBLIC                   => $keyword,
            T_PROTECTED                => $keyword,
            T_RETURN                   => $keyword,
            T_STATIC                   => $keyword,
            T_SWITCH                   => $keyword,
            T_THROW                    => $keyword,
            T_TRAIT                    => $keyword,
            T_TRY                      => $keyword,
            T_USE                      => $keyword,
            T_VAR                      => $keyword,
            T_WHILE                    => $keyword,
            T_YIELD                    => $keyword,
            T_YIELD_FROM               => $keyword,
            T_EMPTY                    => $keyword,
            T_EVAL                     => $keyword,
            T_ISSET                    => $keyword,
            T_LIST                     => $keyword,
            T_PRINT                    => $keyword,
            T_UNSET                    => $keyword,
            T_INCLUDE                  => $keyword,
            T_INCLUDE_ONCE             => $keyword,
            T_REQUIRE                  => $keyword,
            T_REQUIRE_ONCE             => $keyword,
            T_HALT_COMPILER            => $keyword,
            T_STRING                   => $symbol,
            T_CONSTANT_ENCAPSED_STRING => $literal,
            T_ENCAPSED_AND_WHITESPACE  => $literal,
            T_NUM_STRING               => $literal,
            T_DNUMBER                  => $literal,
            T_LNUMBER                  => $literal,
            // T_STRING_VARNAME           => $literal,
            // T_CURLY_OPEN               => $literal,
            // T_DOLLAR_OPEN_CURLY_BRACES => $literal,
            '"'                        => $literal,
            T_VARIABLE                 => $variable,
            T_COMMENT                  => $comment,
            T_DOC_COMMENT              => $comment,
        ];

        $tokens = \PhpToken::tokenize($phpcode, TOKEN_PARSE);
        foreach ($tokens as $n => $token) {
            $style = $rules[strtolower($token->text)] ?? $rules[$token->id] ?? null;
            if ($style !== null) {
                $token->text = $colorize($token->text, $style);
            }
            $tokens[$n] = $token;
        }
        return implode('', array_column($tokens, 'text'));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\php_indent') || (new \ReflectionFunction('ryunosuke\\ltsv\\php_indent'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\php_indent')) {
    /**
     * php のコードのインデントを調整する
     *
     * baseline で基準インデント位置を指定する。
     * その基準インデントを削除した後、指定したインデントレベルでインデントするようなイメージ。
     *
     * Example:
     * ```php
     * $phpcode = '
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ';
     * // 数値指定は空白換算
     * that(php_indent($phpcode, 8))->isSame('
     *         echo 123;
     *
     *         if (true) {
     *             echo 456;
     *         }
     * ');
     * // 文字列を指定すればそれが使用される
     * that(php_indent($phpcode, "  "))->isSame('
     *   echo 123;
     *
     *   if (true) {
     *       echo 456;
     *   }
     * ');
     * // オプション指定
     * that(php_indent($phpcode, [
     *     'baseline'  => 1,    // 基準インデントの行番号（負数で下からの指定になる）
     *     'indent'    => 4,    // インデント指定（上記の数値・文字列指定はこれの糖衣構文）
     *     'trimempty' => true, // 空行を trim するか
     *     'heredoc'   => true, // Flexible Heredoc もインデントするか
     * ]))->isSame('
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode インデントする php コード
     * @param array|int|string $options オプション
     * @return string インデントされた php コード
     */
    function php_indent($phpcode, $options = [])
    {
        if (!is_array($options)) {
            $options = ['indent' => $options];
        }
        $options += [
            'baseline'  => 1,
            'indent'    => 0,
            'trimempty' => true,
            'heredoc'   => true,
        ];
        if (is_int($options['indent'])) {
            $options['indent'] = str_repeat(' ', $options['indent']);
        }

        $lines = preg_split('#\\R#u', $phpcode);
        $baseline = $options['baseline'];
        if ($baseline < 0) {
            $baseline = count($lines) + $baseline;
        }
        preg_match('@^[ \t]*@u', $lines[$baseline] ?? '', $matches);
        $indent = $matches[0] ?? '';

        $tmp = \PhpToken::tokenize("<?php $phpcode");
        array_shift($tmp);

        // トークンの正規化
        $tokens = [];
        for ($i = 0; $i < count($tmp); $i++) {
            if ($options['heredoc']) {
                // 行コメントと同じ（T_START_HEREDOC には改行が含まれている）
                if ($tmp[$i]->id === T_START_HEREDOC && preg_match('@^(<<<).*?(\\R)@um', $tmp[$i]->text, $matches)) {
                    $tmp[$i]->text = trim($tmp[$i]->text);
                    if (($tmp[$i + 1]->id ?? null) === T_ENCAPSED_AND_WHITESPACE) {
                        $tmp[$i + 1]->text = $matches[2] . $tmp[$i + 1]->text;
                    }
                    else {
                        array_splice($tmp, $i + 1, 0, [new \PhpToken(T_ENCAPSED_AND_WHITESPACE, $matches[2])]);
                    }
                }
                // php 7.3 において T_END_HEREDOC は必ず単一行になる
                if ($tmp[$i]->id === T_ENCAPSED_AND_WHITESPACE) {
                    if (($tmp[$i + 1]->id ?? null) === T_END_HEREDOC && preg_match('@^(\\s+)(.*)@um', $tmp[$i + 1]->text, $matches)) {
                        $tmp[$i]->text = $tmp[$i]->text . $matches[1];
                        $tmp[$i + 1]->text = $matches[2];
                    }
                }
            }

            $tokens[] = $tmp[$i];
        }

        // 改行を置換してインデント
        $hereing = false;
        foreach ($tokens as $i => $token) {
            if ($options['heredoc']) {
                if ($token->id === T_START_HEREDOC) {
                    $hereing = true;
                }
                if ($token->id === T_END_HEREDOC) {
                    $hereing = false;
                }
            }
            if (in_array($token->id, [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT], true) || ($hereing && $token->id === T_ENCAPSED_AND_WHITESPACE)) {
                $token->text = preg_replace("@(\\R)$indent@um", '$1' . $options['indent'], $token->text);
            }
            if ($options['trimempty']) {
                if ($token->id === T_WHITESPACE) {
                    $token->text = preg_replace("@(\\R)[ \\t]+(\\R)@um", '$1$2', $token->text);
                }
            }

            $tokens[$i] = $token;
        }
        return implode('', array_column($tokens, 'text'));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\php_opcode') || (new \ReflectionFunction('ryunosuke\\ltsv\\php_opcode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\php_opcode')) {
    /**
     * コード断片の opcode を返す
     *
     * php レベルでサクッと取りたいことはあるし、ini 設定がややややこしく、簡単に取れない場合があるので関数化した。
     * phpdbg 等ではなく opcache で出すため、与えたコードは実行されることに注意。
     *
     * @see https://www.npopov.com/2022/05/22/The-opcache-optimizer.html
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode php コード
     * @param int $level opt_debug_level に渡される（URL 参照だが、正味使うのは 0x10000:最適化前, 0x20000:最適化後 くらいだろう）
     * @return string opcode
     */
    function php_opcode($phpcode, $level = 0x20000)
    {
        $level = dechex($level);

        // log_errors=0 でもいいけど、何かに使えるかもしれないしログは残しておく
        $errorlog = sys_get_temp_dir() . '/php-cli.log';
        touch($errorlog);
        $errorlog = realpath($errorlog);
        @unlink($errorlog);

        process(php_binary(), [
            '-d' => [
                "opcache.enable=1",                   // 必須
                "opcache.enable_cli=1",               // 必須
                "opcache.opt_debug_level=0x{$level}", // 必須
                "opcache.file_update_protection=0",   // 0 にしないと作成直後は opcache が無効になる
                "auto_prepend_file=",                 // 余計なファイルが実行されうる
                "auto_append_file=",                  // 余計なファイルが実行されうる
                "error_log=$errorlog",                // 標準エラーに出力されるので指定しないと混ざる
            ],
        ], "<?php\n$phpcode", $stdout, $stderr);

        return $stderr;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\php_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\php_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\php_parse')) {
    /**
     * php のコード断片をパースする
     *
     * @todo そもそも何がしたいのかよくわからない関数になってきたので動作の洗い出しが必要
     *
     * Example:
     * ```php
     * $phpcode = '<?php
     * namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * // namespace ～ ; を取得
     * $part = php_parse($phpcode, [
     *     'begin' => T_NAMESPACE,
     *     'end'   => ';',
     * ]);
     * that(implode('', array_column($part, 'text')))->isSame('namespace Hogera;');
     *
     * // class ～ { を取得
     * $part = php_parse($phpcode, [
     *     'begin' => T_CLASS,
     *     'end'   => '{',
     * ]);
     * that(implode('', array_column($part, 'text')))->isSame("class Example\n{");
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode パースする php コード
     * @param array|int $option パースオプション
     * @return \PhpToken[] トークン配列
     */
    function php_parse($phpcode, $option = [])
    {
        if (is_int($option)) {
            $option = ['flags' => $option];
        }

        $default = [
            'short_open_tag' => null, // ショートオープンタグを扱うか（null だと余計なことはせず ini に従う）
            'line'           => [],   // 行の範囲（以上以下）
            'position'       => [],   // 文字位置の範囲（以上以下）
            'begin'          => [],   // 開始トークン
            'end'            => [],   // 終了トークン
            'offset'         => 0,    // 開始トークン位置
            'flags'          => 0,    // PHPToken の $flags. TOKEN_PARSE を与えると ParseError が出ることがあるのでデフォルト 0
            'cache'          => true, // キャッシュするか否か
            'greedy'         => false,// end と nest か一致したときに処理を継続するか
            'backtick'       => true, // `` もパースするか
            'nest_token'     => [
                ')' => '(',
                '}' => '{',
                ']' => '[',
            ],
        ];
        $option += $default;

        $cachekey = var_hash($phpcode) . $option['flags'] . '-' . $option['backtick'] . '-' . var_export($option['short_open_tag'], true);
        static $cache = [];
        if (!($option['cache'] && isset($cache[$cachekey]))) {
            $position = 0;
            $backtick = '';
            $backticktoken = null;
            $backticking = false;

            $tokens = [];
            $tmp = \PhpToken::tokenize($phpcode, $option['flags']);
            for ($i = 0; $i < count($tmp); $i++) {
                $token = $tmp[$i];

                // @codeCoverageIgnoreStart
                if ($option['short_open_tag'] === true && $token->id === T_INLINE_HTML && ($p = strpos($token->text, '<?')) !== false) {
                    $newtokens = [];
                    $nlcount = 0;

                    if ($p !== 0) {
                        $html = substr($token->text, 0, $p);
                        $nlcount = preg_match_all('#\r\n|\r|\n#u', $html);
                        $newtokens[] = new \PhpToken(T_INLINE_HTML, $html, $token->line);
                    }

                    $code = substr($token->text, $p + 2);
                    $subtokens = \PhpToken::tokenize("<?php $code");
                    $subtokens[0]->text = '<?';
                    foreach ($subtokens as $subtoken) {
                        $subtoken->line += $token->line + $nlcount - 1;
                        $newtokens[] = $subtoken;
                    }

                    array_splice($tmp, $i + 1, 0, $newtokens);
                    continue;
                }
                if ($option['short_open_tag'] === false && $token->id === T_OPEN_TAG && $token->text === '<?') {
                    for ($j = $i + 1; $j < count($tmp); $j++) {
                        if ($tmp[$j]->id === T_CLOSE_TAG) {
                            break;
                        }
                    }
                    $html = implode('', array_map(fn($token) => $token->text, array_slice($tmp, $i, $j - $i + 1)));
                    array_splice($tmp, $i + 1, $j - $i, [new \PhpToken(T_INLINE_HTML, $html, $token->line)]);
                    continue;
                }
                // @codeCoverageIgnoreEnd

                if (!$option['backtick']) {
                    if ($token->text === '`') {
                        if ($backticking) {
                            $token->text = $backtick . $token->text;
                            $token->line = $backticktoken->line;
                            $token->pos = $backticktoken->pos;
                            $backtick = '';
                        }
                        else {
                            $backticktoken = $token;
                        }
                        $backticking = !$backticking;
                    }
                    if ($backticking) {
                        $backtick .= $token->text;
                        continue;
                    }
                }

                $token->pos = $position;
                $position += strlen($token->text);

                /* PhpToken になりコピーオンライトが効かなくなったので時々書き換えをチェックした方が良い
                $token = new class($token->id, $token->text, $token->line, $token->pos) extends \PhpToken {
                    private array $backup = [];
    
                    public function backup()
                    {
                        $this->backup = [
                            'id'   => $this->id,
                            'text' => $this->text,
                            'line' => $this->line,
                            'pos'  => $this->pos,
                        ];
                    }
    
                    public function __clone(): void
                    {
                        $this->backup = [];
                    }
    
                    public function __destruct()
                    {
                        foreach ($this->backup as $name => $value) {
                            assert($this->$name === $value);
                        }
                    }
                };
                $token->backup();
                 */

                $tokens[] = $token;
            }
            // @codeCoverageIgnoreStart
            if ($option['short_open_tag'] === false) {
                for ($i = 0; $i < count($tokens); $i++) {
                    if ($tokens[$i]->id === T_INLINE_HTML && isset($tokens[$i + 1]) && $tokens[$i + 1]->id === T_INLINE_HTML) {
                        $tokens[$i]->text .= $tokens[$i + 1]->text;
                        array_splice($tokens, $i + 1, 1, []);
                        $i--;
                    }
                }
            }
            // @codeCoverageIgnoreEnd
            $cache[$cachekey] = $tokens;
        }
        $tokens = $cache[$cachekey];

        $lines = $option['line'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $positions = $option['position'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $begin_tokens = (array) $option['begin'];
        $end_tokens = (array) $option['end'];
        $nest_tokens = $option['nest_token'];
        $greedy = $option['greedy'];

        $result = [];
        $starting = !$begin_tokens;
        $nesting = 0;
        $offset = is_array($option['offset']) ? ($option['offset'][0] ?? 0) : $option['offset'];
        $endset = is_array($option['offset']) ? ($option['offset'][1] ?? count($tokens)) : count($tokens);

        for ($i = $offset; $i < $endset; $i++) {
            $token = $tokens[$i];

            if ($lines[0] > $token->line) {
                continue;
            }
            if ($lines[1] < $token->line) {
                continue;
            }
            if ($positions[0] > $token->pos) {
                continue;
            }
            if ($positions[1] < $token->pos) {
                continue;
            }

            foreach ($begin_tokens as $t) {
                if ($t === $token->id || $t === $token->text) {
                    $starting = true;
                    break;
                }
            }
            if (!$starting) {
                continue;
            }

            $result[$i] = $token;

            foreach ($nest_tokens as $end_nest => $start_nest) {
                if ($token->id === $start_nest || $token->text === $start_nest) {
                    $nesting++;
                }
                if ($token->id === $end_nest || $token->text === $end_nest) {
                    $nesting--;
                }
            }

            foreach ($end_tokens as $t) {
                if ($t === $token->id || $t === $token->text) {
                    if ($nesting <= 0 || ($nesting === 1 && in_array($t, $nest_tokens, true))) {
                        if ($nesting === 0 && $greedy && isset($nest_tokens[$t])) {
                            break;
                        }
                        break 2;
                    }
                    break;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\php_strip') || (new \ReflectionFunction('ryunosuke\\ltsv\\php_strip'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\php_strip')) {
    /**
     * 文字列から php コードを取り除く
     *
     * 正確にはオプションの replacer で指定したものに置換される（デフォルト空文字なので削除になる）。
     * replacer にクロージャを渡すと(phpコード, 出現番号) が渡ってくるので、それに応じて値を返せばそれに置換される。
     * 文字列を指定すると自動で出現番号が付与される。
     *
     * $mapping 配列には「どれをどのように」と言った変換表が格納される。
     * 典型的には strtr に渡して php コードを復元させるのに使用する。
     *
     * Example:
     * ```php
     * $phtml = 'begin php code <?php echo 123 ?> end';
     * // php コードが消えている
     * that(php_strip($phtml))->is('begin php code  end');
     * // $mapping を使用すると元の文字列に復元できる
     * $html = php_strip($phtml, [], $mapping);
     * that(strtr($html, $mapping))->is($phtml);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phtml php コードを含む文字列
     * @param array $option オプション配列
     * @param array $mapping 変換表が格納される参照変数
     * @return string php コードが除かれた文字列
     */
    function php_strip($phtml, $option = [], &$mapping = [])
    {
        $option = array_replace([
            'short_open_tag' => true,
            'trailing_break' => true,
            'replacer'       => func_num_args() === 3 ? null : '',
        ], $option);

        $replacer = $option['replacer'];
        if ($replacer === '') {
            $replacer = fn($phptag, $n) => '';
        }
        if ($replacer === null) {
            $replacer = unique_string($phtml, 64);
        }

        $tmp = php_parse($phtml, $option);

        if ($option['trailing_break']) {
            $tokens = $tmp;
        }
        else {
            $tokens = [];
            $echoopen = false;
            $taglength = strlen('?>');
            foreach ($tmp as $token) {
                if ($token->id === T_OPEN_TAG_WITH_ECHO) {
                    $echoopen = true;
                }
                if ($echoopen && $token->id === T_CLOSE_TAG && isset($token->text[$taglength])) {
                    $echoopen = false;

                    $tokens[] = new \PhpToken(
                        $token->id,
                        rtrim($token->text),
                        $token->line,
                        $token->pos,
                    );
                    $tokens[] = new \PhpToken(
                        T_INLINE_HTML,
                        substr($token->text, $taglength),
                        $token->line,
                        $token->pos + $taglength,
                    );
                }
                else {
                    $tokens[] = $token;
                }
            }
        }

        $offsets = [];
        foreach ($tokens as $token) {
            if ($token->id === T_OPEN_TAG || $token->id === T_OPEN_TAG_WITH_ECHO) {
                $offsets[] = [$token->pos, null];
            }
            elseif ($token->id === T_CLOSE_TAG) {
                $lastkey = count($offsets) - 1;
                $offsets[$lastkey][1] = $token->pos + strlen($token->text) - $offsets[$lastkey][0];
            }
        }
        if ($offsets) {
            $lastkey = count($offsets) - 1;
            $offsets[$lastkey][1] = $offsets[$lastkey][1] ?? strlen($phtml) - $offsets[$lastkey][0];
        }

        $mapping = [];
        foreach (array_reverse($offsets) as $n => [$offset, $length]) {
            if ($replacer instanceof \Closure) {
                $mapping[$n] = substr($phtml, $offset, $length);
                $phtml = substr_replace($phtml, $replacer($mapping[$n], $n), $offset, $length);
            }
            else {
                $tag = $replacer . $n;
                $mapping[$tag] = substr($phtml, $offset, $length);
                $phtml = substr_replace($phtml, $tag, $offset, $length);
            }
        }

        return $phtml;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\unique_id') || (new \ReflectionFunction('ryunosuke\\ltsv\\unique_id'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\unique_id')) {
    /**
     * 一意な文字列を返す
     *
     * 最大でも8バイト（64ビット）に収まるようにしてある。
     *
     * - 41bit: 1ミリ秒単位
     * - 7bit: シーケンス
     * - 16bit: IPv4ホストアドレス
     *
     * いわゆる snowflake 系で sonyflake が近い。
     *
     * シーケンスは「単位時間（1ミリ秒）あたりに発行できる数」を表す。
     * 7bit で少し少ないが、生成にファイルロックを使用しているため、1ミリ秒で 128 回生成されることがそもそもレアケース。
     * 7bit を超えると強制的に1ミリ秒待って timestamp を変えることで重複を防ぐ（≒その時は発行に1ミリ秒かかる）。
     *
     * 複数の IPv4 アドレスを持つ場合はサブネットが最も長いもの（ホストアドレスが最も短いもの）が使用される。
     * IPv6 は未対応で、サブネット /16 未満も未対応。
     *
     * 引数はデバッグ用でいくつか用意しているが、実運用としては引数ゼロとして扱うこと。
     *
     * 以下、思考過程と備考。
     *
     * - 単調増加の値としてタイムスタンプを採用
     *     - 如何にホスト・シーケンスが同じになろうと発行時刻が別なら別IDにするためのプレフィックスとして使用する
     *     - 時間が巻き戻らない限りは大丈夫
     *     - 2093年までしか発行できない（`(2 ** 41) * (10 ** -3) / 60 / 60 / 24 / 365` = 69.73 年）
     * - サーバー間で重複を許したくない場合の候補は下記で、現在は IPv4 を採用している
     *     - ホスト名
     *         - 文字列で大きさが読めないし一意である保証もない
     *     - MAC アドレス
     *         - 一意だが少し大きすぎる
     *         - 下3桁がシリアルIDらしいので同メーカーなら重複しないかもしれない
     *         - ただそもそも php で MAC アドレスを簡単に得る手段がない
     *     - IPv4
     *         - サーバー間で重複を許さないような id の生成は大抵クラスタを組んでいて IP が振られているはず
     *         - そして 4byte でユニークな IP が振られることはまずない（大抵は 2,3byte で固有のはず。/12未満のクラスタ構成なんて見たことない）
     *     - IPv6
     *         - 桁が大きすぎる
     *         - まだまだ IPv4 も現役なので積極的に採用する理由に乏しい
     *     - 引数で machine id を渡す
     *         - 大抵のシステムでホスト数は1,2桁だろうので小bitで済む
     *         - でも引数無しにしたかった
     * - プロセス間の重複（シーケンス）はファイルロックを使用して採番している
     *     - プロセスIDを採用してたが思ったより大きすぎた（現代的な linux ではデフォルト 2**22 らしい）
     *     - 逐次ロックなので大量生成には全く向かない
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param array $id_info 元になった生成データのレシーバ引数
     * @param array $debug デバッグ用引数（配列で内部の動的な値を指定できる）
     * @return string 一意なバイナリ文字列
     */
    function unique_id(&$id_info = [], $debug = [])
    {
        $id_info = [];

        assert(PHP_INT_SIZE === 8);
        static $TIMESTAMP_BASE = 1704034800; // 2024-01-01 00:00:00
        static $TIMESTAMP_PRECISION = 1;
        static $TIMESTAMP_BIT = 41;
        static $SEQUENCE_BIT = 7;
        static $IPADDRESS_BIT = 16;
        assert(($TIMESTAMP_BIT + $SEQUENCE_BIT + $IPADDRESS_BIT) === 64);

        static $ipaddress = null;
        $ipaddress ??= (function () {
            $addrs = [];
            foreach (net_get_interfaces() as $interface) {
                foreach ($interface['unicast'] as $addr) {
                    // IPv4 で・・・
                    if ($addr['family'] === AF_INET) {
                        // subnet/16 以上のもの
                        $subnet = strrpos(decbin((ip2long($addr['netmask']))), '1') + 1;
                        if ($subnet >= 16) {
                            $addrs[] = [$addr['address'], $subnet];
                        }
                    }
                    // @todo subnet が /104 なら IPv6 でもいける？
                }
            }
            if ($addrs) {
                usort($addrs, fn($a, $b) => -($a[1] <=> $b[1]));
                return reset($addrs)[0];
            }
            throw new \UnexpectedValueException("ip address is not found"); // @codeCoverageIgnore
        })();
        $ipaddress = $debug['ipaddress'] ?? $ipaddress;

        // プロセスを跨いだ連番生成器（何かに使えそうなのでクラスにまとめて少し冗長になっている）
        static $sequencer = null;
        $sequencer ??= new class (sys_get_temp_dir() . "/id-sequence") {
            private     $handle;
            private int $lockcount = 0;

            public function __construct(string $lockfile)
            {
                $this->handle = fopen($lockfile, 'c+');
            }

            public function lock(): int
            {
                if (flock($this->handle, LOCK_EX)) {
                    $this->lockcount++;
                }
                return $this->lockcount;
            }

            public function unlock(): int
            {
                if (flock($this->handle, LOCK_UN)) {
                    $this->lockcount--;
                }
                return $this->lockcount;
            }

            public function reset(int $sequence): void
            {
                assert($this->lockcount > 0, 'must be lock');

                set_error_handler(function ($severity, $message, $file, $line) { throw new \ErrorException($message, 0, $severity, $file, $line); });
                try {
                    rewind($this->handle);
                    ftruncate($this->handle, 0);
                    fwrite($this->handle, $sequence);
                }
                finally {
                    restore_error_handler();
                }
            }

            public function add(int $increment = 1): int
            {
                assert($this->lockcount > 0, 'must be lock');

                set_error_handler(function ($severity, $message, $file, $line) { throw new \ErrorException($message, 0, $severity, $file, $line); });
                try {
                    rewind($this->handle);
                    $sequence = (int) stream_get_contents($this->handle);

                    $next = $sequence + $increment;
                    $this->reset(is_float($next) ? 0 : $next);

                    return $sequence;
                }
                finally {
                    restore_error_handler();
                }
            }
        };

        $sequencer->lock();
        try {
            $timestamp = $debug['timestamp'] ?? microtime(true);
            if (isset($debug['sequence'])) {
                $sequencer->reset($debug['sequence']);
            }

            $sequence = $sequencer->add() % (1 << $SEQUENCE_BIT);
            if ($sequence === 0) {
                usleep(1000 * $TIMESTAMP_PRECISION);
                $timestamp = microtime(true);
            }
        }
        finally {
            $sequencer->unlock();
        }

        $id_info = [
            'timestamp' => (int) (($timestamp - $TIMESTAMP_BASE) * 1000 / $TIMESTAMP_PRECISION),
            'sequence'  => $sequence,
            'ipsegment' => ip2long($ipaddress) & ((1 << $IPADDRESS_BIT) - 1),
        ];

        assert(($id_info['timestamp'] & ((1 << $TIMESTAMP_BIT) - 1)) === $id_info['timestamp']);
        assert(($id_info['sequence'] & ((1 << $SEQUENCE_BIT) - 1)) === $id_info['sequence']);
        assert(($id_info['ipsegment'] & ((1 << $IPADDRESS_BIT) - 1)) === $id_info['ipsegment']);

        $ipaddress_right_bits = 0;
        $sequence_right_bits = $ipaddress_right_bits + $IPADDRESS_BIT;
        $timestamp_right_bits = $sequence_right_bits + $SEQUENCE_BIT;

        return pack('J', ($id_info['timestamp'] << $timestamp_right_bits) | ($id_info['sequence'] << $sequence_right_bits) | ($id_info['ipsegment'] << $ipaddress_right_bits));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cidr2ip') || (new \ReflectionFunction('ryunosuke\\ltsv\\cidr2ip'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cidr2ip')) {
    /**
     * cidr 内の IP アドレスを返す
     *
     * すべての IP アドレスを返すため、`/1` のような極端な値を投げてはならない。
     * （Generator の方がいいかもしれない）。
     *
     * ipv6 は今のところ未対応。
     *
     * Example:
     * ```php
     * that(cidr2ip('192.168.0.0/30'))->isSame(['192.168.0.0', '192.168.0.1', '192.168.0.2', '192.168.0.3']);
     * that(cidr2ip('192.168.0.255/30'))->isSame(['192.168.0.252', '192.168.0.253', '192.168.0.254', '192.168.0.255']);
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param string $cidr cidr
     * @return array IP アドレス
     */
    function cidr2ip($cidr)
    {
        [$prefix, , $mask] = cidr_parse($cidr);

        $prefix = ip2long($prefix) >> $mask << $mask;

        $result = [];
        for ($i = 0, $l = 1 << $mask; $i < $l; $i++) {
            $result[] = long2ip($prefix + $i);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cidr_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\cidr_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cidr_parse')) {
    /**
     * cidr を分割する
     *
     * ※ 内部向け
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param string $cidr
     * @return array [$address, $networkBit, $localBit]
     */
    function cidr_parse($cidr)
    {
        [$address, $subnet] = explode('/', trim($cidr), 2) + [1 => 32];

        if (!filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            throw new \InvalidArgumentException("subnet addr '$address' is invalid.");
        }
        if (!(ctype_digit("$subnet") && (0 <= $subnet && $subnet <= 32))) {
            throw new \InvalidArgumentException("subnet mask '$subnet' is invalid.");
        }

        $subnet = (int) $subnet;
        return [$address, $subnet, 32 - $subnet];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\getipaddress') || (new \ReflectionFunction('ryunosuke\\ltsv\\getipaddress'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\getipaddress')) {
    /**
     * 接続元となる IP を返す
     *
     * IP を指定してそこへ接続する際の SourceIP を返す（省略すると最初のエントリを返す）。
     * 複数のネットワークにマッチした場合の結果は不定（最長が無難だろうがそもそも SourceIP がどうなるかが不定）。
     *
     * Example:
     * ```php
     * // 何らかの IP アドレスが返ってくる
     * that(getipaddress())->isValidIpv4();
     * // 自分への接続元は自分なので 127.0.0.1 を返す
     * that(getipaddress('127.0.0.9'))->isSame('127.0.0.1');
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param string|int|null $target 接続先
     * @return ?string IP アドレス
     */
    function getipaddress($target = null)
    {
        $net_get_interfaces = cache("net_get_interfaces", fn() => net_get_interfaces(), __FUNCTION__);

        // int, null 時は最初のエントリを返す（ループバックは除く）
        if ($target === null || is_int($target)) {
            $target ??= AF_INET;
            unset($net_get_interfaces['lo']);
            foreach ($net_get_interfaces as $interface) {
                foreach ($interface['unicast'] as $unicast) {
                    if ($unicast['family'] === $target) {
                        return $unicast['address'];
                    }
                }
            }
            return null;
        }

        if (filter_var($target, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false) {
            $family = AF_INET;
        }
        elseif (filter_var($target, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false) {
            $family = AF_INET6;
        }
        else {
            throw new \InvalidArgumentException("$target is invalid ip address");
        }

        $targetBytes = unpack('C*', inet_pton($target));

        foreach ($net_get_interfaces as $interface) {
            foreach ($interface['unicast'] as $unicast) {
                if ($unicast['family'] === $family) {
                    $addressBytes = unpack('C*', inet_pton($unicast['address']));
                    $netmaskBytes = unpack('C*', inet_pton($unicast['netmask']));
                    foreach ($netmaskBytes as $i => $netmaskByte) {
                        if (($addressBytes[$i] & $netmaskByte) !== ($targetBytes[$i] & $netmaskByte)) {
                            continue 2;
                        }
                    }
                    return $unicast['address'];
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_delete') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_delete'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_delete')) {
    /**
     * {@link http_request() http_request} の DELETE 特化版
     *
     * @package ryunosuke\Functions\Package\network
     * @inheritdoc http_request()
     *
     * @param string $url 対象 URL
     * @param mixed $data パラメータ
     * @return mixed レスポンスボディ
     */
    function http_delete($url, $data = [], $options = [], &$response_header = [], &$info = [])
    {
        $default = [
            'url'    => $url,
            'method' => 'DELETE',
            'body'   => $data,
        ];
        return http_request($options + $default, $response_header, $info);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_get') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_get'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_get')) {
    /**
     * {@link http_request() http_request} の GET 特化版
     *
     * @package ryunosuke\Functions\Package\network
     * @inheritdoc http_request()
     *
     * @param string $url 対象 URL
     * @param mixed $data パラメータ
     * @return mixed レスポンスボディ
     */
    function http_get($url, $data = [], $options = [], &$response_header = [], &$info = [])
    {
        if (!is_empty($data, true)) {
            $url .= (strrpos($url, '?') === false ? '?' : '&') . (is_array($data) || is_object($data) ? http_build_query($data) : $data);
        }
        $default = [
            'url'    => $url,
            'method' => 'GET',
        ];
        return http_request($options + $default, $response_header, $info);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_head') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_head'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_head')) {
    /**
     * {@link http_request() http_request} の HEAD 特化版
     *
     * @package ryunosuke\Functions\Package\network
     * @inheritdoc http_request()
     *
     * @param string $url 対象 URL
     * @param mixed $data パラメータ
     * @return array レスポンスヘッダ
     */
    function http_head($url, $data = [], $options = [], &$response_header = [], &$info = [])
    {
        $default = [
            'method'       => 'HEAD',
            CURLOPT_NOBODY => true,
        ];
        http_get($url, $data, $options + $default, $response_header, $info);
        return $response_header;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_patch') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_patch'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_patch')) {
    /**
     * {@link http_request() http_request} の PATCH 特化版
     *
     * @package ryunosuke\Functions\Package\network
     * @inheritdoc http_request()
     *
     * @param string $url 対象 URL
     * @param mixed $data パラメータ
     * @return mixed レスポンスボディ
     */
    function http_patch($url, $data = [], $options = [], &$response_header = [], &$info = [])
    {
        $default = [
            'url'    => $url,
            'method' => 'PATCH',
            'body'   => $data,
        ];
        return http_request($options + $default, $response_header, $info);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_post') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_post'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_post')) {
    /**
     * {@link http_request() http_request} の POST 特化版
     *
     * @package ryunosuke\Functions\Package\network
     * @inheritdoc http_request()
     *
     * @param string $url 対象 URL
     * @param mixed $data パラメータ
     * @return mixed レスポンスボディ
     */
    function http_post($url, $data = [], $options = [], &$response_header = [], &$info = [])
    {
        $default = [
            'url'    => $url,
            'method' => 'POST',
            'body'   => $data,
        ];
        return http_request($options + $default, $response_header, $info);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_put') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_put'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_put')) {
    /**
     * {@link http_request() http_request} の PUT 特化版
     *
     * @package ryunosuke\Functions\Package\network
     * @inheritdoc http_request()
     *
     * @param string $url 対象 URL
     * @param mixed $data パラメータ
     * @return mixed レスポンスボディ
     */
    function http_put($url, $data = [], $options = [], &$response_header = [], &$info = [])
    {
        $default = [
            'url'    => $url,
            'method' => 'PUT',
            'body'   => $data,
        ];
        return http_request($options + $default, $response_header, $info);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_request') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_request'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_request')) {
    /**
     * curl のラッパー関数
     *
     * curl は高機能だけど、低レベルで設定が細かすぎる上に似たようなものが大量にあるので素で書くのが割とつらい。
     * のでデフォルトをスタンダードな設定に寄せつつ、多少便利になるようにラップしている。
     * まぁ現在では guzzle みたいなクライアントも整ってるし、使い捨てスクリプトでサクッとリクエストを投げたい時用。
     *
     * 生 curl との差異は下記。
     *
     * - `CURLOPT_HTTPHEADER` は連想配列指定が可能
     * - `CURLOPT_POSTFIELDS` は連想配列・多次元配列指定が可能
     * - 単一ファイル指定は単一アップロードになる
     *
     * さらに独自のオプションとして下記がある。
     *
     * - `raw` (bool): curl インスタンスと変換クロージャを返すだけになる
     *     - ただし、ほぼデバッグや内部用なので指定することはほぼ無いはず
     * - `async` (bool): リクエストを投げて、結果を返すオブジェクトを返す
     *     - いわゆる非同期で、すぐさま処理を返し、結果は返り値オブジェクト経由で取得する
     * - `nobody` (bool): ヘッダーの受信が完了したらただちに処理を返す
     *     - ボディは空文字になる（CURLOPT_NOBODY とは全く性質が異なるので注意）
     * - `throw` (bool): ステータスコードが 400 以上のときに例外を投げる
     *     - `CURLOPT_FAILONERROR` は原則使わないほうがいいと思う
     * - `retry` (float[]|callable): エラーが出た場合にリトライする
     *     - 配列で指定した回数・秒数のリトライを行う（[1, 2, 3] で、1秒後、2秒後、3秒後になる）
     *     - callable を指定するとその callable が false を返すまでリトライする（引数として curl_info が渡ってきて待機秒数を返す）
     * - `atfile` (bool): キーに @ があるフィールドをファイルアップロードとみなす
     *     - 悪しき `CURLOPT_SAFE_UPLOAD` の代替。ただし値ではなくキーで判別する
     *     - 値が配列のフィールドのキーに @ をつけると連番要素のみアップロードになる
     * - `cachedir` (string): GET のときにクライアントキャッシュや 304 キャッシュが効くようになる
     *     - Cache-Control の private, public は見ないので一応注意
     * - `parser` (array): Content-Type に基づいて body をパースする
     *     - 今のところ application/json のみ
     *
     * また、頻出するオプションは下記の定数のエイリアスがあり、単純に読み替えられる。
     *
     * - `url`: `CURLOPT_URL`
     * - `method`: `CURLOPT_CUSTOMREQUEST`
     * - `cookie`: `CURLOPT_COOKIE`
     * - `header`: `CURLOPT_HTTPHEADER`
     * - `body`: `CURLOPT_POSTFIELDS`
     * - `cookie_file`: `CURLOPT_COOKIEJAR`, `CURLOPT_COOKIEFILE`
     *
     * Example:
     * ```php
     * $response = http_request([
     *     'url'    => TESTWEBSERVER . '/post?name=value',
     *     'method' => 'POST',
     *     'body'   => ['k1' => 'v1', 'k2' => 'v2'],
     * ]);
     * that($response['args'])->is([
     *     'name' => 'value',
     * ]);
     * that($response['form'])->is([
     *     'k1' => 'v1',
     *     'k2' => 'v2',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param array $options curl_setopt_array に渡される
     * @param array $response_header レスポンスヘッダが連想配列で格納される
     * @param array $info curl_getinfo が格納される
     * @return mixed レスポンスボディ
     */
    function http_request($options = [], &$response_header = [], &$info = [])
    {
        $options += [
            // curl options
            CURLOPT_CUSTOMREQUEST  => 'GET', // リクエストメソッド
            CURLINFO_HEADER_OUT    => true,  // リクエストヘッダを含める
            CURLOPT_HTTPHEADER     => [],    // リクエストヘッダ
            CURLOPT_COOKIE         => null,  // リクエストクッキー
            CURLOPT_POSTFIELDS     => null,  // リクエストボディ
            CURLOPT_NOBODY         => false, // HEAD 用
            CURLOPT_ENCODING       => "",    // Accept-Encoding 兼自動展開
            CURLOPT_FOLLOWLOCATION => true,  // リダイレクトをたどる
            CURLOPT_MAXREDIRS      => 16,    // リダイレクトをたどる回数
            CURLOPT_RETURNTRANSFER => true,  // 戻り値として返す
            CURLOPT_HEADER         => true,  // レスポンスヘッダを含める
            CURLOPT_CONNECTTIMEOUT => 60,    // timeout on connect
            CURLOPT_TIMEOUT        => 60,    // timeout on response

            // alias option
            'url'                  => null,
            'method'               => null,
            'cookie'               => null,
            'header'               => null,
            'body'                 => null,
            'cookie_file'          => null,

            // custom options
            'raw'                  => false,
            'async'                => false,
            'nobody'               => false,
            'throw'                => true,
            'retry'                => [],
            'atfile'               => true,
            'cachedir'             => null,
            'parser'               => [
                'application/json' => [
                    'request'  => fn($contents) => json_export($contents),
                    'response' => fn($contents) => json_import($contents),
                ],
            ],
        ];

        // 利便性用の定数エイリアス
        $options[CURLOPT_URL] = $options['url'] ?? $options[CURLOPT_URL];
        $options[CURLOPT_CUSTOMREQUEST] = $options['method'] ?? $options[CURLOPT_CUSTOMREQUEST];
        $options[CURLOPT_COOKIE] = $options['cookie'] ?? $options[CURLOPT_COOKIE];
        $options[CURLOPT_HTTPHEADER] = $options['header'] ?? $options[CURLOPT_HTTPHEADER];
        $options[CURLOPT_POSTFIELDS] = $options['body'] ?? $options[CURLOPT_POSTFIELDS];
        if (isset($options['cookie_file'])) {
            $options[CURLOPT_COOKIEJAR] = $options['cookie_file'];
            $options[CURLOPT_COOKIEFILE] = $options['cookie_file'];
        }
        if ($options['nobody']) {
            $headers = '';
            $options[CURLOPT_HEADERFUNCTION] = function ($curl, $header) use (&$headers) {
                if (trim($header) === '') {
                    return -1;
                }
                $headers .= $header;
                return strlen($header);
            };
        }

        // ヘッダは後段の判定に頻出するので正規化して取得しておく
        $request_header = array_kvmap($options[CURLOPT_HTTPHEADER], function ($k, $v) {
            if (is_int($k)) {
                [$k, $v] = explode(':', $v, 2);
            }
            return [strtolower(trim($k)) => trim($v)];
        });

        // request body 変換
        $content_type = split_noempty(';', $request_header['content-type'] ?? '');
        if ($convert = ($options['parser'][strtolower($content_type[0] ?? '')]['request'] ?? null)) {
            $options[CURLOPT_POSTFIELDS] = $convert($options[CURLOPT_POSTFIELDS], ...$content_type);
        }

        // response クロージャ
        $response_parse = function ($response, $info) use ($options) {
            [$head, $body] = str_chunk($response, $info['header_size']);

            $head = str_array($head, ':', true);
            $info['no_request'] = false;
            $info['response_size'] = strlen($response);
            $info['content_type'] = $info['content_type'] ?? null;
            $info['cache_control'] = $head['Cache-Control'] ?? null;
            $info['last_modified'] = $head['Last-Modified'] ?? null;
            $info['etag'] = $head['ETag'] ?? null;
            if (isset($info['request_header']) && is_string($info['request_header'])) {
                $info['request_header'] = str_array($info['request_header'], ':', true);
            }

            if (!($options[CURLOPT_NOBODY] ?? false) && !$options['nobody']) {
                $content_type = split_noempty(';', $info['content_type'] ?? '');
                if ($convert = ($options['parser'][strtolower($content_type[0] ?? '')]['response'] ?? null)) {
                    $body = $convert($body, ...$content_type);
                }
            }

            return [$info, $head, $body];
        };

        // キャッシュのキー
        $filekey = null;
        if ($options[CURLOPT_CUSTOMREQUEST] === 'GET' && isset($options['cachedir'])) {
            [$url, $query] = explode('?', $options[CURLOPT_URL]) + [1 => ''];
            $filekey = $options['cachedir'] . DIRECTORY_SEPARATOR . urlencode($url) . sha1($query);
        }

        // http cache
        if (isset($filekey)) {
            if (file_exists($filekey)) {
                $fp = fopen($filekey, 'r');
                if ($fp !== false) {
                    try {
                        $info = json_decode(fgets($fp), true);
                        if (stripos($info['cache_control'] ?? '', 'no-cache') === false && preg_match('#max-age=(\\d+)#i', $info['cache_control'] ?? '', $matches)) {
                            clearstatcache(true, $filekey);
                            if (time() - filemtime($filekey) < $matches[1]) {
                                $info['no_request'] = true;
                                $response = stream_get_contents($fp);
                                [, $response_header, $body] = $response_parse($response, $info);
                                return $body;
                            }
                        }

                        if ($info['last_modified']) {
                            $options[CURLOPT_HTTPHEADER]['if-modified-since'] = $info['last_modified'];
                        }
                        if ($info['etag']) {
                            $options[CURLOPT_HTTPHEADER]['if-none-match'] = $info['etag'];
                        }
                    }
                    finally {
                        fclose($fp);
                    }
                }
            }
        }

        // http cache クロージャ
        $cache = function ($response, $info) use ($filekey, $response_parse) {
            if (isset($filekey)) {
                if ($info['http_code'] === 200 && stripos($info['cache_control'] ?? '', 'no-store') === false) {
                    file_set_contents($filekey, json_encode($info, JSON_UNESCAPED_SLASHES) . "\n" . $response);
                }
                if ($info['http_code'] === 304 && file_exists($filekey)) {
                    touch($filekey);
                    [$info2, $response] = explode("\n", file_get_contents($filekey), 2);
                    return $response_parse($response, json_decode($info2, true))[2];
                }
            }
        };

        // CURLOPT_POSTFIELDS は配列を渡せば万事 OK ・・・と思いきや多次元には対応していないのでフラットにする
        if (is_array($options[CURLOPT_POSTFIELDS])) {
            // の、前に @ 付きキーを CURLFile に変換
            if ($options['atfile']) {
                $options[CURLOPT_POSTFIELDS] = array_kvmap($options[CURLOPT_POSTFIELDS], function ($k, $v, $callback) {
                    $atfile = ($k[0] ?? null) === '@';
                    if ($atfile) {
                        $k = substr($k, 1);
                        if (is_array($v)) {
                            $v = array_kvmap($v, fn($k, $v) => [is_int($k) ? "@$k" : $k => $v]);
                        }
                        else {
                            $v = new \CURLFile($v);
                        }
                    }
                    if (is_array($v)) {
                        $v = array_kvmap($v, $callback);
                    }
                    return [$k => $v];
                });
            }
            // CURLFile が含まれているかもしれないので http_build_query は使えない
            $options[CURLOPT_POSTFIELDS] = array_flatten($options[CURLOPT_POSTFIELDS], fn($keys) => array_shift($keys) . ($keys ? '[' . implode('][', $keys) . ']' : ''));
        }

        // 単一ファイルは単一アップロードとする
        if ($options[CURLOPT_POSTFIELDS] instanceof \CURLFile) {
            $file = $options[CURLOPT_POSTFIELDS];
            unset($options[CURLOPT_POSTFIELDS]);
            if (!isset($request_header['content-type'])) {
                $options[CURLOPT_HTTPHEADER]['content-type'] = $file->getMimeType() ?: mime_content_type($file->getFilename());
            }
            $options[CURLOPT_INFILE] = fopen($file->getFilename(), 'r');
            $options[CURLOPT_INFILESIZE] = filesize($file->getFilename());
            $options[CURLOPT_PUT] = true;
        }

        // CURLOPT_HTTPHEADER は素の配列しか受け入れてくれないので連想配列を k: v 形式に変換
        $options[CURLOPT_HTTPHEADER] = array_sprintf($options[CURLOPT_HTTPHEADER], fn($v, $k) => is_int($k) ? $v : "$k: $v");

        // 同上： CURLOPT_COOKIE
        if ($options[CURLOPT_COOKIE] && is_array($options[CURLOPT_COOKIE])) {
            $options[CURLOPT_COOKIE] = array_sprintf($options[CURLOPT_COOKIE], fn($v, $k) => is_int($k) ? $v : rawurlencode($k) . "=" . rawurlencode($v), '; ');
        }

        assert(is_callable($options['retry']) || is_array($options['retry']));
        $retry = is_callable($options['retry']) ? $options['retry'] : function ($info) use ($options) {
            // リトライを費やしたなら打ち切り
            $time = $options['retry'][$info['retry']] ?? null;
            if ($time === null) {
                return false;
            }
            // curl レイヤでは一部の curl_errno のみ
            if (in_array($info['errno'], [CURLE_OPERATION_TIMEOUTED, CURLE_GOT_NOTHING, CURLE_SEND_ERROR, CURLE_RECV_ERROR])) {
                return $time;
            }
            // 結果が返ってきてるなら打ち切り…としたいところだが、一部のコードはリトライ対象とする。ちょっと思うところがあるのでメモを下記に記す
            // 429 は微妙。いわゆるレート制限が多いだろうので、リトライしてもどうせコケる
            // 502 はもっと微妙。でも「たまたま具合の悪い ap サーバに到達してしまった」ならリトライの価値はある
            // 503 は本来あるべきリトライだろうけど、過負荷でリトライしても…という思いもある
            if ($info['errno'] === CURLE_OK && in_array($info['http_code'], [429, 502, 503])) {
                return $time;
            }

            return false;
        };

        $responser = function ($response, $info) use ($options, $response_parse, $cache) {
            if ($options['throw'] && $info['http_code'] >= 400) {
                throw new \UnexpectedValueException("status is {$info['http_code']}.");
            }
            if (!($info['errno'] === CURLE_OK || ($options['nobody'] && $info['errno'] === CURLE_WRITE_ERROR))) {
                throw new \RuntimeException(curl_strerror($info['errno']), $info['errno']);
            }
            [$info, $head, $body] = $response_parse($response, $info);
            return [$cache($response, $info) ?? $body, $head, $info];
        };

        $ch = curl_init();
        curl_setopt_array($ch, array_filter($options, 'is_int', ARRAY_FILTER_USE_KEY));
        if ($options['raw']) {
            return [$ch, $responser, $retry];
        }

        if ($options['async']) {
            // コールバックを実行したときに初めてエラーが分かるので自動リトライに何の意味もない
            assert(empty($options['retry']), 'Cannot specify async and retry option');

            $client = new class($ch, $responser, $response_header, $info) {
                private $singleHandle;
                private $multiHandle;

                private $responser;

                private $header;
                private $info;

                public function __construct($handle, $responser, &$header, &$info)
                {
                    $this->singleHandle = $handle;
                    $this->multiHandle = curl_multi_init();
                    curl_multi_add_handle($this->multiHandle, $this->singleHandle);

                    $this->responser = $responser;

                    $this->header = &$header;
                    $this->info = &$info;
                }

                public function __destruct()
                {
                    $this->close();
                }

                public function __invoke()
                {
                    while (true) {
                        $this->wait();
                        $minfo = curl_multi_info_read($this->multiHandle);

                        if ($minfo !== false) {
                            $info = curl_getinfo($minfo['handle']);
                            $info['errno'] = curl_errno($minfo['handle']);
                            $response = curl_multi_getcontent($minfo['handle']);
                            [$body, $this->header, $this->info] = ($this->responser)($response, $info);

                            $this->close();
                            return $body;
                        }
                        usleep(1);
                    }
                }

                public function wait(float $timeout = 1.0)
                {
                    do {
                        $execed = curl_multi_exec($this->multiHandle, $still_running);
                    } while ($execed === CURLM_CALL_MULTI_PERFORM);

                    while (curl_multi_select($this->multiHandle, $timeout) === -1) {
                        usleep(1); // @codeCoverageIgnore
                    }

                    return $still_running;
                }

                public function close()
                {
                    if (isset($this->singleHandle)) {
                        curl_multi_remove_handle($this->multiHandle, $this->singleHandle);
                        curl_close($this->singleHandle);
                        curl_multi_close($this->multiHandle);

                        unset($this->singleHandle);
                        unset($this->multiHandle);
                    }
                }
            };

            // この wait がないとリクエストが始まってすらいないので非同期にならない
            // 名前解決、cert 処理など様々なアクティビティがあるが「手を離してもよい」と判断できる最適なものは接続済み(connect_time>0)っぽい
            while (true) {
                $active = $client->wait();
                $info = curl_getinfo($ch);
                if ($info['connect_time'] || $active === 0) {
                    break;
                }
                usleep(1);
            }
            // 接続さえしてしまえば後は OS/curl が勝手にやってくれるはずなのでこの段階で返してよい
            return $client;
        }

        try {
            $retry_count = 0;
            do {
                $headers = '';
                $response = curl_exec($ch);
                if ($options['nobody']) {
                    $response = $headers;
                }
                $info = curl_getinfo($ch);
                $info['retry'] = $retry_count++;
                $info['errno'] = curl_errno($ch);
                $time = $retry($info, $response);
                usleep($time * 1000 * 1000);
            } while ($time);
        }
        finally {
            curl_close($ch);
        }

        [$body, $response_header, $info] = $responser($response, $info);
        return $body;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\http_requests') || (new \ReflectionFunction('ryunosuke\\ltsv\\http_requests'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\http_requests')) {
    /**
     * http リクエストを並列で投げる
     *
     * $urls で複数の curl を渡し、並列で実行して複数の結果をまとめて返す。
     * $urls の要素は単一の文字列か curl のオプションである必要がある。
     * リクエストの実体は http_request なので、そっちで使えるオプションは一部を除きすべて使える。
     *
     * 返り値は $urls のキーを保持したまま、レスポンスが返ってきた順にボディを格納して配列で返す。
     * 構造は下記のサンプルを参照。
     *
     * ただし、オプションに callback がある場合、各リクエスト完了直後にそれがコールされ、返り値はそのコールバックの返り値になる。
     *
     * Example:
     * ```php
     * $responses = http_requests([
     *     // このように [キー => CURL オプション] 形式が正しい使い方
     *     'fuga'             => [
     *         CURLOPT_URL     => 'http://unknown-host',
     *         CURLOPT_TIMEOUT => 5,
     *     ],
     *     // ただし、このように [キー => URL] 形式でもいい（オプションはデフォルトが使用される）
     *     'hoge'             => 'http://127.0.0.1',
     *     // さらに、このような [URL => CURL オプション] 形式も許容される（あまり用途はないだろうが）
     *     'http://127.0.0.1' => [
     *         CURLOPT_TIMEOUT => 5,
     *         'callback'      => fn($key, $body) => $body,
     *     ],
     * ], [
     *     // 第2引数で各リクエストの共通オプションを指定できる（個別指定優先）
     *     // @see https://www.php.net/manual/ja/function.curl-setopt.php
     * ], [
     *     // 第3引数でマルチリクエストのオプションを指定できる
     *     // @see https://www.php.net/manual/ja/function.curl-multi-setopt.php
     * ],
     *     // 第4引数を与えるとボディ以外の各種情報が格納される
     *     $infos
     * );
     * # 返り値
     * [
     *     // キーが維持されるので hoge キー
     *     'hoge'             => 'response body',
     *     // curl のエラーが出た場合は null になる（詳細なエラー情報は $infos に格納される）
     *     'fuga'             => null,
     *     // callback を設定しているので strlen($body) が返り値になる
     *     'http://127.0.0.1' => 12345,
     * ];
     * # 第4引数（要するにキーを維持しつつ [header, curlinfo] が格納される）
     * [
     *     'hoge'             => [['response header'], ['curl_info']],
     *     'fuga'             => [['response header'], ['curl_info']],
     *     'http://127.0.0.1' => [['response header'], ['curl_info']],
     * ];
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param array $urls 実行する curl オプション
     * @param array $single_options 全 $urls に適用されるデフォルトオプション
     * @param array $multi_options 並列リクエストとしてのオプション
     * @param array $infos curl 情報やヘッダなどが格納される受け変数
     * @return array レスポンスボディ配列。取得した順番でキーを保持しつつ追加される
     */
    function http_requests($urls, $single_options = [], $multi_options = [], &$infos = [])
    {
        // urls の正規化
        foreach ($urls as $key => $opt) {
            // 文字列は URL 指定とみなす
            if (is_string($opt)) {
                $opt = [CURLOPT_URL => $opt];
            }
            // クロージャはコールバック指定とみなす
            if ($opt instanceof \Closure) {
                $opt = ['callback' => $opt];
            }
            // さらに URL 指定がないなら key を URL とみなす
            if (!isset($opt[CURLOPT_URL]) && !isset($opt['url'])) {
                $opt[CURLOPT_URL] = $key;
            }

            $urls[$key] = $opt + $single_options;
        }

        $multi_options += [
            'throw' => false, // curl レイヤーでエラーが出たら例外を投げるか（http レイヤーではない）
        ];

        // 固定オプション（必ずこの値が使用される）
        $default = [
            'raw'                  => true,
            'throw'                => false,
            CURLOPT_FAILONERROR    => false,
            CURLOPT_RETURNTRANSFER => true, // 戻り値として返す
            CURLOPT_HEADER         => true, // ヘッダを含める
        ];

        $responses = [];
        $resultmap = [];
        $infos = [];

        $set_response = function ($key, $body, $header, $info) use ($urls, &$responses, &$infos) {
            $responses[$key] = $body;
            $infos[$key] = [$header, $info];

            if (isset($urls[$key]['callback'])) {
                $responses[$key] = $urls[$key]['callback']($key, $body, $header, $info);
            }
        };

        $mh = curl_multi_init();
        foreach (array_filter($multi_options, 'is_int', ARRAY_FILTER_USE_KEY) as $name => $value) {
            curl_multi_setopt($mh, $name, $value);
        }

        try {
            foreach ($urls as $key => $opt) {
                $rheader = null;
                $info = null;
                $res = http_request($default + $opt, $rheader, $info);
                if (is_array($res) && isset($res[0]) && $handle_id = spl_object_id($res[0])) {
                    curl_multi_add_handle($mh, $res[0]);
                    $resultmap[$handle_id] = [$key, $res[1], $res[2], microtime(true), 0];
                }
                else {
                    $set_response($key, $res, $rheader, $info);
                }
            }

            do {
                do {
                    $mrc = curl_multi_exec($mh, $active);
                } while ($mrc === CURLM_CALL_MULTI_PERFORM);

                // see http://php.net/manual/ja/function.curl-multi-select.php#115381
                if (curl_multi_select($mh) === -1) {
                    usleep(1); // @codeCoverageIgnore
                }

                do {
                    if (($minfo = curl_multi_info_read($mh, $remains)) === false) {
                        continue;
                    }

                    $handle = $minfo['handle'];
                    $handle_id = spl_object_id($handle);
                    [$key, $responser, $retry, $now, $retry_count] = $resultmap[$handle_id];

                    $response = curl_multi_getcontent($handle);
                    $info = curl_getinfo($handle);
                    $info['errno'] = $minfo['result'];
                    $info['retry'] = $retry_count;

                    if ($time = $retry($info, $response)) {
                        // 同じリソースを使い回しても大丈夫っぽい？（大丈夫なわけないと思うが…動いてはいる）
                        curl_multi_remove_handle($mh, $handle);
                        curl_multi_add_handle($mh, $handle);

                        // 他のリクエストの待機で既に指定秒数を超えている場合は待たない（分岐は本来不要だが現在以下だと警告が出るため）
                        if (microtime(true) < ($next = $now + $time)) {
                            time_sleep_until($next);
                        }

                        $resultmap[$handle_id][3] = microtime(true);
                        $resultmap[$handle_id][4] = $retry_count + 1;

                        $active++;
                        continue;
                    }

                    if ($info['errno'] !== CURLE_OK) {
                        if ($multi_options['throw']) {
                            throw new \UnexpectedValueException("'{$info['url']}' curl_errno({$info['errno']}).");
                        }
                        $set_response($key, null, [], $info);
                    }
                    else {
                        $set_response($key, ...$responser($response, $info));
                    }

                    curl_multi_remove_handle($mh, $handle);
                    curl_close($handle);
                } while ($remains);
            } while ($active && $mrc === CURLM_OK);
        }
        finally {
            curl_multi_close($mh);
        }

        return $responses;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\incidr') || (new \ReflectionFunction('ryunosuke\\ltsv\\incidr'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\incidr')) {
    /**
     * ipv4 の cidr チェック
     *
     * $ipaddr が $cidr のレンジ内なら true を返す。
     * $cidr は複数与えることができ、どれかに合致したら true を返す。
     *
     * ipv6 は今のところ未対応。
     *
     * Example:
     * ```php
     * // 範囲内なので true
     * that(incidr('192.168.1.1', '192.168.1.0/24'))->isTrue();
     * // 範囲外なので false
     * that(incidr('192.168.1.1', '192.168.2.0/24'))->isFalse();
     * // 1つでも範囲内なら true
     * that(incidr('192.168.1.1', ['192.168.1.0/24', '192.168.2.0/24']))->isTrue();
     * // 全部範囲外なら false
     * that(incidr('192.168.1.1', ['192.168.2.0/24', '192.168.3.0/24']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param string $ipaddr 調べられる IP/cidr アドレス
     * @param string|array $cidr 調べる cidr アドレス
     * @return bool $ipaddr が $cidr 内なら true
     */
    function incidr($ipaddr, $cidr)
    {
        [$ipaddr, , $ipmask] = cidr_parse($ipaddr);

        $iplong = ip2long($ipaddr);

        foreach (arrayize($cidr) as $cidr) {
            [$netaddress, , $netmask] = cidr_parse($cidr);

            if ($ipmask > $netmask) {
                continue;
            }

            if ((ip2long($netaddress) >> $netmask) == ($iplong >> $netmask)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ip2cidr') || (new \ReflectionFunction('ryunosuke\\ltsv\\ip2cidr'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ip2cidr')) {
    /**
     * IP アドレスを含みうる cidr を返す
     *
     * from, to の大小関係には言及しないので、from > to を与えると空配列を返す。
     *
     * ipv6 は今のところ未対応。
     *
     * Example:
     * ```php
     * that(ip2cidr('192.168.1.1', '192.168.2.64'))->isSame([
     *     '192.168.1.1/32',
     *     '192.168.1.2/31',
     *     '192.168.1.4/30',
     *     '192.168.1.8/29',
     *     '192.168.1.16/28',
     *     '192.168.1.32/27',
     *     '192.168.1.64/26',
     *     '192.168.1.128/25',
     *     '192.168.2.0/26',
     *     '192.168.2.64/32',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param string $fromipaddr ipaddrs
     * @param string $toipaddr ipaddrs
     * @return array cidr
     */
    function ip2cidr($fromipaddr, $toipaddr)
    {
        if (!filter_var($fromipaddr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            throw new \InvalidArgumentException("ipaddr '$fromipaddr' is invalid.");
        }
        if (!filter_var($toipaddr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            throw new \InvalidArgumentException("ipaddr '$toipaddr' is invalid.");
        }
        $minlong = ip2long($fromipaddr);
        $maxlong = ip2long($toipaddr);

        $bit_length = fn($number) => strlen(ltrim(sprintf('%032b', $number), '0'));

        $result = [];
        for ($long = $minlong; $long <= $maxlong; $long += 1 << $nbits) {
            $current_bits = $bit_length(~$long & ($long - 1));
            $target_bits = $bit_length($maxlong - $long + 1) - 1;
            $nbits = min($current_bits, $target_bits);

            $result[] = long2ip($long) . '/' . (32 - $nbits);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ip_info') || (new \ReflectionFunction('ryunosuke\\ltsv\\ip_info'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ip_info')) {
    /**
     * ipv4 の情報を返す
     *
     * 登録機関とか登録日、国等を返すが、実際のところ cc（国）くらいしか使わないはず。
     * データソースは各 RIR の delegated-afrinic-latest だが、かなりでかいのでデフォルトでは24時間のキャッシュが効く。
     * キャッシュ切れ/効かせないと最悪30秒くらいかかるので注意（バッチで叩くといいと思う）。
     *
     * $ipaddr に null を渡すと全 ip 情報を返す。
     * 上記の通り、情報としてかなりでかいので php で処理するのではなく、全取得して RDBMS に登録したり htaccess に書き込んだりするのに使える。
     *
     * 膨大な配列として保持するのでメモ化等は一切行わない。
     * opcache 前提であるので、CLI 等で呼ぶとかなり遅くなるので注意。
     *
     * ipv6 は今のところ未対応。
     *
     * Example:
     * ```php
     * // apnic 管轄
     * that(ip_info(gethostbyname('www.nic.ad.jp')))->is([
     *     'cidr'     => '192.41.192.0/24',
     *     'registry' => 'apnic',
     *     'cc'       => 'JP',
     *     'date'     => '19880620',
     * ]);
     * // arin 管轄
     * that(ip_info(gethostbyname('www.internic.net')))->is([
     *     'cidr'     => '192.0.32.0/20',
     *     'registry' => 'arin',
     *     'cc'       => 'US',
     *     'date'     => '20090629',
     * ]);
     * // こういう特殊なアドレスも一応対応している（全てではない）
     * that(ip_info('127.0.0.1'))['registry']->is('RFC1122');
     * that(ip_info('192.168.0.1'))['registry']->is('RFC1918');
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param string $ipaddr 調べる IP アドレス
     * @param array $options オプション配列
     * @return ?array IP の情報。ヒットしない場合は null
     */
    function ip_info($ipaddr, $options = [])
    {
        if ($ipaddr === null) {
            $ipv = 0;
        }
        elseif (filter_var($ipaddr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            $ipv = 4;
        }
        elseif (filter_var($ipaddr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            $ipv = 6; // @codeCoverageIgnore
        }

        if (!isset($ipv)) {
            throw new \InvalidArgumentException("\$ipaddr($ipaddr) is invalid");
        }
        if ($ipv === 6) {
            throw new \InvalidArgumentException("IPV6($ipaddr) is not supported");
        }

        $options += [
            'cachedir' => function_configure('storagedir') . '/' . rawurlencode(__FUNCTION__),
            'ttl'      => 60 * 60 * 24 + 120, // 120 は1日1回バッチで叩くことを前提としたバッファ
            'rir'      => [],
            'throw'    => true, // テスト用で原則 true（例外が飛ばないと情報が膨大過ぎるので失敗しても気付けない）
        ];
        $options['rir'] += [
            'afrinic' => 'https://ftp.afrinic.net/pub/stats/afrinic/delegated-afrinic-latest',
            'apnic'   => 'https://ftp.apnic.net/pub/stats/apnic/delegated-apnic-latest',
            'arin'    => 'https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest',
            'lacnic'  => 'https://ftp.lacnic.net/pub/stats/lacnic/delegated-lacnic-latest',
            'ripe'    => 'https://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest',
        ];

        $urls = [];
        $files = [
            'reserved' => (function () {
                $reserved = [];
                foreach ([
                    ['RFC1700', '0.0.0.0', 8],         // wildcard
                    ['RFC919', '255.255.255.255', 32], // broadcast
                    ['RFC5771', '224.0.0.0', 4],       // multicast
                    ['RFC1122', '127.0.0.0', 8],       // loopback
                    ['RFC3927', '169.254.0.0', 16],    // link-local
                    ['RFC1918', '10.0.0.0', 8],        // private
                    ['RFC1918', '172.16.0.0', 12],     // private
                    ['RFC1918', '192.168.0.0', 24],    // private
                ] as [$name, $ip, $mask]) {
                    $reserved[substr(sprintf("%032b", ip2long($ip)), 0, $mask)] = [
                        'cidr'     => "$ip/$mask",
                        'registry' => $name,
                        'cc'       => null,
                        'date'     => null,
                    ];
                }
                return $reserved;
            })(),
        ];
        foreach ($options['rir'] as $rir => $url) {
            $cachefile = "{$options['cachedir']}/$rir.php";
            if (!file_exists($cachefile) || (time() - filemtime($cachefile)) >= $options['ttl']) {
                $urls[$rir] = $url;
            }
            $files[$rir] = $cachefile;
        }

        http_requests($urls, [
            'cachedir' => $options['cachedir'],
            'callback' => function ($rir, $body, $header, $info) use ($files, $options) {
                if ($options['throw'] && ($body === null || $info['http_code'] >= 400)) {
                    throw new \UnexpectedValueException("request {$info['url']} failed. caused by {$info['http_code']}(error {$info['errno']})");
                }
                $tmpfile = tmpfile();
                fwrite($tmpfile, $body ?? '');
                rewind($tmpfile);

                $cidrs = [];
                while (($fields = fgetcsv($tmpfile, 0, "|")) !== false) {
                    if (($fields[2] ?? '') === 'ipv4' && in_array($fields[6] ?? '', ['assigned', 'allocated'], true)) {
                        $subnet = 32 - strlen(sprintf("%b", $fields[4] - 1));
                        $key = substr(sprintf("%032b", ip2long($fields[3])), 0, $subnet);
                        $cidrs[$key] = [
                            'cidr'     => "{$fields[3]}/$subnet",
                            'registry' => $fields[0],
                            'cc'       => $fields[1],
                            'date'     => $fields[5],
                        ];
                    }
                }

                $cachefile = $files[$rir];
                @mkdir(dirname($cachefile));
                file_put_contents($cachefile, "<?php\nreturn " . var_export($cidrs, true) . ";", LOCK_EX);
                //file_put_contents($cachefile, php_strip_whitespace($cachefile));
                opcache_invalidate($cachefile, true);
            },
        ]);

        // サイズがでかいので static 等にはしない（opcache に完全に任せる）
        $all = [];
        foreach ($files as $file) {
            if (is_array($file)) {
                $rir = $file;
            }
            elseif (file_exists($file)) {
                $rir = include $file;
            }
            else {
                // @codeCoverageIgnoreStart http が失敗したときなので基本的に到達しない（http が失敗したときは既に例外投げられている）
                $rir = [];
                if ($options['throw']) {
                    throw new \UnexpectedValueException("failed to load $file");
                }
                // @codeCoverageIgnoreEnd
            }

            if ($ipaddr === null) {
                $all += $rir;
                continue;
            }

            $binary = sprintf("%032b", ip2long($ipaddr));
            foreach (range(32, 1) as $n) {
                $key = substr($binary, 0, $n);
                if (isset($rir[$key])) {
                    return $rir[$key];
                }
            }
        }

        if ($ipaddr === null) {
            return $all;
        }

        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ping') || (new \ReflectionFunction('ryunosuke\\ltsv\\ping'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ping')) {
    /**
     * ネットワーク疎通を返す
     *
     * $port を指定すると TCP/UDP、省略（null）すると ICMP で繋ぐ。
     * が、 ICMP は root ユーザしか実行できないので ping コマンドにフォールバックする。
     * TCP/UDP の分岐はマニュアル通り tcp://, udp:// のようなスキームで行う（スキームがなければ tcp）。
     *
     * udp は結果が不安定なので信頼しないこと（タイムアウトも疎通 OK とみなされる。プロトコルの仕様上どうしようもない）。
     *
     * Example:
     * ```php
     * // 自身へ ICMP ping を打つ（正常終了なら float を返し、失敗なら false を返す）
     * that(ping('127.0.0.1'))->isFloat();
     * // 自身の tcp:1234 が開いているか（開いていれば float を返し、開いていなければ null を返す）
     * that(ping('tcp://127.0.0.1', 1234))->isNull();
     * that(ping('127.0.0.1', 1234))->isNull(); // tcp はスキームを省略できる
     * ```
     *
     * @package ryunosuke\Functions\Package\network
     *
     * @param string $host ホスト名（プロトコルも指定できる）
     * @param int|null $port ポート番号。指定しないと ICMP になる
     * @param int $timeout タイムアウト秒
     * @param string $errstr エラー文字列が格納される
     * @return ?float 成功したときは疎通時間。失敗したときは null
     */
    function ping($host, $port = null, $timeout = 1, &$errstr = '')
    {
        $errstr = '';

        $parts = parse_url($host);
        if (!isset($parts['scheme'])) {
            if ($port === null) {
                $parts['scheme'] = 'icmp';
            }
            else {
                $parts['scheme'] = 'tcp';
            }
        }
        $protocol = strtolower($parts['scheme']);
        $host = $parts['host'] ?? $parts['path'];

        // icmp で linux かつ非 root は SOCK_RAW が使えないので ping コマンドへフォールバック
        if ($protocol === 'icmp' && DIRECTORY_SEPARATOR === '/' && !is_readable('/root')) {
            // @codeCoverageIgnoreStart
            $stdout = null;
            process('ping', [
                '-c' => 1,
                '-W' => (int) $timeout,
                $host,
            ], null, $stdout, $errstr);
            // min/avg/max/mdev = 0.026/0.026/0.026/0.000
            if (preg_match('#min/avg/max/mdev.*?[0-9.]+/([0-9.]+)/[0-9.]+/[0-9.]+#', $stdout, $m)) {
                return $m[1] / 1000.0;
            }
            return null;
            // @codeCoverageIgnoreEnd
        }

        if ($protocol === 'icmp') {
            $port = 0;
            $socket = socket_create(AF_INET, SOCK_RAW, getprotobyname($protocol));
        }
        elseif ($protocol === 'tcp') {
            $socket = socket_create(AF_INET, SOCK_STREAM, getprotobyname($protocol));
        }
        elseif ($protocol === 'udp') {
            $socket = socket_create(AF_INET, SOCK_DGRAM, getprotobyname($protocol));
        }
        else {
            throw new \InvalidArgumentException("'$protocol' is not supported.");
        }

        $restore = set_error_exception_handler();
        $mtime = microtime(true);
        try {
            socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $timeout, 'usec' => 0]);
            socket_set_option($socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $timeout, 'usec' => 0]);
            if (!socket_connect($socket, $host, $port)) {
                throw new \RuntimeException(); // @codeCoverageIgnore
            }

            // icmp は ping メッセージを送信
            if ($protocol === 'icmp') {
                $message = "\x08\x00\x7d\x4b\x00\x00\x00\x00PingHost";
                socket_send($socket, $message, strlen($message), 0);
                socket_read($socket, 255);
            }
            // tcp は接続自体ができれば OK
            if ($protocol === 'tcp') {
                assert(true); // PhpStatementHasEmptyBodyInspection
            }
            // udp は何か送ってみてその挙動で判断（=> catch 節）
            if ($protocol === 'udp') {
                $message = ""; // noop
                socket_send($socket, $message, strlen($message), 0);
                socket_read($socket, 255);
            }
            return microtime(true) - $mtime;
        }
        catch (\Throwable) {
            $errno = socket_last_error($socket);
            // windows では到達できても socket_read がエラーを返すので errno で判断
            // 接続済みの呼び出し先が一定の時間を過ぎても正しく応答しなかったため、接続できませんでした。
            // または接続済みのホストが応答しなかったため、確立された接続は失敗しました。
            if (DIRECTORY_SEPARATOR === '\\' && $errno === 10060 && $protocol === 'udp') {
                return microtime(true) - $mtime;
            }
            $errstr = socket_strerror($errno);
            return null;
        }
        finally {
            $restore();
            socket_close($socket);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ob_capture') || (new \ReflectionFunction('ryunosuke\\ltsv\\ob_capture'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ob_capture')) {
    /**
     * ob_start ～ ob_get_clean のブロックでコールバックを実行する
     *
     * Example:
     * ```php
     * // コールバック内のテキストが得られる
     * that(ob_capture(fn() => print(123)))->isSame('123');
     * // こういう事もできる
     * that(ob_capture(function () {
     * ?>
     * bare string1
     * bare string2
     * <?php
     * }))->isSame("bare string1\nbare string2\n");
     * ```
     *
     * @package ryunosuke\Functions\Package\outcontrol
     *
     * @param callable $callback 実行するコールバック
     * @param mixed ...$variadic $callback に渡される引数（可変引数）
     * @return string オフスリーンバッファの文字列
     */
    function ob_capture($callback, ...$variadic)
    {
        ob_start();
        try {
            $callback(...$variadic);
            return ob_get_contents();
        }
        finally {
            ob_end_clean();
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ob_include') || (new \ReflectionFunction('ryunosuke\\ltsv\\ob_include'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ob_include')) {
    /**
     * 変数を extract して include する
     *
     * Example:
     * ```php
     * // このようなテンプレートファイルを用意すると
     * file_put_contents(sys_get_temp_dir() . '/template.php', '
     * This is plain text.
     * This is <?= $var ?>.
     * This is <?php echo strtoupper($var) ?>.
     * ');
     * // このようにレンダリングできる
     * that(ob_include(sys_get_temp_dir() . '/template.php', ['var' => 'hoge']))->isSame('
     * This is plain text.
     * This is hoge.
     * This is HOGE.
     * ');
     * ```
     *
     * @package ryunosuke\Functions\Package\outcontrol
     *
     * @param string $include_file include するファイル名
     * @param array $array extract される連想変数
     * @return string レンダリングされた文字列
     */
    function ob_include($include_file, $array = [])
    {
        /** @noinspection PhpMethodParametersCountMismatchInspection */
        return (static function () {
            ob_start();
            extract(func_get_arg(1));
            include func_get_arg(0);
            return ob_get_clean();
        })($include_file, $array);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ob_stdout') || (new \ReflectionFunction('ryunosuke\\ltsv\\ob_stdout'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ob_stdout')) {
    /**
     * 標準出力をコメント化して埋め込む ob_start
     *
     * 非常にニッチな関数で、想定用途は「README.md の中の php を実行して出力結果を埋め込みたい」のみ。
     * 例えば php のマニュアルみたいな「上記の結果は下記のようになります」は対応が分かりにくいのでコメントで埋め込みたいことがある。
     * いちいち結果を手で埋め込むのも馬鹿らしいのでこの関数を使えば自動で埋め込まれる。
     *
     * 言語仕様上の制約で echo/print は不可。
     * また、 ob_content 系で途中経過の出力は取れない（chunk_size を指定すると強制フラッシュされるらしいので制御できない）。
     * 返り値オブジェクトが toString を実装してるのでそれで得ること（ただし返り値は toString であること以外はいかなる前提も置いてはならない）。
     *
     * @package ryunosuke\Functions\Package\outcontrol
     *
     * @return object|string 制御用（デバッグ用）
     */
    function ob_stdout()
    {
        $status = new class {
            public const SPECIALS = [
                'include'      => true,
                'include_once' => true,
                'require'      => true,
                'require_once' => true,
            ];

            private array  $traces  = [];
            private array  $outputs = [];
            private string $buffer  = '';

            public function trace(string $buffer, int $phase): ?array
            {
                $traces = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3);
                $trace = $traces[2] ?? [];
                assert($this->traces[] = $trace + ['buffer' => $buffer, 'phase' => $phase]);

                // end を呼ばずに言語ランタイムのシャットダウン関数が呼ばれた場合
                if (!$trace) {
                    return null; // @codeCoverageIgnore
                }

                // php タグ外と echo/print はオペコードレベルで同じっぽいので検出不可（何か方法があるかもしれないので残しておく）
                if (isset(self::SPECIALS[$trace['function'] ?? ''])) {
                    return null;
                }

                return $trace;
            }

            public function append(?string $file, ?int $line, string $buffer): void
            {
                if (isset($file, $line)) {
                    $this->outputs[$file][$line] ??= '';
                    $this->outputs[$file][$line] .= $buffer;
                }

                $this->buffer .= $buffer;
            }

            public function outputs(): array
            {
                return $this->outputs;
            }

            public function __toString(): string
            {
                return $this->buffer;
            }
        };

        // ob_start を $chunk_size:1 で呼べば標準出力をキャプチャできる（実際には1バイト単位ではなく行単位っぽい）
        ob_start(function ($buffer, $phase) use ($status) {
            $trace = $status->trace($buffer, $phase);

            if (!($phase & PHP_OUTPUT_HANDLER_FINAL)) {
                $status->append($trace['file'] ?? null, $trace['line'] ?? null, $buffer);
                // chunk_size を指定してるので $buffer を返すと出力されてしまう
                // さらに、空文字を返すと get_contents 系で取得ができなくなる
                // 出力されてしまうよりは得られない方がマシと判断（最悪 $status で得ることはできるし）
                // php の仕様がおかしい気がするけど18年前からずっとこうらしい…
                return '';
            }

            foreach ($status->outputs() as $file => $lines) {
                $content = file_get_contents($file);
                $contents = preg_split('#\\R#u', $content);

                // 実行のたびに増えていくことになるので既存の出力コメントは捨てる
                foreach (\PhpToken::tokenize($content) as $token) {
                    if ($token->id === T_COMMENT && strpos($token->text, "/*= ") === 0) {
                        $comments = preg_split('#\\R#u', $token->text);
                        array_splice($contents, $token->line - 1, count($comments), array_pad([], count($comments), null));
                    }
                }

                // コメント化して埋め込む（行番号がだんだんズレていくので注意）
                ksort($lines);
                $addition = 0;
                foreach ($lines as $line => $buffer) {
                    $stmt = $contents[$line + $addition - 1];
                    $indent = str_repeat(' ', strspn($stmt, ' '));

                    $outlines = preg_split('#\\R#u', "/*= " . trim(ansi_strip($buffer)) . " */");
                    $outlines = array_map(fn($v) => "$indent$v", $outlines);

                    array_splice($contents, $line + $addition, 0, $outlines);
                    $addition += count($outlines);
                }

                // 異なっていたら書き換え
                $newcontent = implode("\n", array_filter($contents, fn($v) => $v !== null));
                if ($content !== $newcontent) {
                    file_put_contents($file, $newcontent);
                }
            }

            return $status;
        }, 1);
        return $status;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\glob2regex') || (new \ReflectionFunction('ryunosuke\\ltsv\\glob2regex'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\glob2regex')) {
    /**
     * glob 記法を正規表現に変換する
     *
     * 原則的に glob/fnmatch における「パスとしてのマッチ（ディレクトリ区切りの特別扱い）」という性質は失われ、あくまで文字列として扱う。
     * サポートしている記法は下記（ https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AD%E3%83%96 ）。
     * - `*`: 0文字以上の任意の文字列にマッチ
     * - `?`: 任意の1文字にマッチ
     * - `[...]`: 括弧内で列挙されたどれか1文字にマッチ
     * - `[!...]`: 括弧内で列挙されていない何かの1文字にマッチ
     * - `[0-9]`: 括弧内で指定された範囲内の1文字にマッチ
     * - `[!0-9]`: 括弧内で指定されていない範囲内の1文字にマッチ
     * - `{a,b,c}`: 「a」、「b」あるいは「c」のいずれかにマッチ（要 GLOB_BRACE）
     *
     * GLOB_RECURSIVE を与えた場合、挙動が下記のように変化する。
     * - `*`: "/" を含まない0文字以上の文字列にマッチ
     * - `**`: "/" を含む任意の0文字以上の文字列にマッチ
     *
     * いわゆる double star での再帰パターンのためだが、ディレクトリセパレータは "/" 固定とする（glob の "\" エスケープと絡んで非常にややこしいため）。
     *
     * Example:
     * ```php
     * $files = ['hoge.jpg', 'test1.jpg', 'test12.jpg', 'test123.png', 'testA.jpg', 'testAB.jpg', 'testABC.png', 'test.jpg', 'test.jpeg'];
     * // 先頭一致する jpg
     * that(preg_grep('#' . glob2regex('test*.jpg') . '#', $files))->isSame([
     *     1 => 'test1.jpg',
     *     2 => 'test12.jpg',
     *     4 => 'testA.jpg',
     *     5 => 'testAB.jpg',
     *     7 => 'test.jpg',
     * ]);
     * // 先頭一致した2文字の jpg
     * that(preg_grep('#' . glob2regex('test??.jpg') . '#', $files))->isSame([
     *     2 => 'test12.jpg',
     *     5 => 'testAB.jpg',
     * ]);
     * // 先頭一致した数値1桁の jpg
     * that(preg_grep('#' . glob2regex('test[0-9].jpg') . '#', $files))->isSame([
     *     1 => 'test1.jpg',
     * ]);
     * // 先頭一致した数値1桁でない jpg
     * that(preg_grep('#' . glob2regex('test[!0-9].jpg') . '#', $files))->isSame([
     *     4 => 'testA.jpg',
     * ]);
     * // jpeg, jpg のどちらにもマッチ（GLOB_BRACE 使用）
     * that(preg_grep('#' . glob2regex('test.jp{e,}g', GLOB_BRACE) . '#', $files))->isSame([
     *     7 => 'test.jpg',
     *     8 => 'test.jpeg',
     * ]);
     * // 深い階層を含めたすべての png にマッチ（GLOB_RECURSIVE 使用）
     * that(preg_grep('#^' . glob2regex('/**.png', GLOB_RECURSIVE) . '$#', [
     *     '/path/a.png',
     *     '/path/to/b.png',
     *     '/path/to/dir/c.png',
     * ]))->isSame([
     *     '/path/a.png',
     *     '/path/to/b.png',
     *     '/path/to/dir/c.png',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern glob パターン文字列
     * @param int $flags glob フラグ
     * @return string 正規表現パターン文字列
     */
    function glob2regex($pattern, $flags = 0)
    {
        $replacer = [
            // target glob character
            '*'  => '.*',
            '?'  => '.',
            '[!' => '[^',
            // quote regex character
            '.'  => '\\.',
            //'\\' => '\\\\',
            '+'  => '\\+',
            //'*' => '\\*',
            //'?' => '\\?',
            //'[' => '\\[',
            '^'  => '\\^',
            //']' => '\\]',
            '$'  => '\\$',
            '('  => '\\(',
            ')'  => '\\)',
            //'{' => '\\{',
            //'}' => '\\}',
            '='  => '\\=',
            '!'  => '\\!',
            '<'  => '\\<',
            '>'  => '\\>',
            '|'  => '\\|',
            ':'  => '\\:',
            //'-' => '\\-',
            '#'  => '\\#',
        ];

        if ($flags & GLOB_RECURSIVE) {
            $replacer['**'] = '.*';
            $replacer['*'] = '[^/]*';
        }

        if (!($flags & GLOB_BRACE)) {
            $replacer += [
                '{' => '\\{',
                '}' => '\\}',
            ];
        }

        $pattern = strtr_escaped($pattern, $replacer);

        if ($flags & GLOB_BRACE) {
            while (true) {
                $brace_s = strpos_escaped($pattern, '{');
                if ($brace_s === null) {
                    break;
                }
                $brace_e = strpos_escaped($pattern, '}', $brace_s);
                if ($brace_e === null) {
                    break;
                }
                $brace = substr($pattern, $brace_s + 1, $brace_e - $brace_s - 1);
                $brace = strtr_escaped($brace, [',' => '|']);
                $pattern = substr_replace($pattern, "($brace)", $brace_s, $brace_e - $brace_s + 1);
            }
        }

        return $pattern;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\preg_capture') || (new \ReflectionFunction('ryunosuke\\ltsv\\preg_capture'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\preg_capture')) {
    /**
     * キャプチャを主軸においた preg_match
     *
     * $pattern で $subject をマッチングして $default で埋めて返す。$default はフィルタも兼ねる。
     * 空文字マッチは「マッチしていない」とみなすので注意（$default が使用される）。
     *
     * キャプチャを主軸においているので「マッチしなかった」は検出不可能。
     * $default がそのまま返ってくる。
     *
     * Example:
     * ```php
     * $pattern = '#(\d{4})/(\d{1,2})(/(\d{1,2}))?#';
     * $default = [1 => '2000', 2 => '1', 4 => '1'];
     * // 完全にマッチするのでそれぞれ返ってくる
     * that(preg_capture($pattern, '2014/12/24', $default))->isSame([1 => '2014', 2 => '12', 4 => '24']);
     * // 最後の \d{1,2} はマッチしないのでデフォルト値が使われる
     * that(preg_capture($pattern, '2014/12', $default))->isSame([1 => '2014', 2 => '12', 4 => '1']);
     * // 一切マッチしないので全てデフォルト値が使われる
     * that(preg_capture($pattern, 'hoge', $default))->isSame([1 => '2000', 2 => '1', 4 => '1']);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param string $subject 対象文字列
     * @param array $default デフォルト値
     * @return array キャプチャした配列
     */
    function preg_capture($pattern, $subject, $default)
    {
        preg_match($pattern, $subject, $matches);

        foreach ($matches as $n => $match) {
            if (array_key_exists($n, $default) && strlen($match)) {
                $default[$n] = $match;
            }
        }

        return $default;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\preg_matches') || (new \ReflectionFunction('ryunosuke\\ltsv\\preg_matches'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\preg_matches')) {
    /**
     * 複数マッチに対応した preg_match
     *
     * 要するに preg_match_all とほぼ同義だが、下記の差異がある。
     *
     * - 正規表現フラグに "g" フラグが使用できる。 "g" を指定すると preg_match_all 相当の動作になる
     * - キャプチャは参照引数ではなく返り値で返す
     * - 「パターン全体マッチ」を表す 0 キーは返さない
     * - 上記2つの動作により「マッチしなかったら空配列を返す」という動作になる
     * - 名前付きキャプチャーに対応する数値キーは伏せられる
     * - 伏せられても数値キーは 0 ベースで通し連番となる
     *
     * Example:
     * ```php
     * $pattern = '#(\d{4})/(?<month>\d{1,2})(?:/(\d{1,2}))?#';
     * // 1(month)番目は名前付きキャプチャなので 1 キーとしては含まれず month というキーで返す（2 が詰められて 1 になる）
     * that(preg_matches($pattern, '2014/12/24'))->isSame([0 => '2014', 'month' => '12', 1 => '24']);
     * // 一切マッチしなければ空配列が返る
     * that(preg_matches($pattern, 'hoge'))->isSame([]);
     *
     * // g オプションを与えると preg_match_all 相当の動作になる（flags も使える）
     * $pattern = '#(\d{4})/(?<month>\d{1,2})(?:/(\d{1,2}))?#g';
     * that(preg_matches($pattern, '2013/11/23, 2014/12/24', PREG_SET_ORDER))->isSame([
     *     [0 => '2013', 'month' => '11', 1 => '23'],
     *     [0 => '2014', 'month' => '12', 1 => '24'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param string $subject 対象文字列
     * @param int $flags PREG 定数
     * @param int $offset 開始位置
     * @return array キャプチャした配列
     */
    function preg_matches($pattern, $subject, $flags = 0, $offset = 0)
    {
        // 0 と名前付きに対応する数値キーを伏せてその上で通し連番にするクロージャ
        $unset = function ($match) {
            $result = [];
            $keys = array_keys($match);
            for ($i = 1; $i < count($keys); $i++) {
                $key = $keys[$i];
                if (is_string($key)) {
                    $result[$key] = $match[$key];
                    $i++;
                }
                else {
                    $result[] = $match[$key];
                }
            }
            return $result;
        };

        $endpairs = [
            '(' => ')',
            '{' => '}',
            '[' => ']',
            '<' => '>',
        ];
        $endpos = strrpos($pattern, $endpairs[$pattern[0]] ?? $pattern[0]);
        $expression = substr($pattern, 0, $endpos);
        $modifiers = str_split(substr($pattern, $endpos));

        if (($g = array_search('g', $modifiers, true)) !== false) {
            unset($modifiers[$g]);

            preg_match_all($expression . implode('', $modifiers), $subject, $matches, $flags, $offset);
            if (($flags & PREG_SET_ORDER) === PREG_SET_ORDER) {
                return array_map($unset, $matches);
            }
            return $unset($matches);
        }
        else {
            $flags = ~PREG_PATTERN_ORDER & ~PREG_SET_ORDER & $flags;

            preg_match($pattern, $subject, $matches, $flags, $offset);
            return $unset($matches);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\preg_replaces') || (new \ReflectionFunction('ryunosuke\\ltsv\\preg_replaces'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\preg_replaces')) {
    /**
     * パターン番号を指定して preg_replace する
     *
     * パターン番号を指定してそれのみを置換する。
     * 名前付きキャプチャを使用している場合はキーに文字列も使える。
     * 値にクロージャを渡した場合はコールバックされて置換される。
     *
     * $replacements に単一文字列を渡した場合、 `[1 => $replacements]` と等しくなる（第1キャプチャを置換）。
     *
     * Example:
     * ```php
     * // a と z に囲まれた数字を XXX に置換する
     * that(preg_replaces('#a(\d+)z#', [1 => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // 名前付きキャプチャも指定できる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // クロージャを渡すと元文字列を引数としてコールバックされる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => fn($src) => $src * 2], 'a123z'))->isSame('a246z');
     * // 複合的なサンプル（a タグの href と target 属性を書き換える）
     * that(preg_replaces('#<a\s+href="(?<href>.*)"\s+target="(?<target>.*)">#', [
     *     'href'   => fn($href) => strtoupper($href),
     *     'target' => fn($target) => strtoupper($target),
     * ], '<a href="hoge" target="fuga">inner text</a>'))->isSame('<a href="HOGE" target="FUGA">inner text</a>');
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param array|string|callable $replacements 置換文字列
     * @param string $subject 対象文字列
     * @param int $limit 置換回数
     * @param null $count 置換回数格納変数
     * @return string 置換された文字列
     */
    function preg_replaces($pattern, $replacements, $subject, $limit = -1, &$count = null)
    {
        $offset = 0;
        $count = 0;
        if (!is_arrayable($replacements)) {
            $replacements = [1 => $replacements];
        }

        preg_match_all($pattern, $subject, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER);
        foreach ($matches as $match) {
            if ($limit-- === 0) {
                break;
            }
            $count++;

            foreach ($match as $index => $m) {
                if ($m[1] >= 0 && $index !== 0 && isset($replacements[$index])) {
                    $src = $m[0];
                    $dst = $replacements[$index];
                    if ($dst instanceof \Closure) {
                        $dst = $dst($src);
                    }

                    $srclen = strlen($src);
                    $dstlen = strlen($dst);

                    $subject = substr_replace($subject, $dst, $offset + $m[1], $srclen);
                    $offset += $dstlen - $srclen;
                }
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\preg_splice') || (new \ReflectionFunction('ryunosuke\\ltsv\\preg_splice'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\preg_splice')) {
    /**
     * キャプチャも行える preg_replace
     *
     * 「置換を行いつつ、キャプチャ文字列が欲しい」状況はまれによくあるはず。
     *
     * $replacement に callable を渡すと preg_replace_callback がコールされる。
     * callable とはいっても単純文字列 callble （"strtoupper" など）は callable とはみなされない。
     * 配列形式の callable や クロージャのみ preg_replace_callback になる。
     *
     * Example:
     * ```php
     * // 数字を除去しつつその除去された数字を得る
     * that(preg_splice('#\\d+#', '', 'abc123', $m))->isSame('abc');
     * that($m)->isSame(['123']);
     *
     * // callable だと preg_replace_callback が呼ばれる
     * that(preg_splice('#[a-z]+#', fn($m) => strtoupper($m[0]), 'abc123', $m))->isSame('ABC123');
     * that($m)->isSame(['abc']);
     *
     * // ただし、 文字列 callable は文字列として扱う
     * that(preg_splice('#[a-z]+#', 'strtoupper', 'abc123', $m))->isSame('strtoupper123');
     * that($m)->isSame(['abc']);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param string|callable $replacement 置換文字列
     * @param string $subject 対象文字列
     * @param array $matches キャプチャ配列が格納される
     * @param int $limit 置換回数
     * @return string 置換された文字列
     */
    function preg_splice($pattern, $replacement, $subject, &$matches = [], $limit = -1)
    {
        // for compatible. $limit => 1
        // preg_match なので $matches は最初しか引っかからないにも関わらず $limit:-1 だとすべて置換されてしまう

        if (preg_match($pattern, $subject, $matches)) {
            if (!is_string($replacement) && is_callable($replacement)) {
                $subject = preg_replace_callback($pattern, $replacement, $subject, $limit);
            }
            else {
                $subject = preg_replace($pattern, $replacement, $subject, $limit);
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\probability') || (new \ReflectionFunction('ryunosuke\\ltsv\\probability'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\probability')) {
    /**
     * 一定確率で true を返す
     *
     * 具体的には $probability / $divisor の確率で true を返す。
     * $divisor のデフォルトは 100 にしてあるので、 $probability だけ与えれば $probability パーセントで true を返すことになる。
     *
     * Example:
     * ```php
     * // 50% の確率で "hello" を出す
     * if (probability(50)) {
     *     echo "hello";
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param int $probability 分子
     * @param int $divisor 分母
     * @return bool true or false
     */
    function probability($probability, $divisor = 100)
    {
        $probability = (int) $probability;
        if ($probability < 0) {
            throw new \InvalidArgumentException('$probability must be positive number.');
        }
        $divisor = (int) $divisor;
        if ($divisor < 0) {
            throw new \InvalidArgumentException('$divisor must be positive number.');
        }
        // 不等号の向きや=の有無が怪しかったのでメモ
        // 1. $divisor に 100 が与えられたとすると、取り得る範囲は 0 ～ 99（100個）
        // 2. $probability が 1 だとするとこの式を満たす数は 0 の1個のみ
        // 3. 100 個中1個なので 1%
        return $probability > mt_rand(0, $divisor - 1);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\probability_array') || (new \ReflectionFunction('ryunosuke\\ltsv\\probability_array'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\probability_array')) {
    /**
     * 指定確率で配列のキーを返す
     *
     * 確率の合計が 100% を超えている場合は例外を投げる。
     * 100% に満たない場合は残り確率で null を返す。
     *
     * 分母の 100% は $divisor 引数で指定可能（1000 を指定すればパーミルになる）。
     * null を与えると確率の合計値が設定される（いわゆる重み付け乱数になる）。
     *
     * Example:
     * ```php
     * srand(123);
     * // a:10%, b:20%, c:30%, d:40% の確率で返す
     * that(probability_array([
     *     'a' => 10,
     *     'b' => 20,
     *     'c' => 30,
     *     'd' => 40,
     * ]))->isSame('b');
     *
     * // a:16.6%, b:32.3%, c:50% の確率で返す（いわゆる重み付け）
     * that(probability_array([
     *     'a' => 1,
     *     'b' => 2,
     *     'c' => 3,
     * ], null))->isSame('c');
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param array $array 配列
     * @param ?int $divisor 分母
     * @return mixed $array のどれか1つ
     */
    function probability_array($array, $divisor = 100)
    {
        $array = arrayval($array, false);
        if (empty($array)) {
            throw new \InvalidArgumentException("array is empty");
        }

        assert(array_reduce($array, fn($carry, $item) => $carry && ctype_digit("$item"), true));

        $weights = array_sum($array);
        $divisor ??= $weights;

        if ($weights > $divisor) {
            throw new \InvalidArgumentException("The sum of probabilities exceeds $divisor");
        }
        if ($divisor <= 0) {
            throw new \InvalidArgumentException("divisor <= 0");
        }

        $probability = mt_rand(1, $divisor);

        foreach ($array as $key => $per) {
            if (($divisor -= $per) < $probability) {
                return $key;
            }
        }

        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\random_at') || (new \ReflectionFunction('ryunosuke\\ltsv\\random_at'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\random_at')) {
    /**
     * 引数をランダムで返す
     *
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * // 1 ～ 6 のどれかを返す
     * that(random_at(1, 2, 3, 4, 5, 6))->isAny([1, 2, 3, 4, 5, 6]);
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param mixed ...$args 候補
     * @return mixed 引数のうちどれか
     */
    function random_at(...$args)
    {
        return $args[mt_rand(0, count($args) - 1)];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\random_float') || (new \ReflectionFunction('ryunosuke\\ltsv\\random_float'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\random_float')) {
    /**
     * 疑似乱数小数を返す
     *
     * 疑似的に生成しているので偏りはあることに注意。
     * https://www.php.net/manual/random-randomizer.getfloat.php
     * https://www.php.net/manual/random-randomizer.nextfloat.php
     *
     * Example:
     * ```php
     * // [-M_PI~+M_PI] の区間でランダムに返す
     * that(random_float(-M_PI, +M_PI))->isBetween(-M_PI, +M_PI);
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param float $min 最小値
     * @param float $max 最大値
     * @return float min～maxの乱数
     */
    function random_float($min, $max)
    {
        if ($min > $max) {
            throw new \Error('Minimum value must be less than or equal to the maximum value');
        }
        //return ($min + ($max - $min) * lcg_value());
        return $min + ($max - $min) * rand(0, getrandmax()) / getrandmax();
    }
}

assert(!function_exists('ryunosuke\\ltsv\\random_normal') || (new \ReflectionFunction('ryunosuke\\ltsv\\random_normal'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\random_normal')) {
    /**
     * 正規乱数（正規分布に従う乱数）を返す
     *
     * ※ ボックス＝ミュラー法
     *
     * Example:
     * ```php
     * mt_srand(4); // テストがコケるので種固定
     *
     * // 平均 100, 標準偏差 10 の正規乱数を得る
     * that(random_normal(100, 10))->isSame(101.16879645296162);
     * that(random_normal(100, 10))->isSame(96.49615862542069);
     * that(random_normal(100, 10))->isSame(87.74557282679618);
     * that(random_normal(100, 10))->isSame(117.93697951557125);
     * that(random_normal(100, 10))->isSame(99.1917453115627);
     * that(random_normal(100, 10))->isSame(96.74688207698713);
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param float $average 平均
     * @param float $std_deviation 標準偏差
     * @return float 正規乱数
     */
    function random_normal($average = 0.0, $std_deviation = 1.0)
    {
        static $z2, $rand_max, $generate = true;
        $rand_max ??= mt_getrandmax();
        $generate = !$generate;

        if ($generate) {
            return $z2 * $std_deviation + $average;
        }

        $u1 = mt_rand(1, $rand_max) / $rand_max;
        $u2 = mt_rand(0, $rand_max) / $rand_max;
        $v1 = sqrt(-2 * log($u1));
        $v2 = 2 * M_PI * $u2;
        $z1 = $v1 * cos($v2);
        $z2 = $v1 * sin($v2);

        return $z1 * $std_deviation + $average;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\random_range') || (new \ReflectionFunction('ryunosuke\\ltsv\\random_range'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\random_range')) {
    /**
     * 指定範囲内からランダムで返す
     *
     * $count を null にすると個数すらもランダムで返す。
     * 結果は範囲内では重複しない。
     *
     * 範囲が負数の場合は例外を投げるが、$count の 0 や範囲超過数は許容される（array_rand とは違う）。
     *
     * Example:
     * ```php
     * mt_srand(5); // テストがコケるので種固定
     *
     * // [10~20] の区間でランダムに3件返す
     * that(random_range(10, 20, 3))->is([19, 20, 10]);
     * // 0 を渡しても OK（単に空配列を返す）
     * that(random_range(10, 20, 0))->is([]);
     * // 範囲超過数を渡しても OK（最大個数で返す）
     * that(count(random_range(10, 20, 999)))->is(11);
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param int $min 最小値
     * @param int $max 最大値
     * @param ?int $count 返す個数
     * @return array min～maxの数値の配列
     */
    function random_range($min, $max, $count = null)
    {
        $range = $max - $min;
        if ($range < 0) {
            throw new \InvalidArgumentException("invalid range ($min > $max)");
        }

        if ($count === null) {
            $count = rand(0, $range + 1);
        }

        if ($count > ($range >> 1)) {
            $array = range($min, $max);
            shuffle($array);
            return array_slice($array, 0, $count);
        }

        $result = [];
        while (count($result) < $count) {
            $result[rand($min, $max)] = null;
        }
        return array_keys($result);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\random_string') || (new \ReflectionFunction('ryunosuke\\ltsv\\random_string'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\random_string')) {
    /**
     * 安全な乱数文字列を生成する
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param int $length 生成文字列長
     * @param string $charlist 使用する文字セット
     * @return string 乱数文字列
     */
    function random_string($length = 8, $charlist = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    {
        if ($length <= 0) {
            throw new \InvalidArgumentException('$length must be positive number.');
        }

        $charlength = strlen($charlist);
        if ($charlength === 0) {
            throw new \InvalidArgumentException('charlist is empty.');
        }

        $bytes = random_bytes($length);

        // 1文字1バイト使う。文字種によっては出現率に差が出るがう～ん
        $string = '';
        foreach (str_split($bytes) as $byte) {
            $string .= $charlist[ord($byte) % $charlength];
        }
        return $string;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\unique_string') || (new \ReflectionFunction('ryunosuke\\ltsv\\unique_string'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\unique_string')) {
    /**
     * 文字列に含まれない文字列を生成する
     *
     * 例えば http のマルチパートバウンダリのような、「競合しない文字列」を生成する。
     * 実装は愚直に文字列を調べて存在しなければそれを返すようになっている。
     * 一応初期値や文字セットは指定可能。
     *
     * $initial に int を与えると初期値としてその文字数分 $charlist から確保する。
     * 例えば生成後の変更が前提で、ある程度の長さを担保したいときに指定すれば最低でもその長さ以上は保証される。
     * $initial に string を与えるとそれがそのまま初期値として使用される。
     * 例えば「ほぼ存在しない文字列」が予測できるのであればそれを指定すれば無駄な処理が省ける。
     *
     * Example:
     * ```php
     * // 単純に呼ぶと生成1,2文字程度の文字列になる
     * that(unique_string('hello, world'))->stringLengthEqualsAny([1, 2]);
     * // 数値を含んでいないので候補文字に数値のみを指定すれば1文字で「存在しない文字列」となる
     * that(unique_string('hello, world', null, range(0, 9)))->stringLengthEquals(1);
     * // int を渡すと最低でもそれ以上は保証される
     * that(unique_string('hello, world', 5))->stringLengthEqualsAny([5, 6]);
     * // string を渡すとそれが初期値となる
     * that(unique_string('hello, world', 'prefix-'))->stringStartsWith('prefix');
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param string $source 元文字列
     * @param string|int $initial 初期文字列あるいは文字数
     * @param string|array $charlist 使用する文字セット
     * @return string 一意な文字列
     */
    function unique_string($source, $initial = null, $charlist = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    {
        assert(is_stringable($initial) || is_int($initial) || is_null($initial));

        if (is_stringable($charlist)) {
            $charlist = preg_split('//', $charlist, -1, PREG_SPLIT_NO_EMPTY);
        }

        $charlength = count($charlist);
        if ($charlength === 0) {
            throw new \InvalidArgumentException('charlist is empty.');
        }

        $result = '';
        if (is_int($initial)) {
            shuffle($charlist);
            $result = implode('', array_slice($charlist, 0, $initial));
        }
        elseif (is_null($initial)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }
        else {
            $result = $initial;
        }

        while ((($p = strpos($source, $result, $p ?? 0)) !== false)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\callable_code') || (new \ReflectionFunction('ryunosuke\\ltsv\\callable_code'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\callable_code')) {
    /**
     * callable のコードブロックを返す
     *
     * 返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。
     *
     * Example:
     * ```php
     * list($meta, $body) = callable_code(function (...$args) {return true;});
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     *
     * // ReflectionFunctionAbstract を渡しても動作する
     * list($meta, $body) = callable_code(new \ReflectionFunction(function (...$args) {return true;}));
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable|\ReflectionFunctionAbstract $callable コードを取得する callable
     * @param bool $return_token true にすると生のトークン配列で返す
     * @return array ['定義部分', '{処理コード}']
     */
    function callable_code($callable, bool $return_token = false)
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $contents = file($ref->getFileName());
        $start = $ref->getStartLine();
        $end = $ref->getEndLine();
        $codeblock = implode('', array_slice($contents, $start - 1, $end - $start + 1));

        $meta = php_parse("<?php $codeblock", [
            'begin' => [T_FN, T_FUNCTION],
            'end'   => ['{', T_DOUBLE_ARROW],
        ]);
        $end = array_pop($meta);

        if ($end->id === T_DOUBLE_ARROW) {
            $body = php_parse("<?php $codeblock", [
                'begin'  => T_DOUBLE_ARROW,
                'end'    => [';', ',', ')'],
                'offset' => last_key($meta),
                'greedy' => true,
            ]);
            $body = array_slice($body, 1, -1);
        }
        else {
            $body = php_parse("<?php $codeblock", [
                'begin'  => '{',
                'end'    => '}',
                'offset' => last_key($meta),
            ]);
        }

        if ($return_token) {
            return [$meta, $body];
        }

        return [trim(implode('', array_column($meta, 'text'))), trim(implode('', array_column($body, 'text')))];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\function_doccomments') || (new \ReflectionFunction('ryunosuke\\ltsv\\function_doccomments'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\function_doccomments')) {
    /**
     * $callable の本体・引数・返り値の DocComment を返す
     *
     * 下記のような配列を返す（仕様上 Example が書けない）。
     *
     * ```
     * [
     *     "" => "本体の DocComment",
     *     0  => "引数1の DocComment",
     *     1  => "引数2の DocComment",
     *     // ...他の引数
     *     -1 => "返り値の DocComment",
     * ];
     * ```
     *
     * それぞれ存在しない場合はキー自体が抜け落ちる（null で入ったりはしない）。
     * 非常に雑に実装しているので、配列や new(8.1以降)の引数に反応することがある。
     *
     * 本体の DocComment は ReflectionFunctionAbstract::getDocComment と同等である。
     * 引数の DocComment は必ず型宣言の直前（ない場合は引数名の直前）に記述しなければならない。
     * 返り値の DocComment は必ず型宣言の直前（ない場合は{の直前）に記述しなければならない。
     *
     * @package ryunosuke\Functions\Package\reflection
     */
    function function_doccomments(
        /** 対象 callable */
        \ReflectionFunctionAbstract|callable $callable,
    ): /** 本体・引数・返り値の DocComment 配列 */ array
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $parameters = array_each($ref->getParameters(), function (&$carry, $v) {
            $carry[$v->getName()] = $v;
        }, []);

        $result = [];
        if ($ref->getDocComment() !== false) {
            $result[''] = $ref->getDocComment();
        }

        $doccomment = null;
        $tokens = callable_code($ref, true)[0];
        foreach ($tokens as $token) {
            if ($token->is(T_DOC_COMMENT)) {
                $doccomment = $token;
            }

            if ($token->is(T_VARIABLE)) {
                $varname = substr($token->text, 1);
                if ($doccomment && isset($parameters[$varname])) {
                    $result[$parameters[$varname]->getPosition()] = $doccomment->text;
                }
                $doccomment = null;
            }
            if ($token->is([T_NEW])) {
                $doccomment = null; // @codeCoverageIgnore for php8.1
            }
        }

        if ($doccomment) {
            $result[-1] = $doccomment->text;
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\function_export_false2null') || (new \ReflectionFunction('ryunosuke\\ltsv\\function_export_false2null'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\function_export_false2null')) {
    /**
     * 存在する関数の内、false 返しを null 返しに再定義したファイルを返す
     *
     * 標準関数は歴史的な事情で false を返すものが多い（strpos, strtotime 等）。
     * ただ大抵の場合は null の方が好ましいことが多い（int|false より ?int の方が分かりやすいし ?? を駆使できる）。
     * （`strpos(',', 'hello, world') ?? -1` みたいなことができない）。
     *
     * $false_only:false にすると存在する全関数も返す。false 返しでない関数は単純な委譲で余計なことはしない。
     * これは「strpos は nullable だから F\\strpos で、他はグローバル」という使い分けの利便性のためだが、出力数が膨大になるので留意。
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param string $namespace 吐き出す名前空間
     * @param bool $false_only false 返しのみか。false を与えると全関数を返す
     * @return string 吐き出された関数定義を含むファイル内容
     */
    function function_export_false2null(string $namespace, bool $false_only = true): string
    {
        $all = [];
        foreach (get_defined_functions(true) as $functions) {
            foreach ($functions as $funcname) {
                $reffunc = new \ReflectionFunction($funcname);
                $extension = (string) $reffunc->getExtensionName() ?: 'user';
                $all[$extension][$funcname] = $reffunc;
            }
        }

        $formatterOff = "@formatter:" . "off"; // 文字列的に分離しないと外側のコードまで off になる
        $contents = <<<PHP
        <?php
        /**
         * @noinspection PhpDeprecationInspection
         * @noinspection PhpUndefinedFunctionInspection
         * @noinspection PhpUndefinedConstantInspection
         */
        # Don't touch this code. This is auto generated.
        namespace $namespace;
        
        // $formatterOff
        
        PHP;
        foreach ($all as $extension => $functions) {
            $contents .= "\n# $extension\n\n";

            foreach ($functions as $funcname => $reffunc) {
                // 拡張関数で名前空間を持つ者がいる（e.g. pcov）
                if (str_contains($funcname, '\\')) {
                    continue;
                }
                // assert を名前空間内に定義することはできない
                if ($funcname === 'assert') {
                    continue;
                }
                // 標準関数に参照返しは存在しないはず（したとしても1文で返すのが難しいので対応しない）
                if ($reffunc->returnsReference()) {
                    continue; // @codeCoverageIgnore
                }
                $return = reflect_type_resolve($reffunc->getReturnType() ?: 'mixed');
                $returns = explode('|', $return);

                $param = implode(', ', array_maps($reffunc->getParameters(), fn($p) => ($p->isVariadic() ? '...' : '') . '$' . $p->getName()));
                $args = implode(', ', function_parameter($reffunc));

                if (!in_array('null', $returns) && in_array('false', $returns)) {
                    $return = str_replace('false', 'null', $return);
                    $body = "return (\$result = \\{$funcname}($param)) === false ? null : \$result;";
                }
                else {
                    if ($false_only) {
                        continue;
                    }
                    if (in_array('void', $returns)) {
                        $body = "\\{$funcname}($param);";
                    }
                    else {
                        $body = "return \\{$funcname}($param);";
                    }
                }

                $contents .= "function $funcname({$args}):$return {{$body}}\n";
            }
        }

        return $contents;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\function_parameter') || (new \ReflectionFunction('ryunosuke\\ltsv\\function_parameter'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\function_parameter')) {
    /**
     * 関数/メソッドの引数定義を取得する
     *
     * ほぼ内部向けで外から呼ぶことはあまり想定していない。
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param \ReflectionFunctionAbstract|callable $eitherReffuncOrCallable 関数/メソッドリフレクション or callable
     * @return array [引数名 => 引数宣言] の配列
     */
    function function_parameter($eitherReffuncOrCallable)
    {
        $reffunc = $eitherReffuncOrCallable instanceof \ReflectionFunctionAbstract
            ? $eitherReffuncOrCallable
            : reflect_callable($eitherReffuncOrCallable);

        $result = [];
        foreach ($reffunc->getParameters() as $parameter) {
            $declare = '';

            if ($parameter->hasType()) {
                $declare .= reflect_type_resolve($parameter->getType()) . ' ';
            }

            if ($parameter->isPassedByReference()) {
                $declare .= '&';
            }

            if ($parameter->isVariadic()) {
                $declare .= '...';
            }

            $declare .= '$' . $parameter->getName();

            if ($parameter->isOptional()) {
                $defval = null;

                if ($parameter->isDefaultValueAvailable()) {
                    // 修飾なしでデフォルト定数が使われているとその名前空間で解決してしまうので場合分けが必要
                    if ($parameter->isDefaultValueConstant() && strpos($parameter->getDefaultValueConstantName(), '\\') === false) {
                        // 存在チェック＋$dummy でグローバル定数を回避しているが、いっそのこと一律 \\ を付与してしまっても良いような気がする
                        if (const_exists(...(explode('::', $parameter->getDefaultValueConstantName()) + [1 => '$dummy']))) {
                            $defval = '\\' . $parameter->getDefaultValueConstantName();
                        }
                        else {
                            $defval = $parameter->getDefaultValueConstantName();
                        }
                    }
                    else {
                        $default = $parameter->getDefaultValue();
                        $defval = var_export2($default, true);
                    }
                }
                // isOptional だが isDefaultValueAvailable でないし isVariadic でもない（稀にある（stream_filter_append で確認））
                elseif (!$parameter->isVariadic()) {
                    // Type に応じたデフォルト値が得られればベストだがそこまでする必要もない
                    // 少なくとも 8.0 時点では = null してしまえば型エラーも起きない（8.4 で非推奨になってるけど）
                    $defval = "null";
                }

                if (isset($defval)) {
                    $declare .= ' = ' . $defval;
                }
            }

            $name = ($parameter->isPassedByReference() ? '&' : '') . '$' . $parameter->getName();
            $result[$name] = $declare;
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\parameter_default') || (new \ReflectionFunction('ryunosuke\\ltsv\\parameter_default'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\parameter_default')) {
    /**
     * callable のデフォルト引数を返す
     *
     * オプションで指定もできる。
     * 負数を指定した場合「最後の引数から数えた位置」になる。
     *
     * 内部関数には使用できない（リフレクションが対応していない）。
     *
     * Example:
     * ```php
     * $f = function ($a, $b = 'b') {};
     * // デフォルト引数である b を返す
     * that(parameter_default($f))->isSame([1 => 'b']);
     * // 引数で与えるとそれが優先される
     * that(parameter_default($f, ['A', 'B']))->isSame(['A', 'B']);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param iterable|array $arguments デフォルト引数
     * @return array デフォルト引数
     */
    function parameter_default(callable $callable, $arguments = [])
    {
        static $cache = [];

        // $call_name でキャッシュ。しかしクロージャはすべて「Closure::__invoke」になるのでキャッシュできない
        is_callable($callable, true, $call_name);
        if (!isset($cache[$call_name]) || $callable instanceof \Closure) {
            /** @var \ReflectionFunctionAbstract $refunc */
            $refunc = reflect_callable($callable);
            $cache[$call_name] = [
                'length'  => $refunc->getNumberOfParameters(),
                'default' => [],
            ];
            foreach ($refunc->getParameters() as $n => $param) {
                if ($param->isDefaultValueAvailable()) {
                    $cache[$call_name]['default'][$n] = $param->getDefaultValue();
                }
            }
        }

        // 指定されていないならそのまま返せば良い（高速化）
        if (is_array($arguments) && !$arguments) {
            return $cache[$call_name]['default'];
        }

        $args2 = [];
        foreach ($arguments as $n => $arg) {
            if ($n < 0) {
                $n += $cache[$call_name]['length'];
            }
            $args2[$n] = $arg;
        }

        return array_merge2($cache[$call_name]['default'], $args2);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\parameter_length') || (new \ReflectionFunction('ryunosuke\\ltsv\\parameter_length'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\parameter_length')) {
    /**
     * callable の引数の数を返す
     *
     * クロージャはキャッシュされない。毎回リフレクションを生成し、引数の数を調べてそれを返す。
     * （クロージャには一意性がないので key-value なキャッシュが適用できない）。
     * ので、ループ内で使ったりすると目に見えてパフォーマンスが低下するので注意。
     *
     * Example:
     * ```php
     * // trim の引数は2つ
     * that(parameter_length('trim'))->isSame(2);
     * // trim の必須引数は1つ
     * that(parameter_length('trim', true))->isSame(1);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param bool $require_only true を渡すと必須パラメータの数を返す
     * @param bool $thought_variadic 可変引数を考慮するか。 true を渡すと可変引数の場合に無限長を返す
     * @return int 引数の数
     */
    function parameter_length($callable, $require_only = false, $thought_variadic = false)
    {
        // クロージャの $call_name には一意性がないのでキャッシュできない（spl_object_hash でもいいが、かなり重複するので完全ではない）
        if ($callable instanceof \Closure) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            if ($thought_variadic && $ref->isVariadic()) {
                return INF;
            }
            elseif ($require_only) {
                return $ref->getNumberOfRequiredParameters();
            }
            else {
                return $ref->getNumberOfParameters();
            }
        }

        // $call_name 取得
        is_callable($callable, false, $call_name);

        $cache = cache($call_name, function () use ($callable) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            return [
                '00' => $ref->getNumberOfParameters(),
                '01' => $ref->isVariadic() ? INF : $ref->getNumberOfParameters(),
                '10' => $ref->getNumberOfRequiredParameters(),
                '11' => $ref->isVariadic() ? INF : $ref->getNumberOfRequiredParameters(),
            ];
        }, __FUNCTION__);
        return $cache[(int) $require_only . (int) $thought_variadic];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\parameter_wiring') || (new \ReflectionFunction('ryunosuke\\ltsv\\parameter_wiring'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\parameter_wiring')) {
    /**
     * callable の引数の型情報に基づいてワイヤリングした引数配列を返す
     *
     * ワイヤリングは下記のルールに基づいて行われる。
     *
     * - 引数の型とキーが完全一致
     * - 引数の型とキーが継承・実装関係
     *   - 複数一致した場合は解決されない
     * - 引数名とキーが完全一致
     *   - 可変引数は追加
     * - 引数のデフォルト値
     * - 得られた値がクロージャの場合は再帰的に解決
     *   - $this は $dependency になるが FromCallable 経由の場合は元のまま
     *
     * Example:
     * ```php
     * $closure = function (\ArrayObject $ao, \Throwable $t, $array, $none, $default1, $default2 = 'default2', ...$misc) { return get_defined_vars(); };
     * $params = parameter_wiring($closure, [
     *     \ArrayObject::class      => $ao = new \ArrayObject([1, 2, 3]),
     *     \RuntimeException::class => $t = new \RuntimeException('hoge'),
     *     '$array'                 => fn (\ArrayObject $ao) => (array) $ao,
     *     4                        => 'default1',
     *     '$misc'                  => ['x', 'y', 'z'],
     * ]);
     * that($params)->isSame([
     *     0 => $ao,        // 0番目はクラス名が完全一致
     *     1 => $t,         // 1番目はインターフェース実装
     *     2 => [1, 2, 3],  // 2番目はクロージャをコール
     *                      // 3番目は解決されない
     *     4 => 'default1', // 4番目は順番指定のデフォルト値
     *     5 => 'default2', // 5番目は引数定義のデフォルト値
     *     6 => 'x',        // 可変引数なのでフラットに展開
     *     7 => 'y',
     *     8 => 'z',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param array|\ArrayAccess $dependency 引数候補配列
     * @return array 引数配列
     */
    function parameter_wiring($callable, $dependency)
    {
        /** @var \ReflectionFunctionAbstract $ref */
        $ref = reflect_callable($callable);
        $result = [];

        foreach ($ref->getParameters() as $n => $parameter) {
            if (isset($dependency[$n])) {
                $result[$n] = $dependency[$n];
            }
            elseif (isset($dependency[$pname = '$' . $parameter->getName()])) {
                if ($parameter->isVariadic()) {
                    foreach (array_values(arrayize($dependency[$pname])) as $i => $v) {
                        $result[$n + $i] = $v;
                    }
                }
                else {
                    $result[$n] = $dependency[$pname];
                }
            }
            elseif (($typename = strval($parameter->getType()))) {
                if (isset($dependency[$typename])) {
                    $result[$n] = $dependency[$typename];
                }
                else {
                    foreach ($dependency as $key => $value) {
                        if (is_subclass_of(ltrim($key, '\\'), $typename, true)) {
                            if (array_key_exists($n, $result)) {
                                unset($result[$n]);
                                break;
                            }
                            $result[$n] = $value;
                        }
                    }
                }
            }
            elseif ($parameter->isDefaultValueAvailable()) {
                $result[$n] = $parameter->getDefaultValue();
            }
        }

        // $this bind するのでオブジェクト化しておく
        if (!is_object($dependency)) {
            $dependency = new \ArrayObject($dependency);
        }

        // recurse for closure
        return array_map(function ($arg) use ($dependency) {
            if ($arg instanceof \Closure) {
                if ((new \ReflectionFunction($arg))->getShortName() === '{closure}') {
                    $arg = $arg->bindTo($dependency);
                }
                return $arg(...parameter_wiring($arg, $dependency));
            }
            return $arg;
        }, $result);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\reflect_callable') || (new \ReflectionFunction('ryunosuke\\ltsv\\reflect_callable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\reflect_callable')) {
    /**
     * callable から ReflectionFunctionAbstract を生成する
     *
     * 実際には ReflectionFunctionAbstract を下記の独自拡張した Reflection クラスを返す（メソッドのオーバーライド等はしていないので完全互換）。
     * - __invoke: 元となったオブジェクトを $this として invoke する（関数・クロージャは invoke と同義）
     * - call: 実行 $this を指定して invoke する（クロージャ・メソッドのみ）
     *   - 上記二つは __call/__callStatic のメソッドも呼び出せる
     * - getDeclaration: 宣言部のコードを返す
     * - getCode: 定義部のコードを返す
     * - isStatic: $this バインド可能かを返す（クロージャのみ）
     * - getUsedVariables: use している変数配列を返す（クロージャのみ）
     *
     * Example:
     * ```php
     * that(reflect_callable('sprintf'))->isInstanceOf(\ReflectionFunction::class);
     * that(reflect_callable('\Closure::bind'))->isInstanceOf(\ReflectionMethod::class);
     *
     * $x = 1;
     * $closure = function ($a, $b) use (&$x) { return $a + $b; };
     * $reflection = reflect_callable($closure);
     * // 単純実行
     * that($reflection(1, 2))->is(3);
     * // 無名クラスを $this として実行
     * that($reflection->call(new class(){}, 1, 2))->is(3);
     * // 宣言部を返す
     * that($reflection->getDeclaration())->is('function ($a, $b) use (&$x)');
     * // 定義部を返す
     * that($reflection->getCode())->is('{ return $a + $b; }');
     * // static か返す
     * that($reflection->isStatic())->is(false);
     * // use 変数を返す
     * that($reflection->getUsedVariables())->is(['x' => 1]);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @return \ReflectCallable|\ReflectionFunction|\ReflectionMethod リフレクションインスタンス
     */
    function reflect_callable($callable)
    {
        // callable チェック兼 $call_name 取得
        if (!is_callable($callable, true, $call_name)) {
            throw new \InvalidArgumentException("'$call_name' is not callable");
        }

        if (is_string($call_name) && strpos($call_name, '::') === false) {
            return new class($callable) extends \ReflectionFunction {
                private $definition;

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }
            };
        }
        elseif ($callable instanceof \Closure) {
            return new class($callable) extends \ReflectionFunction {
                private $callable;
                private $definition;

                public function __construct($function)
                {
                    parent::__construct($function);

                    $this->callable = $function;
                }

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    return ($this->callable)->call($newThis ?? $this->getClosureThis(), ...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isStatic(): bool
                {
                    return !is_bindable_closure($this->callable);
                }

                public function getUsedVariables(): array
                {
                    $uses = object_properties($this->callable);
                    unset($uses['this']);
                    return $uses;
                }
            };
        }
        else {
            [$class, $method] = explode('::', $call_name, 2);
            // for タイプ 5: 相対指定による静的クラスメソッドのコール (PHP 5.3.0 以降)
            if (strpos($method, 'parent::') === 0) {
                [, $method] = explode('::', $method);
                $class = get_parent_class($class);
            }

            $called_name = '';
            if (!method_exists(is_array($callable) && is_object($callable[0]) ? $callable[0] : $class, $method)) {
                $called_name = $method;
                $method = is_array($callable) && is_object($callable[0]) ? '__call' : '__callStatic';
            }

            return new class($class, $method, $callable, $called_name) extends \ReflectionMethod {
                private $callable;
                private $call_name;
                private $definition;

                public function __construct($class, $method, $callable, $call_name)
                {
                    parent::__construct($class, $method);

                    $this->setAccessible(true); // 8.1 はデフォルトで true になるので模倣する
                    $this->callable = $callable;
                    $this->call_name = $call_name;
                }

                public function __invoke(...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->invoke($this->isStatic() ? null : $this->callable[0], ...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->getClosure($newThis ?? ($this->isStatic() ? null : $this->callable[0]))(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }
            };
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\reflect_type_resolve') || (new \ReflectionFunction('ryunosuke\\ltsv\\reflect_type_resolve'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\reflect_type_resolve')) {
    /**
     * ReflectionType の型に \\ を付与する
     *
     * php8.0 で ReflectionType の __toString が解放されたけど、それをそのまま埋め込んだりすると \\ がないのでエラーになったりする。
     * この関数を通してから埋め込めば \\ が付くので回避できる、という非常にニッチな関数。
     *
     * 型 exists で判定するため、付与するクラスは存在している必要がある（オプション引数で対応するかもしれない）。
     *
     * Example:
     * ```php
     * // このような DNF 型も形式を保ったまま \\ を付与できる
     * that(reflect_type_resolve('(Countable&Traversable)|object'))->is('(\\Countable&\\Traversable)|object');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param ?string $type string だが実用上は getType 等で得られるインスタンスでよい
     * @return ?string 解決された文字列
     */
    function reflect_type_resolve(?string $type): ?string
    {
        if ($type === null) {
            return null;
        }

        // 拡張関数が string|null ではなく ?string で返すことがあるので ? を含める
        // 8.1以上では交差型もあり得るので (&) も含める
        // そして PREG_SPLIT_DELIM_CAPTURE で分割して再結合すれば元の形式のまま得られる
        $types = preg_split('#([?()|&])#', $type, -1, PREG_SPLIT_DELIM_CAPTURE);
        $types = array_map(fn($v) => type_exists($v) ? "\\" . ltrim($v, '\\') : $v, $types);
        return implode('', $types);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\reflect_types') || (new \ReflectionFunction('ryunosuke\\ltsv\\reflect_types'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\reflect_types')) {
    /**
     * ReflectionType の型配列を返す
     *
     * ReflectionType のインターフェース・仕様がコロコロ変わってついていけないので関数化した。
     *
     * ReflectionType に準ずるインスタンスを渡すと取り得る候補を配列ライクなオブジェクトで返す。
     * 引数は配列で複数与えても良い。よしなに扱って複数型として返す。
     * また「Type が一意に導出できる Reflection」を渡しても良い（ReflectionProperty など）。
     * null を与えた場合はエラーにはならず、スルーされる（getType は null を返し得るので利便性のため）。
     *
     * 単純に ReflectionType の配列ライクなオブジェクトを返すが、そのオブジェクトは `__toString` が実装されており、文字列化するとパイプ区切りの型文字列を返す。
     * これは 8.0 における ReflectionUnionType の `__toString` を模倣したものである。
     * 互換性のある型があった場合、上位の型に内包されて型文字列としては出現しない。
     *
     * Countable も実装されているが、その結果は「内部 Type の数」ではなく、論理的に「取り得る型の数」を返す。
     * 例えば `?int` は型としては1つだが、実際は int, null の2つを取り得るため、 count は 2 を返す。
     * 端的に言えば「`__toString` のパイプ区切りの型の数」を返す。
     *
     * あとは便利メソッドとして下記が生えている。
     *
     * - jsonSerialize: JsonSerializable 実装
     * - getTypes: 取り得る型をすべて返す（ReflectionUnionType 互換）
     * - getName: ReflectionUnionType 非互換 toString な型宣言文字列を返す
     * - allows: その値を取りうるか判定して返す
     *
     * ReflectionUnionType とは完全互換ではないので、php8.0が完全に使える環境であれば素直に ReflectionUnionType を使ったほうが良い。
     * （「常に（型分岐せずに）複数形で扱える」程度のメリットしかない。allows は惜しいが）。
     *
     * ちなみに型の変遷は下記の通り。
     *
     * - php7.1: ReflectionType::__toString が非推奨になった
     * - php7.1: ReflectionNamedType が追加され、各種 getType でそれを返すようになった
     * - php8.0: ReflectionType::__toString が非推奨ではなくなった
     * - php8.0: ReflectionUnionType が追加され、複合の場合は getType でそれを返すようになった
     *
     * Example:
     * ```php
     * $object = new class {
     *     function method(object $o):?string {}
     * };
     * $method = new \ReflectionMethod($object, 'method');
     * $types = reflect_types($method->getParameters()[0]->getType());
     * // 文字列化すると型宣言文字列を返すし、配列アクセスや count, iterable でそれぞれの型が得られる
     * that((string) $types)->is('object');
     * that($types[0])->isInstanceOf(\ReflectionType::class);
     * that(iterator_to_array($types))->eachIsInstanceOf(\ReflectionType::class);
     * that(count($types))->is(1);
     * // 返り値でも同じ（null 許容なので null が付くし count も 2 になる）
     * $types = reflect_types($method->getReturnType());
     * that((string) $types)->is('string|null');
     * that(count($types))->is(2);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param \ReflectionFunctionAbstract|\ReflectionType|\ReflectionType[]|null $reflection_type getType 等で得られるインスタンス
     * @return \ReflectTypes|object
     */
    function reflect_types($reflection_type = null)
    {
        if (!is_array($reflection_type)) {
            $reflection_type = [$reflection_type];
        }

        foreach ($reflection_type as $n => $rtype) {
            if ($rtype instanceof \ReflectionProperty) {
                $reflection_type[$n] = $rtype->getType();
            }
            if ($rtype instanceof \ReflectionFunctionAbstract) {
                $reflection_type[$n] = $rtype->getReturnType();
            }
            if ($rtype instanceof \ReflectionParameter) {
                $reflection_type[$n] = $rtype->getType();
            }
        }

        /**
         * @mixin \ReflectionType
         * @mixin \ReflectionNamedType
         * @mixin \ReflectionUnionType
         * @mixin \ReflectionIntersectionType
         */
        return new class(...$reflection_type)
            extends \stdClass
            implements \IteratorAggregate, \ArrayAccess, \Countable, \JsonSerializable {

            private const PSEUDO = [
                'mixed'    => [],
                'static'   => ['object', 'mixed'],
                'self'     => ['static', 'object', 'mixed'],
                'parent'   => ['static', 'object', 'mixed'],
                'callable' => ['mixed'],
                'iterable' => ['mixed'],
                'object'   => ['mixed'],
                'array'    => ['iterable', 'mixed'],
                'string'   => ['mixed'],
                'int'      => ['mixed'],
                'float'    => ['mixed'],
                'bool'     => ['mixed'],
                'false'    => ['bool', 'mixed'],
                'null'     => ['mixed'],
                'void'     => [],
            ];

            public function __construct(?\ReflectionType ...$reflection_types)
            {
                $types = [];
                foreach ($reflection_types as $type) {
                    if ($type === null) {
                        continue;
                    }

                    $types = array_merge($types, $type instanceof \ReflectionUnionType ? $type->getTypes() : [$type]);
                }

                // 配列キャストで配列を得たいので下手にフィールドを宣言せず直に生やす
                foreach ($types as $n => $type) {
                    $this->$n = $type;
                }
            }

            public function __toString(): string
            {
                return implode('|', $this->toStrings(true, true));
            }

            public function getIterator(): \Traversable
            {
                // yield from $this->getTypes();
                return new \ArrayIterator($this->getTypes());
            }

            public function offsetExists($offset): bool
            {
                return isset($this->$offset);
            }

            public function offsetGet($offset): mixed
            {
                return $this->$offset;
            }

            public function offsetSet($offset, $value): void
            {
                // for debug
                if (is_string($value)) {
                    $value = new class ($value, self::PSEUDO) extends \ReflectionNamedType {
                        private $typename;
                        private $nullable;
                        private $builtins;

                        public function __construct($typename, $builtins)
                        {
                            $this->typename = ltrim($typename, '?');
                            $this->nullable = $typename[0] === '?';
                            $this->builtins = $builtins;
                        }

                        public function getName(): string { return $this->typename; }

                        public function allowsNull(): bool { return $this->nullable; }

                        public function isBuiltin(): bool { return isset($this->builtins[$this->typename]); }

                        public function __toString(): string { return $this->getName(); }
                    };
                }

                assert($value instanceof \ReflectionType);
                if ($offset === null) {
                    $offset = max(array_keys($this->getTypes()) ?: [-1]) + 1;
                }
                $this->$offset = $value;
            }

            public function offsetUnset($offset): void
            {
                unset($this->$offset);
            }

            public function count(): int
            {
                return count($this->toStrings(true, false));
            }

            public function jsonSerialize(): array
            {
                return $this->toStrings(true, true);
            }

            public function getName(): string
            {
                $types = array_flip($this->toStrings(true, true));
                $nullable = false;
                if (isset($types['null']) && count($types) === 2) {
                    unset($types['null']);
                    $nullable = true;
                }

                $result = [];
                foreach ($types as $type => $dummy) {
                    $result[] = (isset(self::PSEUDO[$type]) ? '' : '\\') . $type;
                }
                return ($nullable ? '?' : '') . implode('|', $result);
            }

            public function getTypes(): array
            {
                return (array) $this;
            }

            public function allows($type, $strict = false): bool
            {
                $types = array_flip($this->toStrings(false, false));

                if (isset($types['mixed'])) {
                    return true;
                }

                foreach ($types as $allow => $dummy) {
                    if (function_exists($f = "is_$allow") && $f($type)) {
                        return true;
                    }
                    if (is_a($type, $allow, true)) {
                        return true;
                    }
                }

                if (!$strict) {
                    if (is_int($type) || is_float($type) || is_bool($type)) {
                        if (isset($types['int']) || isset($types['float']) || isset($types['bool']) || isset($types['string'])) {
                            return true;
                        }
                    }
                    if (is_string($type) || (is_object($type) && method_exists($type, '__toString'))) {
                        if (isset($types['string'])) {
                            return true;
                        }
                        if ((isset($types['int']) || isset($types['float'])) && is_numeric("$type")) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private function toStrings($ignore_compatible = true, $sort = true): array
            {
                $types = [];
                foreach ($this->getTypes() as $type) {
                    // ドキュメント上は「ReflectionNamedType を返す可能性があります」とのことなので getName 前提はダメ
                    // かといって文字列化前提だと 7.1 以降で deprecated が出てしまう
                    // つまり愚直に分岐するか @ で抑制するくらいしか多バージョン対応する術がない（7.1 の deprecated を解除して欲しい…）
                    $types[$type instanceof \ReflectionNamedType ? $type->getName() : (string) $type] = true;

                    if ($type->allowsNull()) {
                        $types['null'] = true;
                    }
                }

                if ($ignore_compatible) {
                    $types = array_filter($types, function ($type) use ($types) {
                        // いくつか互換のある内包疑似型が存在する（iterable は array を内包するし、 bool は false を内包する）
                        foreach (self::PSEUDO[$type] ?? [] as $parent) {
                            if (isset($types[$parent])) {
                                return false;
                            }
                        }
                        // さらに object 疑似型は全てのクラス名を内包する
                        if (isset($types['object']) && !isset(self::PSEUDO[$type])) {
                            return false;
                        }
                        return true;
                    }, ARRAY_FILTER_USE_KEY);
                }

                if ($sort) {
                    static $orders = null;
                    $orders ??= array_flip(array_keys(self::PSEUDO));
                    uksort($types, function ($a, $b) use ($orders) {
                        $issetA = isset($orders[$a]);
                        $issetB = isset($orders[$b]);
                        switch (true) {
                            case $issetA && $issetB:   // 共に疑似型
                                return $orders[$a] - $orders[$b];
                            case !$issetA && !$issetB: // 共にクラス名
                                return strcasecmp($a, $b);
                            case !$issetA && $issetB:  // A だけがクラス名
                                return -1;
                            case $issetA && !$issetB:  // B だけがクラス名
                                return +1;
                        }
                    });
                }
                return array_keys($types);
            }
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\include_stream') || (new \ReflectionFunction('ryunosuke\\ltsv\\include_stream'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\include_stream')) {
    /**
     * file スキームを上書きして include/require をフックできるストリームオブジェクトを返す
     *
     * register で include/require しようとしている $filename が渡ってくる callable を登録する。
     * restore で登録を解除する。
     *
     * stream wrapper にはスタッキングや取得系関数がないため、この関数を使うと file:// の登録は全て解除されるので注意。
     *
     * @package ryunosuke\Functions\Package\stream
     *
     * @return \IncludeStream|object stream wrapper オブジェクト
     */
    function include_stream()
    {
        static $declareProtocol;
        /**
         * file スキームで STREAM_OPEN_FOR_INCLUDE だけを特別扱いしたプロトコル
         *
         * include/require で呼ばれるメソッドはたかが知れているが、その前後等で通常操作がある可能性があるため、結局全部の実装が必要。
         */
        $declareProtocol ??= new class() {
            /** @var int https://github.com/php/php-src/blob/php-7.2.11/main/php_streams.h#L528-L529 */
            private const STREAM_OPEN_FOR_INCLUDE = 0x00000080;

            private static $hooks = [];

            private $handle;

            private $position;
            private $contents;
            private $stat;

            public $context;

            #<editor-fold desc="directory">

            public function dir_opendir($path, $options)
            {
                assert(isset($options)); // @todo It is used?
                return !!$this->handle = $this->call_original(fn() => opendir($path, ...$this->context ? [$this->context] : []));
            }

            public function dir_readdir()
            {
                return $this->call_original(fn() => readdir($this->handle));
            }

            public function dir_rewinddir()
            {
                return $this->call_original(fn() => rewinddir($this->handle));
            }

            public function dir_closedir()
            {
                return $this->call_original(fn() => closedir($this->handle));
            }

            #</editor-fold>

            #<editor-fold desc="stream">

            public function stream_open($path, $mode, $options, &$opened_path)
            {
                $use_path = $options & STREAM_USE_PATH;
                $report_errors = $options & STREAM_REPORT_ERRORS;
                $open_for_include = $options & self::STREAM_OPEN_FOR_INCLUDE;

                if ($open_for_include) {
                    if (!$this->call_original(function ($hook) use ($path) {
                        $contents = $hook($path) ?? @file_get_contents($path);
                        if (!is_string($contents)) {
                            return false;
                        }
                        $this->position = 0;
                        $this->contents = $contents;
                        $this->stat = stat($path);
                        $this->stat[7] = $this->stat['size'] = strlen($this->contents);
                        return true;
                    })) {
                        return false;
                    }
                    if ($use_path) {
                        $opened_path = stream_resolve_include_path($path); // @codeCoverageIgnore
                    }
                    return true;
                }

                $this->handle = $this->call_original(function ($hook) use ($path, $mode, $use_path, $report_errors) {
                    if ($report_errors) {
                        return fopen($path, $mode, $use_path, $this->context); // @codeCoverageIgnore
                    }
                    else {
                        return @fopen($path, $mode, $use_path, $this->context);
                    }
                });
                if ($use_path && $this->handle) {
                    $opened_path = stream_get_meta_data($this->handle)['uri']; // @codeCoverageIgnore
                }
                return !!$this->handle;
            }

            public function stream_lock($operation)
            {
                assert($this->handle, 'never call this method');
                // file_put_contents (LOCK_EX) を呼ぶと 0 で来ることがある
                if ($operation === 0) {
                    return true;
                }
                return flock($this->handle, $operation);
            }

            public function stream_tell()
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => ftell($this->handle));
            }

            public function stream_seek(int $offset, int $whence = SEEK_SET)
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => fseek($this->handle, $offset, $whence)) === 0;
            }

            public function stream_eof()
            {
                if (!$this->handle) {
                    return $this->position >= $this->stat['size'];
                }
                return feof($this->handle);
            }

            public function stream_read($count)
            {
                if (!$this->handle) {
                    $buffer = substr($this->contents, $this->position, $count);
                    $this->position += $count;
                    return $buffer;
                }
                return fread($this->handle, $count);
            }

            public function stream_write(string $data)
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => fwrite($this->handle, $data));
            }

            public function stream_truncate(int $new_size): bool
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => ftruncate($this->handle, $new_size));
            }

            public function stream_flush(): bool
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => fflush($this->handle));
            }

            public function stream_close()
            {
                if (!$this->handle) {
                    return true;
                }
                return fclose($this->handle);
            }

            public function stream_stat()
            {
                if (!$this->handle) {
                    return $this->stat;
                }
                return fstat($this->handle);
            }

            public function stream_set_option($option, $arg1, $arg2)
            {
                if (!$this->handle) {
                    return true;
                }
                // Windows の file スキームでは呼ばれない？（確かにブロッキングやタイムアウトは無縁そう）
                // @codeCoverageIgnoreStart
                switch ($option) {
                    default:
                        throw new \Exception();
                    case STREAM_OPTION_BLOCKING:
                        return stream_set_blocking($this->handle, $arg1);
                    case STREAM_OPTION_READ_TIMEOUT:
                        return stream_set_timeout($this->handle, $arg1, $arg2);
                    case STREAM_OPTION_READ_BUFFER:
                        return stream_set_read_buffer($this->handle, $arg2) === 0; // @todo $arg1 is used?
                    case STREAM_OPTION_WRITE_BUFFER:
                        return stream_set_write_buffer($this->handle, $arg2) === 0; // @todo $arg1 is used?
                }
                // @codeCoverageIgnoreEnd
            }

            /**
             * @codeCoverageIgnore
             */
            public function stream_cast(int $cast_as)
            {
                assert(is_int($cast_as));
                assert($this->handle, 'never call this method');
                return $this->handle;
            }

            #</editor-fold>

            #<editor-fold desc="url">

            public function stream_metadata($path, $option, $value)
            {
                return $this->call_original(function () use ($path, $option, $value) {
                    switch ($option) {
                        default:
                            throw new \Exception(); // @codeCoverageIgnore
                        case STREAM_META_TOUCH:
                            return touch($path, ...$value);
                        case STREAM_META_ACCESS:
                            return chmod($path, $value);
                        case STREAM_META_OWNER_NAME:
                        case STREAM_META_OWNER:
                            return chown($path, $value);
                        case STREAM_META_GROUP_NAME:
                        case STREAM_META_GROUP:
                            return chgrp($path, $value);
                    }
                });
            }

            public function url_stat($path, $flags)
            {
                return $this->call_original(function () use ($path, $flags) {
                    if ($flags & STREAM_URL_STAT_LINK) {
                        $func = 'lstat';
                    }
                    else {
                        $func = 'stat';
                    }
                    if ($flags & STREAM_URL_STAT_QUIET) {
                        return @$func($path);
                    }
                    else {
                        return $func($path);
                    }
                });
            }

            public function mkdir(string $path, int $mode, int $options)
            {
                return $this->call_original(fn() => mkdir($path, $mode, !!($options & STREAM_MKDIR_RECURSIVE), $this->context));
            }

            public function rmdir(string $path, int $options)
            {
                assert(isset($options)); // @todo It is used?
                return $this->call_original(fn() => rmdir($path, $this->context));
            }

            public function rename(string $path_from, string $path_to)
            {
                return $this->call_original(fn() => rename($path_from, $path_to, $this->context));
            }

            public function unlink(string $path)
            {
                return $this->call_original(fn() => unlink($path, $this->context));
            }

            #</editor-fold>

            public function register($hook)
            {
                stream_wrapper_unregister('file');
                stream_wrapper_register('file', get_class($this));
                self::$hooks[] = $hook;
                return $this;
            }

            public function restore()
            {
                stream_wrapper_unregister('file');
                stream_wrapper_restore('file');
                return array_pop(self::$hooks);
            }

            private function call_original($function)
            {
                $current = $this->restore();
                try {
                    return $function($current);
                }
                finally {
                    $this->register($current);
                }
            }
        };

        return $declareProtocol;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\memory_stream') || (new \ReflectionFunction('ryunosuke\\ltsv\\memory_stream'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\memory_stream')) {
    /**
     * ファイルのように扱えるメモリ上のパスを返す
     *
     * 劣化 vfsStream のようなもの。
     * stream wrapper を用いて実装しており、そのプロトコルは初回呼び出し時に1度だけ登録される。
     * プロトコル名は決め打ちだが、 php.ini に "rfunc.memory_stream" というキーで文字列を指定するとそれが使用される。
     *
     * Example:
     * ```php
     * // ファイル名のように読み書きができるパスを返す（一時ファイルを使用するよりかなり高速に動作する）
     * $memory_stream = memory_stream('filename.txt');
     * // 呼んだだけでは何もしないので存在しない
     * that(file_exists($memory_stream))->isSame(false);
     * // file_put_contents が使える
     * that(file_put_contents($memory_stream, 'Hello, World'))->isSame(12);
     * // file_get_contents が使える
     * that(file_get_contents($memory_stream))->isSame('Hello, World');
     * // 上記の操作で実体が存在している
     * that(file_exists($memory_stream))->isSame(true);
     * // unlink が使える
     * that(unlink($memory_stream))->isSame(true);
     * // unlink したので存在しない
     * that(file_exists($memory_stream))->isSame(false);
     * ```
     *
     * @package ryunosuke\Functions\Package\stream
     *
     * @param string $path パス名（実質的に一意なファイル名）
     * @return string メモリ上のパス
     */
    function memory_stream($path = '')
    {
        static $STREAM_NAME, $registered = false;
        if (!$registered) {
            $STREAM_NAME = $STREAM_NAME ?: function_configure('memory_stream');
            if (in_array($STREAM_NAME, stream_get_wrappers())) {
                throw new \DomainException("$STREAM_NAME is registered already.");
            }

            $registered = true;
            stream_wrapper_register($STREAM_NAME, get_class(new class() {
                private static $entries = [];

                private $entry;
                private $id;
                private $position;
                private $appendable;

                public $context;

                private static function id($path)
                {
                    $parts = parse_url($path) ?: [];
                    $id = ($parts['host'] ?? '') . ($parts['path'] ?? '');
                    $id = strtr($id, ['\\' => '/']);
                    return rtrim($id, '/');
                }

                private static function create($id, $mode)
                {
                    // @todo time 系は一応用意しているだけでほとんど未実装（read/write のたびに更新する？）
                    $now = time();
                    self::$entries[$id] = (object) [
                        'mode'    => $mode | (0777 & ~umask()),
                        'owner'   => function_exists('posix_getuid') ? posix_getuid() : 0,
                        'group'   => function_exists('posix_getgid') ? posix_getgid() : 0,
                        'atime'   => $now,
                        'mtime'   => $now,
                        'ctime'   => $now,
                        'content' => '',
                    ];
                }

                private static function stat($id)
                {
                    $that = self::$entries[$id];
                    return [
                        'dev'     => 0,
                        'ino'     => 0,
                        'mode'    => $that->mode,
                        'nlink'   => 0,
                        'uid'     => $that->owner,
                        'gid'     => $that->group,
                        'rdev'    => 0,
                        'size'    => array_reduce((array) $that->content, fn($carry, $item) => $carry + strlen($item), 0),
                        'atime'   => $that->atime,
                        'mtime'   => $that->mtime,
                        'ctime'   => $that->ctime,
                        'blksize' => -1,
                        'blocks'  => -1,
                    ];
                }

                /** @noinspection PhpUnusedParameterInspection */
                public function stream_set_option(int $option, int $arg1, int $arg2)
                {
                    return false;
                }

                public function stream_open(string $path, string $mode, int $options, &$opened_path): bool
                {
                    assert(is_int($options));
                    assert(is_null($opened_path) || !strlen($opened_path));
                    $this->id = self::id($path);

                    // t フラグはクソなので実装しない（デフォルトで b フラグとする）
                    if (strpos($mode, 'r') !== false) {
                        // 普通の fopen でファイルが存在しないとエラーになるので模倣する
                        if (!isset(self::$entries[$this->id])) {
                            throw new \InvalidArgumentException("'$path' is not exist.");
                        }
                        $this->position = 0;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'w') !== false) {
                        // ファイルポインタをファイルの先頭に置き、ファイルサイズをゼロにします。
                        // ファイルが存在しない場合には、作成を試みます。
                        self::create($this->id, 010_0000);
                        $this->position = 0;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'a') !== false) {
                        // ファイルポインタをファイルの終端に置きます。
                        // ファイルが存在しない場合には、作成を試みます。
                        if (!isset(self::$entries[$this->id])) {
                            self::create($this->id, 010_0000);
                        }
                        $this->position = 0;
                        $this->appendable = true;
                    }
                    elseif (strpos($mode, 'x') !== false) {
                        // ファイルポインタをファイルの先頭に置きます。
                        // ファイルが既に存在する場合には fopen() は失敗し、 E_WARNING レベルのエラーを発行します。
                        // ファイルが存在しない場合には新規作成を試みます。
                        if (isset(self::$entries[$this->id])) {
                            throw new \InvalidArgumentException("'$path' is exist already.");
                        }
                        self::create($this->id, 010_0000);
                        $this->position = 0;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'c') !== false) {
                        // ファイルが存在しない場合には新規作成を試みます。
                        // ファイルが既に存在する場合でもそれを ('w' のように) 切り詰めたりせず、 また ('x' のように) 関数のコールが失敗することもありません。
                        // ファイルポインタをファイルの先頭に置きます。
                        if (!isset(self::$entries[$this->id])) {
                            self::create($this->id, 010_0000);
                        }
                        $this->position = 0;
                        $this->appendable = false;
                    }

                    $this->entry = self::$entries[$this->id];

                    return true;
                }

                public function stream_close()
                {
                }

                public function stream_lock(int $operation): bool
                {
                    assert(is_int($operation));
                    // メモリアクセスは競合しないので常に true を返す
                    return true;
                }

                public function stream_flush(): bool
                {
                    // バッファしないので常に true を返す
                    return true;
                }

                public function stream_eof(): bool
                {
                    return $this->position >= strlen($this->entry->content);
                }

                public function stream_read(int $count): string
                {
                    $result = substr($this->entry->content, $this->position, $count);
                    $this->position += strlen($result);
                    return $result;
                }

                public function stream_write(string $data): int
                {
                    $datalen = strlen($data);
                    $posision = $this->position;
                    // このモードは、fseek() では何の効果もありません。書き込みは、常に追記となります。
                    if ($this->appendable) {
                        $posision = strlen($this->entry->content);
                    }
                    // 一般的に、ファイルの終端より先の位置に移動することも許されています。
                    // そこにデータを書き込んだ場合、ファイルの終端からシーク位置までの範囲を読み込むと 値 0 が埋められたバイトを返します。
                    $current = str_pad($this->entry->content, $posision, "\0", STR_PAD_RIGHT);
                    $this->entry->content = substr_replace($current, $data, $posision, $datalen);
                    $this->position += $datalen;
                    return $datalen;
                }

                public function stream_truncate(int $new_size): bool
                {
                    $current = substr($this->entry->content, 0, $new_size);
                    $this->entry->content = str_pad($current, $new_size, "\0", STR_PAD_RIGHT);
                    return true;
                }

                public function stream_tell(): int
                {
                    return $this->position;
                }

                public function stream_seek(int $offset, int $whence = SEEK_SET): bool
                {
                    $strlen = strlen($this->entry->content);
                    switch ($whence) {
                        case SEEK_SET:
                            if ($offset < 0) {
                                return false;
                            }
                            $this->position = $offset;
                            break;

                        // stream_tell を定義していると SEEK_CUR が呼ばれない？（計算されて SEEK_SET に移譲されているような気がする）
                        // @codeCoverageIgnoreStart
                        case SEEK_CUR:
                            $this->position += $offset;
                            break;
                        // @codeCoverageIgnoreEnd

                        case SEEK_END:
                            $this->position = $strlen + $offset;
                            break;
                    }
                    // ファイルの終端から数えた位置に移動するには、負の値を offset に渡して whence を SEEK_END に設定しなければなりません。
                    if ($this->position < 0) {
                        $this->position = $strlen + $this->position;
                        if ($this->position < 0) {
                            $this->position = 0;
                            return false;
                        }
                    }
                    return true;
                }

                public function stream_stat()
                {
                    return self::stat($this->id);
                }

                public function stream_metadata($path, $option, $var)
                {
                    $id = self::id($path);
                    switch ($option) {
                        case STREAM_META_TOUCH:
                            if (!isset(self::$entries[$id])) {
                                self::create($id, 010_0000);
                            }
                            $mtime = $var[0] ?? time();
                            $atime = $var[1] ?? $mtime;
                            self::$entries[$id]->mtime = $mtime;
                            self::$entries[$id]->atime = $atime;
                            break;

                        case STREAM_META_ACCESS:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->mode &= 077_0000;
                            self::$entries[$id]->mode |= $var & ~umask();
                            self::$entries[$id]->ctime = time();
                            break;

                        /** @noinspection PhpMissingBreakStatementInspection */
                        case STREAM_META_OWNER_NAME:
                            $nam = function_exists('posix_getpwnam') ? posix_getpwnam($var) : [];
                            $var = $nam['uid'] ?? 0;
                        case STREAM_META_OWNER:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->owner = $var;
                            self::$entries[$id]->ctime = time();
                            break;

                        /** @noinspection PhpMissingBreakStatementInspection */
                        case STREAM_META_GROUP_NAME:
                            $var = function_exists('posix_getgrnam') ? posix_getgrnam($var)['gid'] : 0;
                        case STREAM_META_GROUP:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->group = $var;
                            self::$entries[$id]->ctime = time();
                            break;
                    }
                    // https://qiita.com/hnw/items/3af76d3d7ec2cf52fff8
                    clearstatcache(true, $path);
                    return true;
                }

                public function url_stat(string $path, int $flags)
                {
                    assert(is_int($flags));
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    return self::stat($id);
                }

                public function rename(string $path_from, string $path_to): bool
                {
                    // rename は同じプロトコルじゃないと使えない制約があるのでプロトコルは見ないで OK
                    $id_from = self::id($path_from);
                    if (!isset(self::$entries[$id_from])) {
                        return false;
                    }
                    $id_to = self::id($path_to);
                    self::$entries[$id_to] = self::$entries[$id_from];
                    unset(self::$entries[$id_from]);
                    // https://qiita.com/hnw/items/3af76d3d7ec2cf52fff8
                    clearstatcache(true, $path_from);
                    return true;
                }

                public function unlink(string $path): bool
                {
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    unset(self::$entries[$id]);
                    // もしファイルを作成した場合、 たとえファイルを削除したとしても TRUE を返します。しかし、unlink() はキャッシュを自動的にクリアします。
                    clearstatcache(true, $path);
                    return true;
                }

                public function mkdir($path, $mode, $options)
                {
                    $id = self::id($path);
                    if (isset(self::$entries[$id])) {
                        return false;
                    }
                    $parts = explode('/', $id);
                    if (count($parts) > 1 && !($options & STREAM_MKDIR_RECURSIVE)) {
                        if (!isset(self::$entries[implode('/', array_slice($parts, 0, -1))])) {
                            return false;
                        }
                    }
                    $dirpath = '';
                    foreach ($parts as $part) {
                        $dirpath .= "$part/";
                        self::create(rtrim($dirpath, '/'), 004_0000 | $mode);
                    }
                    return true;
                }

                public function rmdir($path, $options)
                {
                    assert(is_int($options));
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    foreach (self::$entries as $eid => $entry) {
                        if (preg_match('#^' . preg_quote("$id/", '#') . '([^/]+)$#u', $eid)) {
                            return false;
                        }
                    }
                    unset(self::$entries[$id]);
                    clearstatcache(true, $path);
                    return true;
                }

                public function dir_opendir(string $path, int $options)
                {
                    assert(is_int($options));
                    $id = self::id($path);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }

                    $files = ['.', '..'];
                    foreach (self::$entries as $eid => $entry) {
                        if (preg_match('#^' . preg_quote("$id/", '#') . '([^/]+)$#u', $eid, $m)) {
                            $files[] = $m[1];
                        }
                    }

                    $this->entry = self::$entries[$id];
                    $this->entry->content = $files;
                    return true;
                }

                public function dir_readdir()
                {
                    $result = current($this->entry->content);
                    next($this->entry->content);
                    return $result;
                }

                public function dir_rewinddir()
                {
                    reset($this->entry->content);
                    return true;
                }

                public function dir_closedir()
                {
                    unset($this->entry);
                    return true;
                }
            }));
        }

        return "$STREAM_NAME://" . trim($path, '\\/');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\profiler') || (new \ReflectionFunction('ryunosuke\\ltsv\\profiler'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\profiler')) {
    /**
     * 外部ツールに頼らない pure php なプロファイラを返す
     *
     * file プロトコル上書きと ticks と debug_backtrace によるかなり無理のある実装なので動かない環境・コードは多い。
     * その分お手軽だが下記の注意点がある。
     *
     * - file プロトコルを上書きするので、既に読み込み済みのファイルは計上されない
     * - tick されないステートメントは計上されない
     *     - 1行メソッドなどでありがち
     * - A->B->C という呼び出しで C が 3秒、B が 2秒、A が1秒かかった場合、 A は 6 秒、B は 5秒、C は 3 秒といて計上される
     *     - つまり、配下の呼び出しも重複して計上される
     *
     * この関数を呼んだ時点で計測は始まる。
     * 返り値としてイテレータを返すので、foreach で回せばコールスタック・回数・時間などが取得できる。
     * 配列で欲しい場合は直に呼べば良い。
     *
     * @package ryunosuke\Functions\Package\stream
     *
     * @param array $options オプション配列
     * @return \Traversable|callable プロファイライテレータ
     */
    function profiler($options = [])
    {
        $profiler = new class($options) implements \IteratorAggregate {
            private $result = [];
            private $wrapper;
            private $ticker;

            public function __construct($options = [])
            {
                $this->wrapper = include_stream()->register(static function ($filename) {
                    if (pathinfo($filename, PATHINFO_EXTENSION) === 'php') {
                        return "<?php declare(ticks=1) ?>" . file_get_contents($filename);
                    }
                });

                $options = array_replace([
                    'callee'   => null,
                    'location' => null,
                ], $options);
                $last_trace = [];
                $result = &$this->result;
                $this->ticker = static function () use ($options, &$last_trace, &$result) {
                    $now = microtime(true);
                    $traces = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);

                    $last_count = count($last_trace);
                    $current_count = count($traces);

                    // スタック数が変わってない（=同じメソッドを処理している？）
                    if ($current_count === $last_count) {
                        assert($current_count === $last_count); // @codeCoverageIgnore
                    }
                    // スタック数が増えた（=新しいメソッドが開始された？）
                    elseif ($current_count > $last_count) {
                        foreach (array_slice($traces, 1, $current_count - $last_count) as $last) {
                            $last['time'] = $now;
                            $last['callee'] = (isset($last['class'], $last['type']) ? $last['class'] . $last['type'] : '') . $last['function'];
                            $last['location'] = isset($last['file'], $last['line']) ? $last['file'] . '#' . $last['line'] : null;
                            array_unshift($last_trace, $last);
                        }
                    }
                    // スタック数が減った（=処理してたメソッドを抜けた？）
                    elseif ($current_count < $last_count) {
                        $prev = null; // array_map などの内部関数はスタックが一気に2つ増減する
                        foreach (array_splice($last_trace, 0, $last_count - $current_count) as $last) {
                            $time = $now - $last['time'];
                            $callee = $last['callee'];
                            $location = $last['location'] ?? ($prev['file'] ?? '') . '#' . ($prev['line'] ?? '');
                            $prev = $last;

                            foreach (['callee', 'location'] as $key) {
                                $condition = $options[$key];
                                $value = $$key;
                                if ($condition !== null) {
                                    if ($condition instanceof \Closure) {
                                        if (!$condition($value)) {
                                            continue 2;
                                        }
                                    }
                                    else {
                                        if (!preg_match($condition, $value)) {
                                            continue 2;
                                        }
                                    }
                                }
                            }
                            $result[$callee][$location][] = $time;
                        }
                    }
                };

                register_tick_function($this->ticker);
                opcache_reset();
            }

            public function __destruct()
            {
                unregister_tick_function($this->ticker);

                $this->wrapper->restore();
            }

            public function __invoke()
            {
                return $this->result;
            }

            public function getIterator(): \Traversable
            {
                return yield from $this->result;
            }
        };

        return $profiler;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_stream') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_stream'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_stream')) {
    /**
     * 変数をリソースのように扱えるファイルポインタを返す
     *
     * 得られたファイルポインタに fread すれば変数の値が見えるし、 fwrite すれば変数の値が書き換わる。
     * 逆に変数を書き換えればファイルポインタで得られる値も書き換わる。
     *
     * 用途は主にテスト用。
     * 例えば「何らかのファイルポインタを要求する処理」に対して fopen や tmpfile を駆使して値の確認をするのは結構めんどくさい。
     * （`rewind` したり `stream_get_contents` したり削除したりする必要がある）。
     * それよりもこの関数で得られたファイルポインタを渡し、 `that($var)->is($expected)` とできる方がテストの視認性が良くなる。
     *
     * Example:
     * ```php
     * // $var のファイルポインタを取得
     * $fp = var_stream($var);
     * // ファイルポインタに書き込みを行うと変数にも反映される
     * fwrite($fp, 'hoge');
     * that($var)->is('hoge');
     * // 変数に追記を行うとファイルポインタで読み取れる
     * $var .= 'fuga';
     * that(fread($fp, 1024))->is('fuga');
     * // 変数をまるっと置換するとファイルポインタ側もまるっと変わる
     * $var = 'hello, world';
     * that(stream_get_contents($fp, -1, 0))->is('hello, world');
     * // ファイルポインタをゴリっと削除すると変数も空になる
     * ftruncate($fp, 0);
     * that($var)->is('');
     * ```
     *
     * @package ryunosuke\Functions\Package\stream
     *
     * @param string|null $var 対象の変数
     * @param string $initial 初期値。与えたときのみ初期化される
     * @return resource 変数のファイルポインタ
     */
    function var_stream(&$var, $initial = '')
    {
        static $STREAM_NAME, $stream_class, $registered = false;
        if (!$registered) {
            $STREAM_NAME = $STREAM_NAME ?: function_configure('var_stream');
            if (in_array($STREAM_NAME, stream_get_wrappers())) {
                throw new \DomainException("$STREAM_NAME is registered already.");
            }

            $registered = true;
            stream_wrapper_register($STREAM_NAME, $stream_class = get_class(new class() {
                private static $ids     = 0;
                private static $entries = [];

                private $id;
                private $entry;
                private $position;

                public $context;

                public static function create(string &$var): int
                {
                    self::$entries[++self::$ids] = &$var;
                    return self::$ids;
                }

                public function stream_open(string $path, string $mode, int $options, &$opened_path): bool
                {
                    assert([$mode, $options, &$opened_path]);
                    $this->id = parse_url($path, PHP_URL_HOST);
                    $this->entry = &self::$entries[$this->id];
                    $this->position = 0;

                    return true;
                }

                public function stream_close()
                {
                    unset(self::$entries[$this->id]);
                }

                public function stream_lock(int $operation): bool
                {
                    assert(is_int($operation));
                    // 競合しないので常に true を返す
                    return true;
                }

                public function stream_flush(): bool
                {
                    // バッファしないので常に true を返す
                    return true;
                }

                public function stream_eof(): bool
                {
                    // 変数の書き換えを検知する術はないので eof は殺しておく
                    return false;
                }

                public function stream_read(int $count): string
                {
                    $result = substr($this->entry, $this->position, $count);
                    $this->position += strlen($result);
                    return $result;
                }

                public function stream_write(string $data): int
                {
                    $datalen = strlen($data);
                    $posision = $this->position;
                    // 一般的に、ファイルの終端より先の位置に移動することも許されています。
                    // そこにデータを書き込んだ場合、ファイルの終端からシーク位置までの範囲を読み込むと 値 0 が埋められたバイトを返します。
                    $current = str_pad($this->entry, $posision, "\0", STR_PAD_RIGHT);
                    $this->entry = substr_replace($current, $data, $posision, $datalen);
                    $this->position += $datalen;
                    return $datalen;
                }

                public function stream_truncate(int $new_size): bool
                {
                    $current = substr($this->entry, 0, $new_size);
                    $this->entry = str_pad($current, $new_size, "\0", STR_PAD_RIGHT);
                    return true;
                }

                public function stream_tell(): int
                {
                    return $this->position;
                }

                public function stream_seek(int $offset, int $whence = SEEK_SET): bool
                {
                    $strlen = strlen($this->entry);
                    switch ($whence) {
                        case SEEK_SET:
                            if ($offset < 0) {
                                return false;
                            }
                            $this->position = $offset;
                            break;

                        // stream_tell を定義していると SEEK_CUR が呼ばれない？（計算されて SEEK_SET に移譲されているような気がする）
                        // @codeCoverageIgnoreStart
                        case SEEK_CUR:
                            $this->position += $offset;
                            break;
                        // @codeCoverageIgnoreEnd

                        case SEEK_END:
                            $this->position = $strlen + $offset;
                            break;
                    }
                    // ファイルの終端から数えた位置に移動するには、負の値を offset に渡して whence を SEEK_END に設定しなければなりません。
                    if ($this->position < 0) {
                        $this->position = $strlen + $this->position;
                        if ($this->position < 0) {
                            $this->position = 0;
                            return false;
                        }
                    }
                    return true;
                }

                public function stream_stat()
                {
                    $size = strlen($this->entry);
                    return [
                        7      => $size,
                        'size' => $size,
                    ];
                }
            }));
        }

        if (func_num_args() > 1) {
            $var = $initial;
        }
        // タイプヒントによる文字列化とキャストによる文字列化は動作が異なるので、この段階で早めに文字列化しておく
        $var = (string) $var;
        return fopen($STREAM_NAME . '://' . $stream_class::create($var), 'r+b');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\camel_case') || (new \ReflectionFunction('ryunosuke\\ltsv\\camel_case'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\camel_case')) {
    /**
     * camelCase に変換する
     *
     * Example:
     * ```php
     * that(camel_case('this_is_a_pen'))->isSame('thisIsAPen');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ
     * @return string 変換した文字列
     */
    function camel_case(?string $string, ?string $delimiter = '_')
    {
        return lcfirst(pascal_case($string, $delimiter));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\chain_case') || (new \ReflectionFunction('ryunosuke\\ltsv\\chain_case'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\chain_case')) {
    /**
     * chain-case に変換する
     *
     * Example:
     * ```php
     * that(chain_case('ThisIsAPen'))->isSame('this-is-a-pen');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ
     * @return string 変換した文字列
     */
    function chain_case(?string $string, ?string $delimiter = '-')
    {
        return snake_case($string, $delimiter);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\concat') || (new \ReflectionFunction('ryunosuke\\ltsv\\concat'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\concat')) {
    /**
     * strcat の空文字回避版
     *
     * 基本は strcat と同じ。ただし、**引数の内1つでも空文字を含むなら空文字を返す**。
     * さらに*引数の内1つでも null を含むなら null を返す**。
     *
     * 「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。
     * コードで言えば `strlen($string) ? 'prefix-' . $string : '';` のようなもの。
     * 可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる。
     *
     * ```php
     * that(concat('prefix-', 'middle', '-suffix'))->isSame('prefix-middle-suffix');
     * that(concat('prefix-', '', '-suffix'))->isSame('');
     * that(concat('prefix-', null, '-suffix'))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param ?string ...$variadic 結合する文字列（可変引数）
     * @return ?string 結合した文字列
     */
    function concat(...$variadic)
    {
        if (count(array_filter($variadic, 'is_null')) > 0) {
            return null;
        }
        $result = '';
        foreach ($variadic as $s) {
            if (strlen($s) === 0) {
                return '';
            }
            $result .= $s;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\damerau_levenshtein') || (new \ReflectionFunction('ryunosuke\\ltsv\\damerau_levenshtein'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\damerau_levenshtein')) {
    /**
     * Damerau–Levenshtein 距離を返す
     *
     * 簡単に言えば「転置（入れ替え）を考慮したレーベンシュタイン」である。
     * 例えば "destroy" と "destory" は 「1挿入1削除=2」であるが、Damerau 版だと「1転置=1」となる。
     *
     * また、マルチバイト（UTF-8 のみ）にも対応している。
     *
     * Example:
     * ```php
     * // destroy と destory は普通にレーベンシュタイン距離を取ると 2 になるが・・・
     * that(levenshtein("destroy", "destory"))->isSame(2);
     * // damerau_levenshtein だと1である
     * that(damerau_levenshtein("destroy", "destory"))->isSame(1);
     * // UTF-8 でも大丈夫
     * that(damerau_levenshtein("あいうえお", "あいえうお"))->isSame(1);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $s1 対象文字列1
     * @param string $s2 対象文字列2
     * @param int $cost_ins 挿入のコスト
     * @param int $cost_rep 置換のコスト
     * @param int $cost_del 削除のコスト
     * @param int $cost_swp 転置のコスト
     * @return int Damerau–Levenshtein 距離
     */
    function damerau_levenshtein($s1, $s2, $cost_ins = 1, $cost_rep = 1, $cost_del = 1, $cost_swp = 1)
    {
        $s1 = is_array($s1) ? $s1 : preg_split('//u', $s1, -1, PREG_SPLIT_NO_EMPTY);
        $s2 = is_array($s2) ? $s2 : preg_split('//u', $s2, -1, PREG_SPLIT_NO_EMPTY);
        $l1 = count($s1);
        $l2 = count($s2);
        if (!$l1) {
            return $l2 * $cost_ins;
        }
        if (!$l2) {
            return $l1 * $cost_del;
        }
        $p1 = array_fill(0, $l2 + 1, 0);
        $p2 = array_fill(0, $l2 + 1, 0);
        for ($i2 = 0; $i2 <= $l2; $i2++) {
            $p1[$i2] = $i2 * $cost_ins;
        }
        for ($i1 = 0; $i1 < $l1; $i1++) {
            $p2[0] = $p1[0] + $cost_del;
            for ($i2 = 0; $i2 < $l2; $i2++) {
                $c0 = $p1[$i2];
                if ($s1[$i1] !== $s2[$i2]) {
                    if (
                        $cost_swp && (
                            ($s1[$i1] === ($s2[$i2 - 1] ?? '') && ($s1[$i1 - 1] ?? '') === $s2[$i2]) ||
                            ($s1[$i1] === ($s2[$i2 + 1] ?? '') && ($s1[$i1 + 1] ?? '') === $s2[$i2])
                        )
                    ) {
                        $c0 += $cost_swp / 2;
                    }
                    else {
                        $c0 += $cost_rep;
                    }
                }
                $c1 = $p1[$i2 + 1] + $cost_del;
                if ($c1 < $c0) {
                    $c0 = $c1;
                }
                $c2 = $p2[$i2] + $cost_ins;
                if ($c2 < $c0) {
                    $c0 = $c2;
                }
                $p2[$i2 + 1] = $c0;
            }
            $tmp = $p1;
            $p1 = $p2;
            $p2 = $tmp;
        }
        return (int) $p1[$l2];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ends_with') || (new \ReflectionFunction('ryunosuke\\ltsv\\ends_with'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ends_with')) {
    /**
     * 指定文字列で終わるか調べる
     *
     * $with に配列を渡すといずれかで終わるときに true を返す。
     *
     * Example:
     * ```php
     * that(ends_with('abcdef', 'def'))->isTrue();
     * that(ends_with('abcdef', 'DEF', true))->isTrue();
     * that(ends_with('abcdef', 'xyz'))->isFalse();
     * that(ends_with('abcdef', ['d', 'e', 'f']))->isTrue();
     * that(ends_with('abcdef', ['x', 'y', 'z']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 探される文字列
     * @param string|string[] $with 探す文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 対象文字列で終わるなら true
     */
    function ends_with(?string $string, $with, $case_insensitivity = false)
    {
        foreach ((array) $with as $w) {
            assert(strlen($w));

            if (str_equals(substr($string, -strlen($w)), $w, $case_insensitivity)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\include_string') || (new \ReflectionFunction('ryunosuke\\ltsv\\include_string'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\include_string')) {
    /**
     * 変数を extract して include する（文字列指定）
     *
     * @package ryunosuke\Functions\Package\strings
     * @see ob_include()
     *
     * @param string $template テンプレート文字列
     * @param array $array extract される連想変数
     * @return string レンダリングされた文字列
     */
    function include_string(?string $template, $array = [])
    {
        // opcache が効かない気がする
        $path = memory_stream(__FUNCTION__);
        file_put_contents($path, $template);
        $result = ob_include($path, $array);
        unlink($path);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\kvsprintf') || (new \ReflectionFunction('ryunosuke\\ltsv\\kvsprintf'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\kvsprintf')) {
    /**
     * 連想配列を指定できるようにした vsprintf
     *
     * sprintf の順序指定構文('%1$d')にキーを指定できる。
     *
     * Example:
     * ```php
     * that(kvsprintf('%hoge$s %fuga$d', ['hoge' => 'ThisIs', 'fuga' => '3.14']))->isSame('ThisIs 3');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $format フォーマット文字列
     * @param array $array フォーマット引数
     * @return string フォーマットされた文字列
     */
    function kvsprintf(?string $format, array $array)
    {
        $keys = array_flip(array_keys($array));
        $vals = array_values($array);

        $format = preg_replace_callback('#%%|%(.*?)\$#u', function ($m) use ($keys) {
            if (!isset($m[1])) {
                return $m[0];
            }

            $w = $m[1];
            if (!isset($keys[$w])) {
                throw new \OutOfBoundsException("kvsprintf(): Undefined index: $w");
            }

            return '%' . ($keys[$w] + 1) . '$';

        }, $format);

        return vsprintf($format, $vals);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_compatible_encoding') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_compatible_encoding'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_compatible_encoding')) {
    /**
     * 指定エンコーディング間に互換性があるかを返す
     *
     * ※ ユースケースとして多い utf8,sjis 以外はほぼ実装していないので注意（かなり適当なのでそれすらも怪しい）
     *
     * mb_convert_encoding/mb_convert_variables は実際に変換が行われなくても処理が走ってしまうので、それを避けるための関数。
     * エンコーディングはただでさえカオスなのに utf8, UTF-8, sjis, sjis-win, cp932 などの表記揺れやエイリアスがあるので判定が結構しんどい。
     *
     * Example:
     * ```php
     * // ほぼ唯一のユースケース（互換性があるなら変換しない）
     * if (!mb_compatible_encoding(mb_internal_encoding(), 'utf8')) {
     *     mb_convert_encoding('utf8 string', 'utf8');
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $from 変換元エンコーディング
     * @param string $to 変換先エンコーディング
     * @return ?bool from が to に対して互換性があるなら true（8bit binary の時のみ例外的に null を返す）
     */
    function mb_compatible_encoding(?string $from, ?string $to)
    {
        static $encmap = [];
        if (!$encmap) {
            foreach (mb_list_encodings() as $encoding) {
                // 非推奨を避ける
                if (!in_array($encoding, ['BASE64', 'UUENCODE', 'HTML-ENTITIES', 'Quoted-Printable'], true)) {
                    $encmap[strtolower($encoding)] = [
                        'aliases'  => array_flip(array_map('strtolower', mb_encoding_aliases($encoding))),
                        'mimename' => strtolower((string) @mb_preferred_mime_name($encoding)),
                    ];
                }
            }
        }

        // php 世界のエンコーディング名に正規化
        $normalize = function ($encoding) use ($encmap) {
            $encoding = strtolower($encoding);

            static $cache = [];

            if (isset($cache[$encoding])) {
                return $cache[$encoding];
            }

            if (isset($encmap[$encoding])) {
                return $cache[$encoding] = $encoding;
            }
            foreach ($encmap as $encname => ['aliases' => $aliases]) {
                if (isset($aliases[$encoding])) {
                    return $cache[$encoding] = $encname;
                }
            }
            foreach ($encmap as $encname => ['mimename' => $mimename]) {
                if ($mimename === $encoding) {
                    return $cache[$encoding] = $encname;
                }
            }

            throw new \InvalidArgumentException("$encoding is not supported encoding");
        };

        $from = $normalize($from);
        $to = $normalize($to);

        // 他方が 8bit(binary) は全く互換性がない（互換性がないというか、そもそもテキストではない）
        // false を返すべきだが呼び元で特殊な処理をしたいことがあると思うので null にする
        if ($from === '8bit' xor $to === '8bit') {
            return null;
        }

        // 同じなら完全互換だろう
        if ($from === $to) {
            return true;
        }

        // ucs 系以外は大抵は ASCII 互換
        if ($from === 'ascii' && !preg_match('#^(ucs-2|ucs-4|utf-16|utf-32)#', $to)) {
            return true;
        }

        // utf8 派生
        if ($from === 'utf-8' && strpos($to, 'utf-8') === 0) {
            return true;
        }

        // sjis 派生
        if ($from === 'sjis' && (strpos($to, 'sjis') === 0 || $to === 'cp932')) {
            return true;
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_ellipsis') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_ellipsis'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_ellipsis')) {
    /**
     * 文字列を指定幅に丸める
     *
     * mb_strimwidth と機能的には同じだが、省略文字の差し込み位置を $pos で指定できる。
     * $pos は負数が指定できる。負数の場合後ろから数えられる。
     * 省略した場合は真ん中となる。
     *
     * Example:
     * ```php
     * // 10文字幅に丸める（$pos 省略なので真ん中が省略される）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...'))->isSame('あい...890');
     * // 10文字幅に丸める（$pos=1 なので1幅目から省略される…が、1文字は「あ」なので前方に切られる）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...', 1))->isSame('...567890');
     * // 10文字幅に丸める（$pos=2 なので2幅目から省略される）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...', 2))->isSame('あ...67890');
     * // 10文字幅に丸める（$pos=-1 なので後ろから1幅目から省略される）
     * that(mb_ellipsis('あいうえお1234567890', 10, '...', -1))->isSame('あいう...0');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int $width 丸める幅
     * @param string $trimmarker 省略文字列
     * @param int|null $pos 省略記号の差し込み位置
     * @return string 丸められた文字列
     */
    function mb_ellipsis(?string $string, $width, $trimmarker = '...', $pos = null)
    {
        $strwidth = mb_monospace($string);
        if ($strwidth <= $width) {
            return $string;
        }

        $markerwidth = mb_monospace($trimmarker);
        if ($markerwidth >= $width) {
            return $trimmarker;
        }

        $maxwidth = $width - $markerwidth;
        $pos ??= $maxwidth / 2;
        if ($pos < 0) {
            $pos += $maxwidth;
        }
        $pos = ceil(max(0, min($pos, $maxwidth)));
        $end = $pos + $strwidth - $maxwidth;

        $widths = array_map(fn($s) => mb_monospace($s), mb_str_split($string));
        $s = $e = null;
        $sum = 0;
        foreach ($widths as $n => $w) {
            $sum += $w;
            if (!isset($s) && $sum > $pos) {
                $s = $n;
            }
            if (!isset($e) && $sum >= $end) {
                $e = $n + 1;
            }
        }

        return mb_substr($string, 0, $s) . $trimmarker . mb_substr($string, $e);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_ereg_options') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_ereg_options'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_ereg_options')) {
    /**
     * mb_系の全体設定を一括設定する
     *
     * 返り値として「コールすると元に戻す callable」を返す。
     * あるいはその返り値はスコープが外れると自動で元に戻す処理が行われる。
     *
     * 余計なことはしない素直な実装だが、'encoding' というキーは mb_internal_encoding と regex_encoding の両方に適用される。
     *
     * Example:
     * ```php
     * $recover = mb_ereg_options([
     *     'internal_encoding' => 'SJIS', // 今だけは internal_encoding を SJIS にする
     *     'regex_options'     => 'ir',   // 今だけは regex_options を ir にする
     * ]);
     * that($recover)->isCallable();             // 返り値は callable
     * that(mb_internal_encoding())->is('SJIS'); // 今だけは SJIS
     * that(mb_regex_set_options())->is('ir');   // 今だけは ir
     *
     * $recover();
     * that(mb_internal_encoding())->is('UTF-8'); // $recover をコールすると戻る
     * that(mb_regex_set_options())->is('pr');    // $recover をコールすると戻る
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param array $options オプション配列
     * @return callable 元に戻す callable
     */
    function mb_ereg_options($options)
    {
        $set = static function ($setting) {
            if (strlen((string) $setting['internal_encoding'])) {
                mb_internal_encoding($setting['internal_encoding']);
            }
            if (strlen((string) $setting['substitute_character'])) {
                mb_substitute_character($setting['substitute_character']);
            }
            if (strlen((string) $setting['regex_encoding'])) {
                mb_regex_encoding($setting['regex_encoding']);
            }
            if (strlen((string) $setting['regex_options'])) {
                mb_regex_set_options($setting['regex_options']);
            }
        };

        $backup = [
            'internal_encoding'    => mb_internal_encoding(),
            'substitute_character' => mb_substitute_character(),
            'regex_encoding'       => mb_regex_encoding(),
            'regex_options'        => mb_regex_set_options(),
        ];
        $set([
            'internal_encoding'    => $options['internal_encoding'] ?? $options['encoding'] ?? null,
            'substitute_character' => $options['substitute_character'] ?? null,
            'regex_encoding'       => $options['regex_encoding'] ?? $options['encoding'] ?? null,
            'regex_options'        => $options['regex_options'] ?? null,
        ]);
        return finalize(fn() => $set($backup));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_ereg_split') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_ereg_split'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_ereg_split')) {
    /**
     * マルチバイト対応 preg_split
     *
     * preg_split の PREG_SPLIT_NO_EMPTY, PREG_SPLIT_DELIM_CAPTURE, PREG_SPLIT_OFFSET_CAPTURE も使用できる。
     *
     * Example:
     * ```php
     * # 下記のようにすべて preg_split と合わせてある
     * // limit:2
     * that(mb_ereg_split(",", "a,b,c", 2))->is(['a', 'b,c']);
     * // flags:PREG_SPLIT_NO_EMPTY
     * that(mb_ereg_split(",", ",a,,b,,c,", -1, PREG_SPLIT_NO_EMPTY))->is(['a', 'b', 'c']);
     * // flags:PREG_SPLIT_DELIM_CAPTURE
     * that(mb_ereg_split("(,)", "a,c", -1, PREG_SPLIT_DELIM_CAPTURE))->is(['a', ',', 'c']);
     * // flags:PREG_SPLIT_OFFSET_CAPTURE
     * that(mb_ereg_split(",", "a,b,c", -1, PREG_SPLIT_OFFSET_CAPTURE))->is([['a', 0], ['b', 2], ['c', 4]]);
     * # 他の preg_split 特有の動きも同じ
     * // 例えば limit は PREG_SPLIT_DELIM_CAPTURE には作用しない
     * that(mb_ereg_split("(,)", "a,b,c", 2, PREG_SPLIT_DELIM_CAPTURE))->is(['a', ',', 'b,c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $pattern パターン文字列
     * @param string $subject 対象文字列
     * @param int $limit 分割数
     * @param int $flags フラグ
     * @return ?array 分割された文字列
     */
    function mb_ereg_split(?string $pattern, ?string $subject, $limit = -1, $flags = 0)
    {
        // 是正（奇妙だが preg_split は 0, -1 以外は特別扱いしないようだ（個数が負数になることはないので実質的に 1 指定と同じ））
        if (-1 <= $limit && $limit <= 0) {
            $limit = PHP_INT_MAX;
        }

        // フラグに応じて追加するクロージャ
        $SPLIT_NO_EMPTY = !!($flags & PREG_SPLIT_NO_EMPTY);
        $SPLIT_DELIM_CAPTURE = !!($flags & PREG_SPLIT_DELIM_CAPTURE);
        $SPLIT_OFFSET_CAPTURE = !!($flags & PREG_SPLIT_OFFSET_CAPTURE);
        $result = [];
        $append = function ($part, $offset, $delim) use (&$result, $SPLIT_NO_EMPTY, $SPLIT_DELIM_CAPTURE, $SPLIT_OFFSET_CAPTURE) {
            if ($SPLIT_NO_EMPTY && !strlen($part)) {
                return false;
            }
            if (!$SPLIT_DELIM_CAPTURE && $delim) {
                return false;
            }
            if ($SPLIT_OFFSET_CAPTURE) {
                $result[] = [$part, $offset];
            }
            else {
                $result[] = $part;
            }
            return true;
        };

        // 超特別扱い（mb_ereg は空パターンを許容せず、文字境界での分割ができない。.でバラしてさらに消費しないようにする）
        $empty_pattern = !strlen($pattern);
        if ($empty_pattern) {
            $pattern = '.';
        }

        // 不正ならそこで終わり
        if (!mb_ereg_search_init($subject, $pattern)) {
            return null;
        }

        // マッチしなくなるまでループ（ただし $length を超えた場合は無駄なので break）
        $offset = 0;
        $length = 0;
        while (($pos = mb_ereg_search_pos()) !== false && $length < $limit - 1) {
            // PREG_SPLIT_NO_EMPTY は空文字をカウントしない（極論全て空文字なら最後まで読む）
            $part = substr($subject, $offset, $pos[0] - $offset);
            if ($append($part, $offset, false)) {
                $length++;
            }

            // 空パターンは区切り文字自体は計上しない
            if ($empty_pattern) {
                $offset = $pos[0];
            }
            // 空じゃなければ計上する
            else {
                $offset = $pos[0] + $pos[1];
            }

            // キャプチャパターンも入れておく
            $regs = mb_ereg_search_getregs();
            $all = array_shift($regs);
            $offset2 = $pos[0];
            foreach ($regs as $reg) {
                $append($reg, $offset2, true);
                $offset2 += strlen($reg);
            }

            // マッチしてない場合無限ループになるので強制的に進める（かなりやっつけ。もっといい方法はあるはず）
            if ($all === '') {
                for ($i = 1; $i < strlen($subject); $i++) {
                    $c = substr($subject, $offset, $i);
                    if ($c === '') {
                        break 2;
                    }
                    if (mb_ord($c) !== false && mb_ereg_search_setpos($offset + $i)) {
                        break;
                    }
                }
            }
        }

        // 打ち切った場合にまだ残っていることがある
        $part = substr($subject, $offset);
        $append($part, $offset, false);

        // 空パターンの場合、境界で区切るので preg_split と合わせるため空文字が必要
        if ($empty_pattern) {
            $append("", $offset + strlen($part), false);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_monospace') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_monospace'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_monospace')) {
    /**
     * ASCII 文字を1, それ以外を2で計算した文字幅を返す
     *
     * mb_strwidth は記号も1で返すので若干使いづらい（仕様的にしょうがない）。
     * 日本語圏内であれば記号や絵文字も2バイト換算の方が便利なことが多いのでそのようにしたもの。
     *
     * オプションでコードポイント配列を渡すとそれに従って幅を加算する。
     * コードポイントの指定は Example を参照。
     *
     * Example:
     * ```php
     * that(mb_monospace("※★▼…"))->is(8);     // 記号類も2バイト換算で8
     * that(mb_monospace("123456７8８"))->is(11); // 比較用（フォントに依存するが）
     * that(mb_monospace("Σ(ﾟДﾟ)え!！"))->is(15); // 半角全角の判定ではなく ASCII 判定なので 15
     * that(mb_monospace("Σ(ﾟДﾟ)え!！", [         // コードポイントを指定すれば合わせることが可能
     *     "Σ"    => 1, // 単体指定（シグマ）
     *     "Ѐ-ӿ"  => 1, // 範囲指定（キリル文字）
     *     0xFF9F => 1, // 直指定（半角半濁点）
     * ]))->is(11);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $codepoints コードポイント配列
     * @return int 等幅の文字幅
     */
    function mb_monospace(?string $string, $codepoints = [])
    {
        $widthmap = [];
        foreach ($codepoints as $codepoint => $width) {
            // 数値あるいは数値に準ずる値（intval がややこしくなるのでコードポイント 0 は考慮しない）
            if (is_int($codepoint) || intval($codepoint, 0) !== 0) {
                $widthmap[mb_chr(intval($codepoint, 0))] = $width;
            }
            // 文字列あるいは - による範囲指定
            else {
                // mb_ereg_search_regs が使いにくすぎるので callback で代用している
                $pairs = [];
                $codepoint = mb_ereg_replace_callback('([^-])\-([^-])', function ($m) use (&$pairs) {
                    $pairs[] = [mb_ord($m[1]), mb_ord($m[2])];
                    return '';
                }, $codepoint);
                foreach ($pairs as [$s, $e]) {
                    for ($i = $s; $i <= $e; $i++) {
                        $widthmap[mb_chr($i)] = $width;
                    }
                }
                foreach (mb_str_split($codepoint) as $char) {
                    $widthmap[$char] = $width;
                }
            }
        }

        $width = 0;
        foreach (mb_str_split($string) as $char) {
            if (isset($widthmap[$char])) {
                $width += $widthmap[$char];
            }
            elseif (strlen($char) === 1) {
                $width += 1;
            }
            else {
                $width += 2;
            }
        }
        return $width;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_str_pad') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_str_pad'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_str_pad')) {
    /**
     * マルチバイト版 str_pad
     *
     * 単純な mb_strlen での実装ではなく mb_monospace による実装となっている。
     * 「文字数を指定して pad したい」という状況は utf8 で2バイト超えという状況がふさわしくないことが非常に多い。
     * 多くは単純に「全角は2文字、半角は1文字」というユースケースが多い（埋める文字がスペースなら特に）。
     *
     * また、$pad_string が切り捨てられることもない。
     * 標準の str_pad はできるだけ詰めようとして中途半端な $pad_string になることがあるが、その動作は模倣していない。
     * 端的に「$width を超えないようにできる限り敷き詰めて返す」という動作になる。
     *
     * Example:
     * ```php
     * // マルチバイトは2文字幅として換算される
     * that(mb_str_pad('aaaa', 12, '-'))->isSame('aaaa--------');
     * that(mb_str_pad('ああ', 12, '-'))->isSame('ああ--------');
     * // $pad_string は切り捨てられない
     * that(mb_str_pad('aaaa', 12, 'xyz'))->isSame('aaaaxyzxyz'); // 10文字で返す（あと1回 xyz すると 13 文字になり width を超えてしまう（かといって xy だけを足したりもしない））
     * that(mb_str_pad('ああ', 12, 'xyz'))->isSame('ああxyzxyz'); // マルチバイトでも同じ
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int $width 埋める幅
     * @param string $pad_string 埋める文字列
     * @param int $pad_type 埋める位置
     * @return string 指定文字で埋められた文字列
     */
    function mb_str_pad(?string $string, $width, $pad_string = " ", $pad_type = STR_PAD_RIGHT)
    {
        assert(in_array($pad_type, [STR_PAD_LEFT, STR_PAD_RIGHT, STR_PAD_BOTH]));

        $str_length = mb_monospace($string);
        $pad_length = mb_monospace($pad_string);
        $target_length = intval($width - $str_length);

        if ($pad_length === 0 || $target_length <= 0) {
            return $string;
        }

        $pad_count = $target_length / $pad_length;

        switch ($pad_type) {
            default:
                throw new \InvalidArgumentException("pad_type is invalid($pad_type)"); // @codeCoverageIgnore
            case STR_PAD_BOTH:
                $left = str_repeat($pad_string, floor($pad_count / 2));
                $right = str_repeat($pad_string, floor(($target_length - mb_monospace($left)) / $pad_length));
                return $left . $string . $right;
            case STR_PAD_RIGHT:
                return $string . str_repeat($pad_string, floor($pad_count));
            case STR_PAD_LEFT:
                return str_repeat($pad_string, floor($pad_count)) . $string;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_substr_replace') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_substr_replace'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_substr_replace')) {
    /**
     * マルチバイト対応 substr_replace
     *
     * 本家は配列を与えたりできるが、ややこしいし使う気がしないので未対応。
     *
     * Example:
     * ```php
     * // 2文字目から5文字を「あいうえお」に置換する
     * that(mb_substr_replace('０１２３４５６７８９', 'あいうえお', 2, 5))->isSame('０１あいうえお７８９');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $replacement 置換文字列
     * @param int $start 開始位置
     * @param ?int $length 置換長
     * @return string 置換した文字列
     */
    function mb_substr_replace(?string $string, ?string $replacement, $start, $length = null)
    {
        $strlen = mb_strlen($string);
        if ($start < 0) {
            $start += $strlen;
        }
        if ($length === null) {
            $length = $strlen;
        }
        if ($length < 0) {
            $length += $strlen - $start;
        }

        return mb_substr($string, 0, $start) . $replacement . mb_substr($string, $start + $length);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_trim') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_trim'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_trim')) {
    /**
     * マルチバイト対応 trim
     *
     * Example:
     * ```php
     * that(mb_trim(' 　 あああ　 　'))->isSame('あああ');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @return string trim した文字列
     */
    function mb_trim(?string $string)
    {
        return preg_replace('/\A[\p{C}\p{Z}]++|[\p{C}\p{Z}]++\z/u', '', $string);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\mb_wordwrap') || (new \ReflectionFunction('ryunosuke\\ltsv\\mb_wordwrap'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\mb_wordwrap')) {
    /**
     * 文字列を指定文字幅で改行を挟み込む
     *
     * 基本的に wordwrap のマルチバイト対応版だと思って良い。
     * ただし下記の点が異なる。
     *
     * - マルチバイトは一律2文字換算
     *   - これ系の関数の「幅」はいわゆる半角/全角として扱ったほうが都合が良い
     * - $cut_long_words 引数はない
     *   - 用途的に true がデフォだろうし、マルチバイトが絡んでくると「単語」の定義がそもそも曖昧なので実装しない
     *   - 実装するにしても禁則処理の方が用途は多いだろう
     * - $break に null を与えると配列で返す
     *
     * Example:
     * ```php
     * that(mb_wordwrap("todayは晴天なり", 10, null))->is([
     *     'todayは晴',
     *     '天なり',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 分割する文字列
     * @param int $width 分割する最大幅
     * @param ?string $break 分割文字
     * @return string|array 指定幅で改行が差し込まれた文字列
     */
    function mb_wordwrap(?string $string, $width, $break = "\n")
    {
        $lines = mb_split('\\R', $string);

        $result = [];
        foreach ($lines as $line) {
            $chars = mb_str_split($line);
            $widths = array_map(fn($c) => mb_monospace($c), $chars);

            $sum = 0;
            $buffer = '';
            foreach ($widths as $n => $charwidth) {
                if ($sum + $charwidth > $width) {
                    $result[] = $buffer;
                    $sum = 0;
                    $buffer = '';
                }

                $sum += $charwidth;
                $buffer .= $chars[$n];
            }
            $result[] = $buffer;
        }

        if ($break !== null) {
            $result = implode($break, $result);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\multiexplode') || (new \ReflectionFunction('ryunosuke\\ltsv\\multiexplode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\multiexplode')) {
    /**
     * explode の配列対応と $limit の挙動を変えたもの
     *
     * $delimiter には配列が使える。いわゆる「複数文字列での分割」の動作になる。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // 配列を与えると複数文字列での分割
     * that(multiexplode([',', ' ', '|'], 'a,b c|d'))->isSame(['a', 'b', 'c', 'd']);
     * // 負数を与えると前詰め
     * that(multiexplode(',', 'a,b,c,d', -2))->isSame(['a,b,c', 'd']);
     * // もちろん上記2つは共存できる
     * that(multiexplode([',', ' ', '|'], 'a,b c|d', -2))->isSame(['a,b c', 'd']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array $delimiter 分割文字列。配列可
     * @param string $string 対象文字列
     * @param int $limit 分割数
     * @return array 分割された配列
     */
    function multiexplode($delimiter, ?string $string, $limit = \PHP_INT_MAX)
    {
        $limit = (int) $limit;
        if ($limit < 0) {
            // 下手に php で小細工するよりこうやって富豪的にやるのが一番速かった
            return array_reverse(array_map('strrev', multiexplode($delimiter, strrev($string), -$limit)));
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }
        $delimiter = array_map(fn($v) => preg_quote($v, '#'), arrayize($delimiter));
        return preg_split('#' . implode('|', $delimiter) . '#', $string, $limit);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\namespace_split') || (new \ReflectionFunction('ryunosuke\\ltsv\\namespace_split'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\namespace_split')) {
    /**
     * 文字列を名前空間とローカル名に区切ってタプルで返す
     *
     * class_namespace/class_shorten や function_shorten とほぼ同じだが下記の違いがある。
     *
     * - あくまで文字列として処理する
     *     - 例えば class_namespace は get_class されるが、この関数は（いうなれば） strval される
     * - \\ を trim しないし、特別扱いもしない
     *     - `ns\\hoge` と `\\ns\\hoge` で返り値が微妙に異なる
     *     - `ns\\` のような場合は名前空間だけを返す
     *
     * Example:
     * ```php
     * that(namespace_split('ns\\hoge'))->isSame(['ns', 'hoge']);
     * that(namespace_split('hoge'))->isSame(['', 'hoge']);
     * that(namespace_split('ns\\'))->isSame(['ns', '']);
     * that(namespace_split('\\hoge'))->isSame(['', 'hoge']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @return array [namespace, localname]
     */
    function namespace_split(?string $string)
    {
        $pos = strrpos($string, '\\');
        if ($pos === false) {
            return ['', $string];
        }
        return [substr($string, 0, $pos), substr($string, $pos + 1)];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\ngram') || (new \ReflectionFunction('ryunosuke\\ltsv\\ngram'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\ngram')) {
    /**
     * N-gram 化して配列で返す
     *
     * 素朴な実装であり特記事項はない。
     * 末端要素や除去フィルタくらいは実装するかもしれない。
     *
     * Example:
     * ```php
     * that(ngram("あいうえお", 1))->isSame(["あ", "い", "う", "え", "お"]);
     * that(ngram("あいうえお", 2))->isSame(["あい", "いう", "うえ", "えお", "お"]);
     * that(ngram("あいうえお", 3))->isSame(["あいう", "いうえ", "うえお", "えお", "お"]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int $N N-gram の N
     * @param string $encoding マルチバイトエンコーディング
     * @return array N-gram 配列
     */
    function ngram(?string $string, $N, $encoding = 'UTF-8')
    {
        if (func_num_args() < 3) {
            $encoding = mb_internal_encoding();
        }

        $chars = mb_str_split($string, 1, $encoding);

        $result = [];
        foreach ($chars as $i => $char) {
            $result[] = implode('', array_slice($chars, $i, $N));
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\pascal_case') || (new \ReflectionFunction('ryunosuke\\ltsv\\pascal_case'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\pascal_case')) {
    /**
     * PascalCase に変換する
     *
     * Example:
     * ```php
     * that(pascal_case('this_is_a_pen'))->isSame('ThisIsAPen');
     * that(pascal_case('this_is-a-pen', '-_'))->isSame('ThisIsAPen');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ（複数可）
     * @return string 変換した文字列
     */
    function pascal_case(?string $string, ?string $delimiter = '_')
    {
        $replacemap = array_combine(str_split($delimiter), array_pad([], strlen($delimiter), ' '));
        return strtr(ucwords(strtr($string, $replacemap)), [' ' => '']);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\quoteexplode') || (new \ReflectionFunction('ryunosuke\\ltsv\\quoteexplode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\quoteexplode')) {
    /**
     * エスケープやクオートに対応した explode
     *
     * $enclosures は配列で開始・終了文字が別々に指定できるが、実装上の都合で今のところ1文字ずつのみ。
     *
     * Example:
     * ```php
     * // シンプルな例
     * that(quoteexplode(',', 'a,b,c\\,d,"e,f"'))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     'c\\,d', // \\ でエスケープしているので区切り文字とみなされない
     *     '"e,f"', // "" でクオートされているので区切り文字とみなされない
     * ]);
     *
     * // $enclosures で囲い文字の開始・終了文字を明示できる
     * that(quoteexplode(',', 'a,b,{e,f}', null, ['{' => '}']))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     '{e,f}', // { } で囲まれているので区切り文字とみなされない
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array $delimiter 分割文字列
     * @param string $string 対象文字列
     * @param ?int $limit 分割数。負数未対応
     * @param array|string $enclosures 囲い文字。 ["start" => "end"] で開始・終了が指定できる
     * @param string $escape エスケープ文字
     * @param array $options オプション
     * @return array 分割された配列
     */
    function quoteexplode($delimiter, ?string $string, $limit = null, $enclosures = "'\"", $escape = '\\', $options = [])
    {
        $options += [
            'delim-capture' => false, // デリミタも結果に含まれるようになる
        ];

        if ($limit === null) {
            $limit = PHP_INT_MAX;
        }
        $limit = max(1, $limit);

        $delimiters = arrayize($delimiter);
        $current = 0;
        $result = [];
        for ($i = 0, $l = strlen($string); $i < $l; $i++) {
            if (count($result) === $limit - 1) {
                break;
            }
            $i = strpos_quoted($string, $delimiters, $i, $enclosures, $escape);
            if ($i === null) {
                break;
            }
            foreach ($delimiters as $delimiter) {
                $delimiterlen = strlen($delimiter);
                if (substr_compare($string, $delimiter, $i, $delimiterlen) === 0) {
                    $result[] = substr($string, $current, $i - $current);
                    if ($options['delim-capture']) {
                        $result[] = $delimiter;
                    }
                    $current = $i + $delimiterlen;
                    $i += $delimiterlen - 1;
                    break;
                }
            }
        }
        $result[] = substr($string, $current, $l);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\render_file') || (new \ReflectionFunction('ryunosuke\\ltsv\\render_file'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\render_file')) {
    /**
     * "hoge {$hoge}" 形式のレンダリングのファイル版
     *
     * @package ryunosuke\Functions\Package\strings
     * @see render_string()
     *
     * @param string $template_file レンダリングするファイル名
     * @param array $array レンダリング変数
     * @return string レンダリングされた文字列
     */
    function render_file(?string $template_file, $array)
    {
        return render_string(file_get_contents($template_file), $array);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\render_string') || (new \ReflectionFunction('ryunosuke\\ltsv\\render_string'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\render_string')) {
    /**
     * "hoge {$hoge}" 形式のレンダリング
     *
     * 文字列を eval して "hoge {$hoge}" 形式の文字列に変数を埋め込む。
     * 基本処理は `eval("return '" . addslashes($template) . "';");` と考えて良いが、下記が異なる。
     *
     * - 数値キーが参照できる
     * - クロージャは呼び出し結果が埋め込まれる。引数は (変数配列, 自身のキー文字列)
     * - 引数をそのまま返すだけの特殊な変数 $_ が宣言される
     * - シングルクォートのエスケープは外される
     *
     * $_ が宣言されるのは変数配列に '_' を含んでいないときのみ（上書きを防止するため）。
     * この $_ は php の埋め込み変数の闇を利用するととんでもないことが出来たりする（サンプルやテストコードを参照）。
     *
     * ダブルクオートはエスケープされるので文字列からの脱出はできない。
     * また、 `{$_(syntax(""))}` のように {$_()} 構文で " も使えなくなるので \' を使用しなければならない。
     *
     * Example:
     * ```php
     * // クロージャは呼び出し結果が埋め込まれる
     * that(render_string('$c', ['c' => fn($vars, $k) => $k . '-closure']))->isSame('c-closure');
     * // 引数をそのまま返すだけの特殊な変数 $_ が宣言される
     * that(render_string('{$_(123 + 456)}', []))->isSame('579');
     * // 要するに '$_()' の中に php の式が書けるようになる
     * that(render_string('{$_(implode(\',\', $strs))}', ['strs' => ['a', 'n', 'z']]))->isSame('a,n,z');
     * that(render_string('{$_(max($nums))}', ['nums' => [1, 9, 3]]))->isSame('9');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $template レンダリング文字列
     * @param array $array レンダリング変数
     * @return string レンダリングされた文字列
     */
    function render_string(?string $template, $array)
    {
        // eval 可能な形式に変換
        $evalcode = 'return ' . str_quote($template, [
                'special-character' => [
                    '\\' => '\\\\', // バックスラッシュ
                    '"'  => '\\"',  // 二重引用符
                ],
            ]) . ';';

        // 利便性を高めるために変数配列を少しいじる
        $vars = [];
        foreach ($array as $k => $v) {
            // クロージャはその実行結果を埋め込む仕様
            if ($v instanceof \Closure) {
                $v = $v($array, $k);
            }
            $vars[$k] = $v;
        }
        // '_' はそのまま返すクロージャとする（キーがないときのみ）
        if (!array_key_exists('_', $vars)) {
            $vars['_'] = fn($v) => $v;
        }

        try {
            /** @noinspection PhpMethodParametersCountMismatchInspection */
            return (function () {
                // extract は数値キーを展開してくれないので自前ループで展開
                foreach (func_get_arg(1) as $k => $v) {
                    $$k = $v;
                }
                // 現スコープで宣言してしまっているので伏せなければならない
                unset($k, $v);
                // かと言って変数配列に k, v キーがあると使えなくなるので更に extract で補完
                extract(func_get_arg(1));
                // そして eval. ↑は要するに数値キーのみを展開している
                return eval(func_get_arg(0));
            })($evalcode, $vars);
        }
        catch (\ParseError $ex) {
            throw new \RuntimeException('failed to eval code.' . $evalcode, 0, $ex);
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\render_template') || (new \ReflectionFunction('ryunosuke\\ltsv\\render_template'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\render_template')) {
    /**
     * "hoge ${hoge}" 形式のレンダリング
     *
     * ES6 のテンプレートリテラルのようなもの。
     *
     * - 埋め込みは ${var} のみで、{$var} は無効
     * - ${expression} は「評価結果の変数名」ではなく「評価結果」が埋め込まれる
     *
     * この関数は実験的機能のため、互換性を維持せず変更される可能性がある。
     * また、 token_get_all に頼っているため php9 で `${var}` 構文が廃止されたらおそらく動かない。
     *
     * Example:
     * ```php
     * that(render_template('${max($nums)}', ['nums' => [1, 9, 3]]))->isSame('9');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $template レンダリングする文字列
     * @param array|object $vars レンダリング変数
     * @param callable $tag ブロックと変数値が渡ってくるクロージャ（タグ付きテンプレートリテラルのようなもの）
     * @return string レンダリングされた文字列
     */
    function render_template(?string $template, $vars, $tag = null)
    {
        assert(is_arrayable($vars) || is_array($vars));

        $tag ??= function ($literals, ...$values) {
            $l = max(count($literals), count($values));
            $result = '';
            for ($i = 0; $i < $l; $i++) {
                $result .= ($literals[$i] ?? '') . ($values[$i] ?? '');
            }
            return $result;
        };

        [$blocks, $stmts] = cache("template-$template", function () use ($template) {
            $tokens = array_slice(php_parse("<?php <<<PHPTEMPLATELITERAL\n" . $template . "\nPHPTEMPLATELITERAL;", [
                'backtick' => false,
            ]), 2, -2);
            $last = array_key_last($tokens);
            if ($tokens[$last]->id === T_ENCAPSED_AND_WHITESPACE) {
                $tokens[$last] = clone $tokens[$last];
                $tokens[$last]->text = substr($tokens[$last]->text, 0, -1);
            }

            $blocks = [""];
            $stmts = [];
            for ($i = 0, $l = count($tokens); $i < $l; $i++) {
                if ($tokens[$i]->id === T_DOLLAR_OPEN_CURLY_BRACES) {
                    for ($j = $i + 1; $j < $l; $j++) {
                        if ($tokens[$j]->text === '}') {
                            $blocks[] = "";
                            $stmts[] = array_slice($tokens, $i + 1, $j - $i - 1, true);
                            $i = $j;
                            break;
                        }
                    }
                }
                else {
                    $blocks[count($blocks) - 1] .= strtr_escaped($tokens[$i]->text, ['\$' => '$']);
                }
            }

            array_walk_recursive($stmts, fn(&$token) => $token = (array) $token);
            return [$blocks, $stmts];
        }, __FUNCTION__);

        $values = [];
        foreach ($stmts as $stmt) {
            foreach ($stmt as $n => $subtoken) {
                if ($subtoken['id'] === ord('`')) {
                    $stmt[$n]['text'] = var_export(render_template(substr($subtoken['text'], 1, -1), $vars), true);
                }
                elseif (attr_exists($subtoken['text'], $vars) && ($stmt[$n + 1]['text'] ?? '') !== '(') {
                    $stmt[$n]['text'] = '$' . $subtoken['text'];
                }
            }
            $values[] = phpval(implode('', array_column($stmt, 'text')), (array) $vars);
        }

        return $tag($blocks, ...$values);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\snake_case') || (new \ReflectionFunction('ryunosuke\\ltsv\\snake_case'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\snake_case')) {
    /**
     * snake_case に変換する
     *
     * Example:
     * ```php
     * that(snake_case('ThisIsAPen'))->isSame('this_is_a_pen');
     * that(snake_case('URLEncode', '-'))->isSame('u-r-l-encode');     // デフォルトでは略語も分割される
     * that(snake_case('URLEncode', '-', true))->isSame('url-encode'); // 第3引数 true で略語は維持される
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ
     * @param bool $keep_abbr すべて大文字の単語を1単語として扱うか
     * @return string 変換した文字列
     */
    function snake_case(?string $string, ?string $delimiter = '_', $keep_abbr = false)
    {
        $pattern = $keep_abbr ? '/[A-Z]([A-Z](?![a-z]))*/' : '/[A-Z]/';
        return ltrim(strtolower(preg_replace($pattern, $delimiter . '\0', $string)), $delimiter);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\split_noempty') || (new \ReflectionFunction('ryunosuke\\ltsv\\split_noempty'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\split_noempty')) {
    /**
     * 空文字を除外する文字列分割
     *
     * - 空文字を任意の区切り文字で分割しても常に空配列
     * - キーは連番で返す（歯抜けがないただの配列）
     *
     * $triming を指定した場合、結果配列にも影響する。
     * つまり「除外は trim したいが結果配列にはしたくない」はできない。
     *
     * Example:
     * ```php
     * that(split_noempty(',', 'a, b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c', false))->isSame(['a', ' ', ' ', ' b', ' c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $delimiter 区切り文字
     * @param string $string 対象文字
     * @param string|bool $trimchars 指定した文字を trim する。true を指定すると trim する
     * @return array 指定文字で分割して空文字を除いた配列
     */
    function split_noempty(?string $delimiter, ?string $string, $trimchars = true)
    {
        // trim しないなら preg_split(PREG_SPLIT_NO_EMPTY) で十分
        if (strlen($trimchars) === 0) {
            return preg_split('#' . preg_quote($delimiter, '#') . '#u', $string, -1, PREG_SPLIT_NO_EMPTY);
        }

        // trim するなら preg_split だと無駄にややこしくなるのでベタにやる
        $trim = ($trimchars === true) ? 'trim' : fn($v) => trim($v, $trimchars);
        $parts = explode($delimiter, $string);
        $parts = array_map($trim, $parts);
        $parts = array_filter($parts, 'strlen');
        $parts = array_values($parts);
        return $parts;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\starts_with') || (new \ReflectionFunction('ryunosuke\\ltsv\\starts_with'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\starts_with')) {
    /**
     * 指定文字列で始まるか調べる
     *
     * $with に配列を渡すといずれかで始まるときに true を返す。
     *
     * Example:
     * ```php
     * that(starts_with('abcdef', 'abc'))->isTrue();
     * that(starts_with('abcdef', 'ABC', true))->isTrue();
     * that(starts_with('abcdef', 'xyz'))->isFalse();
     * that(starts_with('abcdef', ['a', 'b', 'c']))->isTrue();
     * that(starts_with('abcdef', ['x', 'y', 'z']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 探される文字列
     * @param string|string[] $with 探す文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 指定文字列で始まるなら true を返す
     */
    function starts_with(?string $string, $with, $case_insensitivity = false)
    {
        foreach ((array) $with as $w) {
            assert(strlen($w));

            if (str_equals(substr($string, 0, strlen($w)), $w, $case_insensitivity)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_anyof') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_anyof'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_anyof')) {
    /**
     * 文字列が候補の中にあるか調べる
     *
     * 候補配列の中に対象文字列があるならそのキーを返す。ないなら null を返す。
     *
     * あくまで文字列としての比較に徹する（in_array/array_search の第3引数は厳密すぎて使いにくいことがある）。
     * ので array_search の文字列特化版とも言える。
     * 動作的には `array_flip($haystack)[$needle] ?? null` と同じ（大文字小文字オプションはあるけど）。
     * ただ array_flip は巨大配列に弱いし、大文字小文字などの融通が効かないので foreach での素朴な実装になっている。
     *
     * Example:
     * ```php
     * that(str_anyof('b', ['a', 'b', 'c']))->isSame(1);       // 見つかったキーを返す
     * that(str_anyof('x', ['a', 'b', 'c']))->isSame(null);    // 見つからないなら null を返す
     * that(str_anyof('C', ['a', 'b', 'c'], true))->isSame(2); // 大文字文字を区別しない
     * that(str_anyof('1', [1, 2, 3]))->isSame(0);             // 文字列の比較に徹する
     * that(str_anyof(2, ['1', '2', '3']))->isSame(1);         // 同上
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param ?string $needle 調べる文字列
     * @param iterable $haystack 候補配列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 候補の中にあるならそのキー。無いなら null
     */
    function str_anyof(?string $needle, $haystack, $case_insensitivity = false)
    {
        $needle ??= '';

        foreach ($haystack as $k => $v) {
            if (!$case_insensitivity && strcmp($needle, $v) === 0) {
                return $k;
            }
            elseif ($case_insensitivity && strcasecmp($needle, $v) === 0) {
                return $k;
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_array') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_array'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_array')) {
    /**
     * 文字列を区切り文字で区切って配列に変換する
     *
     * 典型的には http ヘッダとか sar の結果とかを配列にする。
     *
     * Example:
     * ```php
     * // http response header  を ":" 区切りで連想配列にする
     * that(str_array("
     * HTTP/1.1 200 OK
     * Content-Type: text/html; charset=utf-8
     * Connection: Keep-Alive
     * ", ':', true))->isSame([
     *     'HTTP/1.1 200 OK',
     *     'Content-Type' => 'text/html; charset=utf-8',
     *     'Connection'   => 'Keep-Alive',
     * ]);
     *
     * // sar の結果を " " 区切りで連想配列の配列にする
     * that(str_array("
     * 13:00:01        CPU     %user     %nice   %system   %iowait    %steal     %idle
     * 13:10:01        all      0.99      0.10      0.71      0.00      0.00     98.19
     * 13:20:01        all      0.60      0.10      0.56      0.00      0.00     98.74
     * ", ' ', false))->isSame([
     *     1 => [
     *         '13:00:01' => '13:10:01',
     *         'CPU'      => 'all',
     *         '%user'    => '0.99',
     *         '%nice'    => '0.10',
     *         '%system'  => '0.71',
     *         '%iowait'  => '0.00',
     *         '%steal'   => '0.00',
     *         '%idle'    => '98.19',
     *     ],
     *     2 => [
     *         '13:00:01' => '13:20:01',
     *         'CPU'      => 'all',
     *         '%user'    => '0.60',
     *         '%nice'    => '0.10',
     *         '%system'  => '0.56',
     *         '%iowait'  => '0.00',
     *         '%steal'   => '0.00',
     *         '%idle'    => '98.74',
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array $string 対象文字列。配列を与えても動作する
     * @param string $delimiter 区切り文字
     * @param bool $hashmode 連想配列モードか
     * @return array 配列
     */
    function str_array($string, ?string $delimiter, $hashmode)
    {
        $array = $string;
        if (is_stringable($string)) {
            $array = preg_split('#\R#u', $string, -1, PREG_SPLIT_NO_EMPTY);
        }
        $delimiter = preg_quote($delimiter, '#');

        $result = [];
        if ($hashmode) {
            foreach ($array as $n => $line) {
                $parts = preg_split("#$delimiter#u", $line, 2, PREG_SPLIT_NO_EMPTY);
                $key = isset($parts[1]) ? array_shift($parts) : $n;
                $result[trim($key)] = trim($parts[0]);
            }
        }
        else {
            foreach ($array as $n => $line) {
                $parts = preg_split("#$delimiter#u", $line, -1, PREG_SPLIT_NO_EMPTY);
                if (!isset($keys)) {
                    $keys = $parts;
                    continue;
                }
                $result[$n] = count($keys) === count($parts) ? array_combine($keys, $parts) : null;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_between') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_between'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_between')) {
    /**
     * 指定文字で囲まれた文字列を取得する
     *
     * $from, $to で指定した文字間を取得する（$from, $to 自体は結果に含まれない）。
     * ネストしている場合、一番外側の文字間を返す。
     *
     * $enclosure で「特定文字に囲まれている」場合を無視することができる。
     * $escape で「特定文字が前にある」場合を無視することができる。
     *
     * $position を与えた場合、その場所から走査を開始する。
     * さらに結果があった場合、 $position には「次の走査開始位置」が代入される。
     * これを使用すると連続で「次の文字, 次の文字, ...」と言った動作が可能になる。
     *
     * Example:
     * ```php
     * // $position を利用して "first", "second", "third" を得る（"で囲まれた "blank" は返ってこない）。
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('first');
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('second');
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('third');
     * // ネストしている場合は最も外側を返す
     * that(str_between('{nest1{nest2{nest3}}}', '{', '}'))->isSame('nest1{nest2{nest3}}');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $from 開始文字列
     * @param string $to 終了文字列
     * @param int $position 開始位置。渡した場合次の開始位置が設定される
     * @param string $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @return ?string $from, $to で囲まれた文字。見つからなかった場合は null
     */
    function str_between(?string $string, ?string $from, ?string $to, &$position = 0, $enclosure = '\'"', $escape = '\\')
    {
        $strlen = strlen($string);
        $fromlen = strlen($from);
        $tolen = strlen($to);
        $position = intval($position);
        $nesting = 0;
        $start = null;
        for ($i = $position; $i < $strlen; $i++) {
            $i = strpos_quoted($string, [$from, $to], $i, $enclosure, $escape);
            if ($i === null) {
                break;
            }

            // 開始文字と終了文字が重複している可能性があるので $to からチェックする
            if (substr_compare($string, $to, $i, $tolen) === 0) {
                if (--$nesting === 0) {
                    $position = $i + $tolen;
                    return substr($string, $start, $i - $start);
                }
                // いきなり終了文字が来た場合は無視する
                if ($nesting < 0) {
                    $nesting = 0;
                }
            }
            if (substr_compare($string, $from, $i, $fromlen) === 0) {
                if ($nesting++ === 0) {
                    $start = $i + $fromlen;
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_bytes') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_bytes'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_bytes')) {
    /**
     * 文字列のバイト配列を得る
     *
     * $base 引数で基数を変更できる。
     *
     * Example:
     * ```php
     * // 10進配列で返す
     * that(str_bytes('abc'))->isSame([97, 98, 99]);
     * // 16進配列で返す
     * that(str_bytes('abc', 16))->isSame(["61", "62", "63"]);
     * // マルチバイトで余計なことはしない（php としての文字列のバイト配列をそのまま返す）
     * that(str_bytes('あいう', 16))->isSame(["e3", "81", "82", "e3", "81", "84", "e3", "81", "86"]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int $base 基数
     * @return array 文字のバイト配列
     */
    function str_bytes(?string $string, $base = 10)
    {
        // return array_values(unpack('C*', $string));

        $base = intval($base);
        $strlen = strlen($string);
        $result = [];
        for ($i = 0; $i < $strlen; $i++) {
            $ord = ord($string[$i]);
            if ($base !== 10) {
                $ord = base_convert($ord, 10, $base);
            }
            $result[] = $ord;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_chop') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_chop'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_chop')) {
    /**
     * 先頭・末尾の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列と拡張子を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_chop("$PATH/hoge.php", "$PATH/", '.php'))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $prefix 削ぎ落とす先頭文字列
     * @param string $suffix 削ぎ落とす末尾文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_chop(?string $string, ?string $prefix = '', ?string $suffix = '', $case_insensitivity = false)
    {
        $pattern = [];
        if (strlen($prefix)) {
            $pattern[] = '(\A' . preg_quote($prefix, '#') . ')';
        }
        if (strlen($suffix)) {
            $pattern[] = '(' . preg_quote($suffix, '#') . '\z)';
        }
        $flag = 'u' . ($case_insensitivity ? 'i' : '');
        return preg_replace('#' . implode('|', $pattern) . '#' . $flag, '', $string);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_chunk') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_chunk'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_chunk')) {
    /**
     * 文字列を可変引数の数で分割する
     *
     * str_split の $length を個別に指定できるイメージ。
     * 長さ以上を指定したりしても最後の要素は必ずついてくる（指定数で分割した後のあまり文字が最後の要素になる）。
     * これは最後が空文字でも同様で、 list での代入を想定しているため。
     *
     * Example:
     * ```php
     * // 1, 2, 3 文字に分割（ぴったりなので変わったことはない）
     * that(str_chunk('abcdef', 1, 2, 3))->isSame(['a', 'bc', 'def', '']);
     * // 2, 3 文字に分割（余った f も最後の要素として含まれてくる）
     * that(str_chunk('abcdef', 2, 3))->isSame(['ab', 'cde', 'f']);
     * // 1, 10 文字に分割
     * that(str_chunk('abcdef', 1, 10))->isSame(['a', 'bcdef', '']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int ...$chunks 分割の各文字数（可変引数）
     * @return string[] 分割された文字列配列
     */
    function str_chunk(?string $string, ...$chunks)
    {
        $offset = 0;
        $length = strlen($string);
        $result = [];
        foreach ($chunks as $chunk) {
            if ($offset >= $length) {
                break;
            }
            $result[] = substr($string, $offset, $chunk);
            $offset += $chunk;
        }
        $result[] = substr($string, $offset);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_common_prefix') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_common_prefix'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_common_prefix')) {
    /**
     * 文字列群の共通のプレフィックスを返す
     *
     * 共通部分がない場合は空文字を返す。
     * 引数は2個以上必要で足りない場合は null を返す。
     *
     * Example:
     * ```php
     * // 共通プレフィックスを返す
     * that(str_common_prefix('ab', 'abc', 'abcd'))->isSame('ab');
     * that(str_common_prefix('あ', 'あい', 'あいう'))->isSame('あ');
     * // 共通部分がない場合は空文字を返す
     * that(str_common_prefix('xab', 'yabc', 'zabcd'))->isSame('');
     * that(str_common_prefix('わあ', 'をあい', 'んあいう'))->isSame('');
     * // 引数不足の場合は null を返す
     * that(str_common_prefix('a'))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string[] $strings
     * @return ?string 共通部分（共通がない場合は空文字）
     */
    function str_common_prefix(?string ...$strings)
    {
        if (count($strings) < 2) {
            return null;
        }

        $n = 0;
        $result = '';
        $arrays = array_map(fn($string) => mb_str_split($string), $strings);
        foreach (array_intersect_assoc(...$arrays) as $i => $c) {
            if ($i !== $n++) {
                break;
            }
            $result .= $c;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_control_apply') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_control_apply'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_control_apply')) {
    /**
     * 制御文字を実際に適用させる
     *
     * とはいえ文字列として適用できる制御文字はそう多くはなく、実質的に \b くらいだろう。
     *
     * - \b: 前の1文字を消して自身も消える
     * - \d: 次の\d以外の1文字を消して自身も消える
     *   - 前方探索なので利便性のため「\d以外の」という条件がついている
     * - \r: 直前の \n から直後の \n までを消す
     *   - \r に「消す」という意味はないが、実用上はその方が便利なことが多い
     *
     * なお、 \b と書いてあるが php のエスケープシーケンスに \b は存在しないため \x08 と記述する必要がある（\d も同様）。
     * それはそれで不便なので \b, \d は特別扱いとしてある（$characters のデフォルト値に潜ませてあるが、それを外せば特別扱いは無くなる）。
     *
     * Example:
     * ```php
     * // 最初の X は [BS] で消える・次の X は [DEL] で消える、XXX は [CR] で消える。結果 text\nzzz になる
     * that(str_control_apply("X\b\dXtext\nXXX\rzzz"))->isSame("text\nzzz");
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $characters 対象とする制御文字
     * @return string 制御文字が適用された文字列
     */
    function str_control_apply(string $string, string $characters = "\b\x08\d\x7f\r"): string
    {
        $remap = [];
        if (strpos_escaped($characters, "\b") !== null) {
            $remap["\b"] = "\x08";
        }
        if (strpos_escaped($characters, "\d") !== null) {
            $remap["\d"] = "\x7f";
        }
        $string = strtr_escaped($string, $remap);
        $characters = strtr_escaped($characters, $remap);

        $offset = 0;
        while (true) {
            $pos = strcspn($string, $characters, $offset) + $offset;
            $control = $string[$pos] ?? null;
            if ($control === null) {
                break;
            }
            if ($control === "\x08") {
                if ($pos === 0) {
                    $string = substr_replace($string, '', $pos, 1);
                    $offset = $pos;
                }
                else {
                    $string = substr_replace($string, '', $pos - 1, 2);
                    $offset = $pos - 1;
                }
            }
            if ($control === "\x7f") {
                $next = strspn($string, "\x7f", $pos) + $pos;
                $string = substr_replace($string, '', $next, 1);
                $string = substr_replace($string, '', $pos, 1);
                $offset = $pos;
            }
            if ($control === "\x0d") {
                $prev = strposr($string, "\x0a", $pos);
                if ($prev === false) {
                    $string = substr_replace($string, '', 0, $pos + 1);
                    $offset = 0;
                }
                else {
                    $string = substr_replace($string, '', $prev + 1, $pos - $prev);
                    $offset = $prev + 1;
                }
            }
        }
        return $string;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_diff') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_diff'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_diff')) {
    /**
     * テキストの diff を得る
     *
     * `$options['allow-binary']` でバイナリ文字列の扱いを指定する（false: 例外, null: null を返す）。
     * `$options['ignore-case'] = true` で大文字小文字を無視する。
     * `$options['ignore-space-change'] = true` で空白文字の数を無視する。
     * `$options['ignore-all-space'] = true` ですべての空白文字を無視する
     * `$options['stringify']` で差分データを文字列化するクロージャを指定する。
     *
     * - normal: 標準形式（diff のオプションなしに相当する）
     * - context: コンテキスト形式（context=3 のような形式で diff の -C 3 に相当する）
     * - unified: ユニファイド形式（unified=3 のような形式で diff の -U 3 に相当する）
     *     - unified のみを指定するとヘッダを含まない +- のみの差分を出す
     * - split: サイドバイサイド形式（split=3,120 のような形式で diff の -y -W 120 に相当する）
     *     - diff -y と互換性はなく、あくまでそれっぽくしているのみ
     * - html: ins, del の html タグ形式
     *     - html=perline とすると行レベルでの差分も出す
     *
     * Example:
     * ```php
     * // 前文字列
     * $old = 'same
     * delete
     * same
     * same
     * change
     * ';
     * // 後文字列
     * $new = 'same
     * same
     * append
     * same
     * this is changed line
     * ';
     * // シンプルな差分テキストを返す
     * that(str_diff($old, $new))->isSame(' same
     * -delete
     *  same
     * +append
     *  same
     * -change
     * +this is changed line
     * ');
     * // html で差分を返す
     * that(str_diff($old, $new, ['stringify' => 'html']))->isSame('same
     * <del>delete</del>
     * same
     * <ins>append</ins>
     * same
     * <del>change</del>
     * <ins>this is changed line</ins>
     * ');
     * // 行レベルの html で差分を返す
     * that(str_diff($old, $new, ['stringify' => 'html=perline']))->isSame('same
     * <del>delete</del>
     * same
     * <ins>append</ins>
     * same
     * <ins>this is </ins>chang<ins>ed lin</ins>e
     * ');
     * // raw な配列で差分を返す
     * that(str_diff($old, $new, ['stringify' => null]))->isSame([
     *     // 等価行（'=' という記号と前後それぞれの文字列を返す（キーは行番号））
     *     ['=', [0 => 'same'], [0 => 'same']],
     *     // 削除行（'-' という記号と前の文字列を返す（キーは行番号）、後は int で行番号のみ）
     *     ['-', [1 => 'delete'], 0],
     *     // 等価行
     *     ['=', [2 => 'same'], [1 => 'same']],
     *     // 追加行（'+' という記号と後の文字列を返す（キーは行番号）、前は int で行番号のみ）
     *     ['+', 2, [2 => 'append']],
     *     // 等価行
     *     ['=', [3 => 'same'], [3 => 'same']],
     *     // 変更行（'*' という記号と前後それぞれの文字列を返す（キーは行番号））
     *     ['*', [4 => 'change'], [4 => 'this is changed line']],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array|resource $xstring 元文字列
     * @param string|array|resource $ystring 比較文字列
     * @param array $options オプション配列
     * @return string|array|null 差分テキスト。 stringify が null の場合は raw な差分配列
     */
    function str_diff($xstring, $ystring, $options = [])
    {
        $differ = new class($options) {
            private $options;
            private $recover;

            public function __construct($options)
            {
                $options += [
                    'allow-binary'        => true,
                    'ignore-case'         => false,
                    'ignore-space-change' => false,
                    'ignore-all-space'    => false,
                    'stringify'           => 'unified',
                ];
                $this->options = $options;

                $this->recover = mb_ereg_options([
                    'encoding'      => $options['encoding'] ?? null,
                    'regex_options' => 'r',
                ]);
            }

            public function __invoke($xstring, $ystring)
            {
                $arrayize = function ($string) {
                    $binary_check = function (?string $string) {
                        if ($this->options['allow-binary'] === true || !preg_match('#\0#', $string)) {
                            return $string;
                        }
                        throw new \InvalidArgumentException('detected binary string');
                    };

                    if (is_resource($string)) {
                        $array = [];
                        while (!feof($string)) {
                            $array[] = $binary_check(rtrim(fgets($string), "\r\n"));
                        }
                        return $array;
                    }
                    if (is_array($string)) {
                        return array_values(array_map($binary_check, $string));
                    }
                    return mb_split('\\R', $binary_check($string));
                };

                try {
                    $xarray = $arrayize($xstring);
                    $yarray = $arrayize($ystring);
                }
                catch (\InvalidArgumentException $ex) {
                    if ($this->options['allow-binary'] === false) {
                        throw $ex;
                    }
                    return null;
                }

                $trailingN = "";
                if ($xarray[count($xarray) - 1] === '' && $yarray[count($yarray) - 1] === '') {
                    $trailingN = "\n";
                    array_pop($xarray);
                    array_pop($yarray);
                }

                $diffs = $this->diff($xarray, $yarray);

                $stringfy = $this->options['stringify'];
                if (!$stringfy) {
                    return $diffs;
                }
                if ($stringfy === 'normal') {
                    $stringfy = [$this, 'normal'];
                }
                if (is_string($stringfy) && preg_match('#context(=(\d+))?#', $stringfy, $m)) {
                    $block_size = (int) ($m[2] ?? 3);
                    $stringfy = [$this, 'context'];
                }
                if (is_string($stringfy) && preg_match('#unified(=(\d+))?#', $stringfy, $m)) {
                    $block_size = isset($m[2]) ? (int) $m[2] : null;
                    $stringfy = fn($diff) => $this->unified($diff, $block_size);
                }
                if (is_string($stringfy) && preg_match('#split(=(\d+),?(\d+)?)?#', $stringfy, $m)) {
                    $block_size = (int) ($m[2] ?? 3);
                    $column_size = (int) ($m[3] ?? 100);
                    $stringfy = fn($diff) => $this->split($diff, $column_size);
                }
                if (is_string($stringfy) && preg_match('#html(=(.+))?#', $stringfy, $m)) {
                    $mode = $m[2] ?? null;
                    $stringfy = fn($diff) => $this->html($diff, $mode);
                }

                if (isset($block_size)) {
                    $result = implode("\n", array_map($stringfy, $this->block($diffs, $block_size)));
                }
                else {
                    $result = $stringfy($diffs);
                }

                return !strlen($result) ? $result : $result . $trailingN;
            }

            private function diff(array $xarray, array $yarray)
            {
                $convert = function ($string) {
                    if ($this->options['ignore-case']) {
                        $string = strtoupper($string);
                    }
                    if ($this->options['ignore-space-change']) {
                        $string = mb_ereg_replace('\\s+', ' ', $string);
                    }
                    if ($this->options['ignore-all-space']) {
                        $string = mb_ereg_replace('\\s+', '', $string);
                    }
                    return $string;
                };
                $xarray2 = array_map($convert, $xarray);
                $yarray2 = array_map($convert, $yarray);
                $xcount = count($xarray2);
                $ycount = count($yarray2);

                $head = [];
                reset($yarray2);
                foreach ($xarray2 as $xk => $xv) {
                    $yk = key($yarray2);
                    if ($yk !== $xk || $xv !== $yarray2[$xk]) {
                        break;
                    }
                    $head[$xk] = $xv;
                    unset($xarray2[$xk], $yarray2[$xk]);
                }

                $tail = [];
                end($xarray2);
                end($yarray2);
                do {
                    $xk = key($xarray2);
                    $yk = key($yarray2);
                    if (null === $xk || null === $yk || current($xarray2) !== current($yarray2)) {
                        break;
                    }
                    prev($xarray2);
                    prev($yarray2);
                    $tail = [$xk - $xcount => $xarray2[$xk]] + $tail;
                    unset($xarray2[$xk], $yarray2[$yk]);
                } while (true);

                $common = $this->lcs(array_values($xarray2), array_values($yarray2));

                $xchanged = $ychanged = [];
                foreach ($head as $n => $line) {
                    $xchanged[$n] = false;
                    $ychanged[$n] = false;
                }
                foreach ($common as $line) {
                    foreach ($xarray2 as $n => $l) {
                        unset($xarray2[$n]);
                        $xchanged[$n] = $line !== $l;
                        if (!$xchanged[$n]) {
                            break;
                        }
                    }
                    foreach ($yarray2 as $n => $l) {
                        unset($yarray2[$n]);
                        $ychanged[$n] = $line !== $l;
                        if (!$ychanged[$n]) {
                            break;
                        }
                    }
                }
                foreach ($xarray2 as $n => $line) {
                    $xchanged[$n] = true;
                }
                foreach ($yarray2 as $n => $line) {
                    $ychanged[$n] = true;
                }
                foreach ($tail as $n => $line) {
                    $xchanged[$n + $xcount] = false;
                    $ychanged[$n + $ycount] = false;
                }

                $diffs = [];
                $xi = $yi = 0;
                while ($xi < $xcount || $yi < $ycount) {
                    for ($xequal = [], $yequal = []; $xi < $xcount && $yi < $ycount && !$xchanged[$xi] && !$ychanged[$yi]; $xi++, $yi++) {
                        $xequal[$xi] = $xarray[$xi];
                        $yequal[$yi] = $yarray[$yi];
                    }
                    for ($delete = []; $xi < $xcount && $xchanged[$xi]; $xi++) {
                        $delete[$xi] = $xarray[$xi];
                    }
                    for ($append = []; $yi < $ycount && $ychanged[$yi]; $yi++) {
                        $append[$yi] = $yarray[$yi];
                    }

                    if ($xequal && $yequal) {
                        $diffs[] = ['=', $xequal, $yequal];
                    }
                    if ($delete && $append) {
                        $diffs[] = ['*', $delete, $append];
                    }
                    elseif ($delete) {
                        $diffs[] = ['-', $delete, $yi - 1];
                    }
                    elseif ($append) {
                        $diffs[] = ['+', $xi - 1, $append];
                    }
                }
                return $diffs;
            }

            private function lcs(array $xarray, array $yarray)
            {
                $xcount = count($xarray);
                $ycount = count($yarray);
                if ($xcount === 0) {
                    return [];
                }
                if ($xcount === 1) {
                    if (in_array($xarray[0], $yarray, true)) {
                        return [$xarray[0]];
                    }
                    return [];
                }
                $i = (int) ($xcount / 2);
                $xprefix = array_slice($xarray, 0, $i);
                $xsuffix = array_slice($xarray, $i);
                $llB = $this->length($xprefix, $yarray);
                $llE = $this->length(array_reverse($xsuffix), array_reverse($yarray));
                $jMax = 0;
                $max = 0;
                for ($j = 0; $j <= $ycount; $j++) {
                    $m = $llB[$j] + $llE[$ycount - $j];
                    if ($m >= $max) {
                        $max = $m;
                        $jMax = $j;
                    }
                }
                $yprefix = array_slice($yarray, 0, $jMax);
                $ysuffix = array_slice($yarray, $jMax);
                return array_merge($this->lcs($xprefix, $yprefix), $this->lcs($xsuffix, $ysuffix));
            }

            private function length(array $xarray, array $yarray)
            {
                $xcount = count($xarray);
                $ycount = count($yarray);
                $current = array_fill(0, $ycount + 1, 0);
                for ($i = 0; $i < $xcount; $i++) {
                    $prev = $current;
                    for ($j = 0; $j < $ycount; $j++) {
                        $current[$j + 1] = $xarray[$i] === $yarray[$j] ? $prev[$j] + 1 : max($current[$j], $prev[$j + 1]);
                    }
                }
                return $current;
            }

            private function minmaxlen($diffs)
            {
                $xmin = $ymin = PHP_INT_MAX;
                $xmax = $ymax = -1;
                $xlen = $ylen = 0;
                foreach ($diffs as $diff) {
                    $xargs = (is_array($diff[1]) ? array_keys($diff[1]) : [$diff[1]]);
                    $yargs = (is_array($diff[2]) ? array_keys($diff[2]) : [$diff[2]]);
                    $xmin = min($xmin, ...$xargs);
                    $ymin = min($ymin, ...$yargs);
                    $xmax = max($xmax, ...$xargs);
                    $ymax = max($ymax, ...$yargs);
                    $xlen += is_array($diff[1]) ? count($diff[1]) : 0;
                    $ylen += is_array($diff[2]) ? count($diff[2]) : 0;
                }
                if ($xmin === -1 && $xlen > 0) {
                    $xmin = 0;
                }
                if ($ymin === -1 && $ylen > 0) {
                    $ymin = 0;
                }
                return [$xmin + 1, $xmax + 1, $xlen, $ymin + 1, $ymax + 1, $ylen];
            }

            private function normal($diffs)
            {
                $index = function ($v) {
                    if (!is_array($v)) {
                        return $v + 1;
                    }
                    $keys = array_keys($v);
                    $s = reset($keys) + 1;
                    $e = end($keys) + 1;
                    return $s === $e ? "$s" : "$s,$e";
                };

                $rule = [
                    '+' => ['a', [2 => '> ']],
                    '-' => ['d', [1 => '< ']],
                    '*' => ['c', [1 => '< ', 2 => '> ']],
                ];
                $result = [];
                foreach ($diffs as $diff) {
                    if (isset($rule[$diff[0]])) {
                        $difftext = [];
                        foreach ($rule[$diff[0]][1] as $n => $sign) {
                            /** @noinspection PhpIllegalArrayKeyTypeInspection */
                            $difftext[] = implode("\n", array_map(fn($v) => $sign . $v, $diff[$n]));
                        }
                        $result[] = "{$index($diff[1])}{$rule[$diff[0]][0]}{$index($diff[2])}";
                        $result[] = implode("\n---\n", $difftext);
                    }
                }
                return implode("\n", $result);
            }

            private function context($diffs)
            {
                [$xmin, $xmax, , $ymin, $ymax,] = $this->minmaxlen($diffs);
                $xheader = $xmin === $xmax ? "$xmin" : "$xmin,$xmax";
                $yheader = $ymin === $ymax ? "$ymin" : "$ymin,$ymax";

                $rules = [
                    '-*' => [
                        'header' => "*** {$xheader} ****",
                        '-'      => [1 => '- '],
                        '*'      => [1 => '! '],
                        '='      => [1 => '  '],
                    ],
                    '+*' => [
                        'header' => "--- {$yheader} ----",
                        '+'      => [2 => '+ '],
                        '*'      => [2 => '! '],
                        '='      => [2 => '  '],
                    ],
                ];
                $result = ["***************"];
                foreach ($rules as $key => $rule) {
                    $result[] = $rule['header'];
                    if (array_filter($diffs, fn($d) => strpos($key, $d[0]) !== false)) {
                        foreach ($diffs as $diff) {
                            foreach ($rule[$diff[0]] ?? [] as $n => $sign) {
                                $result[] = implode("\n", array_map(fn($v) => $sign . $v, $diff[$n]));
                            }
                        }
                    }
                }
                return implode("\n", $result);
            }

            private function unified($diffs, $block_size)
            {
                $result = [];

                if ($block_size !== null) {
                    [$xmin, , $xlen, $ymin, , $ylen] = $this->minmaxlen($diffs);
                    $xheader = $xlen === 1 ? "$xmin" : "$xmin,$xlen";
                    $yheader = $ylen === 1 ? "$ymin" : "$ymin,$ylen";
                    $result[] = "@@ -{$xheader} +{$yheader} @@";
                }

                $rule = [
                    '+' => [2 => '+'],
                    '-' => [1 => '-'],
                    '*' => [1 => '-', 2 => '+'],
                    '=' => [1 => ' '],
                ];
                foreach ($diffs as $diff) {
                    foreach ($rule[$diff[0]] as $n => $sign) {
                        $result[] = implode("\n", array_map(fn($v) => $sign . $v, $diff[$n]));
                    }
                }
                return implode("\n", $result);
            }

            private function split($diffs, $column_size)
            {
                $columns = floor(($column_size - 3) / 2);

                $result = [];

                $rules = [
                    '+' => ['>', 1 => null, 2 => 2],
                    '-' => ['<', 1 => 1, 2 => null],
                    '*' => ['*', 1 => 1, 2 => 2],
                    '=' => ['|', 1 => 1, 2 => 2],
                ];
                foreach ($diffs as $diff) {
                    $rule = $rules[$diff[0]];
                    foreach (array_zip($diff[$rule[1]] ?? [], $diff[$rule[2]] ?? []) as $d) {
                        $d0 = mb_wordwrap($d[0] ?? '', $columns, null);
                        $d1 = mb_wordwrap($d[1] ?? '', $columns, null);
                        foreach (array_zip($d0, $d1) as $n => $dd) {
                            $gutter = $n === 0 ? $rule[0] : " ";
                            $result[] = mb_str_pad($dd[0] ?? '', $columns) . " $gutter " . $dd[1] ?? '';
                        }
                    }
                }
                return implode("\n", $result);
            }

            private function html($diffs, $mode)
            {
                $htmlescape = function ($v) use (&$htmlescape) { return is_array($v) ? array_map($htmlescape, $v) : htmlspecialchars($v, ENT_QUOTES); };
                $taging = fn($tag, $content) => strlen($tag) && strlen($content) ? "<$tag>$content</$tag>" : $content;

                $rule = [
                    '+' => [2 => 'ins'],
                    '-' => [1 => 'del'],
                    '*' => [1 => 'del', 2 => 'ins'],
                    '=' => [1 => ''],
                ];
                $result = [];
                foreach ($diffs as $diff) {
                    if ($mode === 'perline' && $diff[0] === '*') {
                        $length = min(count($diff[1]), count($diff[2]));
                        $delete = array_splice($diff[1], 0, $length, []);
                        $append = array_splice($diff[2], 0, $length, []);
                        for ($i = 0; $i < $length; $i++) {
                            $options2 = ['stringify' => null] + $this->options;
                            $diffs2 = str_diff(preg_split('/(?<!^)(?!$)/u', $delete[$i]), preg_split('/(?<!^)(?!$)/u', $append[$i]), $options2);
                            //$diffs2 = str_diff(mb_split('(?<!^)(?!$)', $delete[$i]), mb_split('(?<!^)(?!$)', $append[$i]), $options2);
                            $result2 = [];
                            foreach ($diffs2 as $diff2) {
                                foreach ($rule[$diff2[0]] as $n => $tag) {
                                    $content = $taging($tag, implode("", (array) $htmlescape($diff2[$n])));
                                    if (strlen($content)) {
                                        $result2[] = $content;
                                    }
                                }
                            }
                            $result[] = implode("", $result2);
                        }
                    }
                    foreach ($rule[$diff[0]] as $n => $tag) {
                        $content = $taging($tag, implode("\n", (array) $htmlescape($diff[$n])));
                        if ($diff[0] === '=' && !strlen($content)) {
                            $result[] = "";
                        }
                        if (strlen($content)) {
                            $result[] = $content;
                        }
                    }
                }
                return implode("\n", $result);
            }

            private function block($diffs, $block_size)
            {
                $head = fn($array) => array_slice($array, 0, $block_size, true);
                $tail = fn($array) => array_slice($array, -$block_size, null, true);

                $blocks = [];
                $block = [];
                $last = count($diffs) - 1;
                foreach ($diffs as $n => $diff) {
                    if ($diff[0] !== '=') {
                        $block[] = $diff;
                        continue;
                    }

                    if (!$block) {
                        if ($block_size) {
                            $block[] = ['=', $tail($diff[1]), $tail($diff[2])];
                        }
                    }
                    elseif ($last === $n) {
                        if ($block_size) {
                            $block[] = ['=', $head($diff[1]), $head($diff[2])];
                        }
                    }
                    elseif (count($diff[1]) > $block_size * 2) {
                        if ($block_size) {
                            $block[] = ['=', $head($diff[1]), $head($diff[2])];
                        }
                        $blocks[] = $block;
                        $block = [];
                        if ($block_size) {
                            $block[] = ['=', $tail($diff[1]), $tail($diff[2])];
                        }
                    }
                    else {
                        if ($block_size) {
                            $block[] = $diff;
                        }
                    }
                }
                if (trim(implode('', array_column($block, 0)), '=')) {
                    $blocks[] = $block;
                }
                return $blocks;
            }
        };

        return $differ($xstring, $ystring);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_ellipsis') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_ellipsis'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_ellipsis')) {
    /**
     * 文字列を指定数に丸める
     *
     * mb_strimwidth と似ているが、省略文字の差し込み位置を $pos で指定できる。
     * $pos は負数が指定できる。負数の場合後ろから数えられる。
     * 省略した場合は真ん中となる。
     *
     * Example:
     * ```php
     * // 8文字に丸める（$pos 省略なので真ん中が省略される）
     * that(str_ellipsis('1234567890', 8, '...'))->isSame('12...890');
     * // 8文字に丸める（$pos=1 なので1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', 1))->isSame('1...7890');
     * // 8文字に丸める（$pos=-1 なので後ろから1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', -1))->isSame('1234...0');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int $width 丸める幅
     * @param string $trimmarker 省略文字列
     * @param int|null $pos 省略記号の差し込み位置
     * @return string 丸められた文字列
     */
    function str_ellipsis(?string $string, $width, $trimmarker = '...', $pos = null)
    {
        $strlen = mb_strlen($string);
        if ($strlen <= $width) {
            return $string;
        }

        $markerlen = mb_strlen($trimmarker);
        if ($markerlen >= $width) {
            return $trimmarker;
        }

        $length = $width - $markerlen;
        $pos ??= (int) ($length / 2);
        if ($pos < 0) {
            $pos += $length;
        }
        $pos = max(0, min($pos, $length));

        return mb_substr_replace($string, $trimmarker, $pos, $strlen - $length);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_embed') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_embed'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_embed')) {
    /**
     * エスケープ付きで文字列を置換する
     *
     * $replacemap で from -> to 文字列を指定する。
     * to は文字列と配列とクロージャを受け付ける。
     * 文字列の場合は普通に想起される動作で単純な置換となる。
     * 配列の場合は順次置換していく。要素が足りなくなったら例外を投げる。
     * クロージャの場合は(from, from 内の連番, トータル置換回数)でコールバックされる。null を返すと置換されない。
     *
     * strtr と同様、最も長いキーから置換を行い、置換後の文字列は対象にならない。
     *
     * $enclosure で「特定文字に囲まれている」場合を無視することができる。
     * $escape で「特定文字が前にある」場合を無視することができる。
     *
     * Example:
     * ```php
     * // 最も単純な置換
     * that(str_embed('a, b, c', ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isSame('A, B, C');
     * // 最も長いキーから置換される
     * that(str_embed('abc', ['a' => 'X', 'ab' => 'AB']))->isSame('ABc');
     * // 配列を渡すと「N番目の置換」が実現できる（文字列の場合は再利用される）
     * that(str_embed('a, a, b, b', [
     *     'a' => 'A',          // 全ての a が A になる
     *     'b' => ['B1', 'B2'], // 1番目の b が B1, 2番目の b が B2 になる
     * ]))->isSame('A, A, B1, B2');
     * // クロージャを渡すと(from, from 内の連番, トータル置換回数)でコールバックされる
     * that(str_embed('a, a, b, b', [
     *     'a' => fn($src, $n, $l) => "$src,$n,$l",
     *     'b' => fn($src, $n, $l) => null,
     * ]))->isSame('a,0,0, a,1,1, b, b');
     * // 最も重要な性質として "' で囲まれていると対象にならない
     * that(str_embed('a, "a", b, "b", b', [
     *     'a' => 'A',
     *     'b' => ['B1', 'B2'],
     * ]))->isSame('A, "a", B1, "b", B2');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $replacemap 置換文字列
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @param ?array $replaced 置換されたペアがタプルで格納される
     * @return string 置換された文字列
     */
    function str_embed(?string $string, $replacemap, $enclosure = "'\"", $escape = '\\', &$replaced = null)
    {
        assert(is_iterable($replacemap));

        // 長いキーから処理するためソートしておく
        $replacemap = arrayval($replacemap, false);
        uksort($replacemap, fn($a, $b) => strlen($b) - strlen($a));
        $srcs = array_keys($replacemap);

        $replaced = [];

        $counter = array_fill_keys(array_keys($replacemap), 0);
        for ($i = 0; $i < strlen($string); $i++) {
            $i = strpos_quoted($string, $srcs, $i, $enclosure, $escape);
            if ($i === null) {
                break;
            }

            foreach ($replacemap as $src => $dst) {
                $srclen = strlen($src);
                if ($srclen === 0) {
                    throw new \InvalidArgumentException("src length is 0.");
                }
                if (substr_compare($string, $src, $i, $srclen) === 0) {
                    $n = $counter[$src]++;
                    if ($dst instanceof \Closure) {
                        $dst = $dst($src, $n, count($replaced));
                        if ($dst === null) {
                            continue;
                        }
                    }
                    if (is_array($dst)) {
                        if (!isset($dst[$n])) {
                            throw new \InvalidArgumentException("notfound search string '$src' of {$n}th.");
                        }
                        $dst = $dst[$n];
                    }
                    $replaced[] = [$src, $dst];
                    $string = substr_replace($string, $dst, $i, $srclen);
                    $i += strlen($dst) - 1;
                    break;
                }
            }
        }
        return $string;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_equals') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_equals'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_equals')) {
    /**
     * 文字列比較の関数版
     *
     * 文字列以外が与えられた場合は常に false を返す。ただし __toString を実装したオブジェクトは別。
     *
     * Example:
     * ```php
     * that(str_equals('abc', 'abc'))->isTrue();
     * that(str_equals('abc', 'ABC', true))->isTrue();
     * that(str_equals('\0abc', '\0abc'))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $str1 文字列1
     * @param string $str2 文字列2
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 同じ文字列なら true
     */
    function str_equals($str1, $str2, $case_insensitivity = false)
    {
        // __toString 実装のオブジェクトは文字列化する（strcmp がそうなっているから）
        if (is_object($str1) && method_exists($str1, '__toString')) {
            $str1 = (string) $str1;
        }
        if (is_object($str2) && method_exists($str2, '__toString')) {
            $str2 = (string) $str2;
        }

        // この関数は === の関数版という位置づけなので例外は投げないで不一致とみなす
        if (!is_string($str1) || !is_string($str2)) {
            return false;
        }

        if ($case_insensitivity) {
            return strcasecmp($str1, $str2) === 0;
        }

        return $str1 === $str2;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_exists') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_exists')) {
    /**
     * 指定文字列を含むか返す
     *
     * Example:
     * ```php
     * that(str_exists('abc', 'b'))->isTrue();
     * that(str_exists('abc', 'B', true))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, false))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 調べる文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @param bool $and_flag すべて含む場合に true を返すか
     * @return bool $needle を含むなら true
     */
    function str_exists(?string $haystack, $needle, $case_insensitivity = false, $and_flag = false)
    {
        if (!is_array($needle)) {
            $needle = [$needle];
        }

        $needle = array_map('strval', $needle);

        foreach ($needle as $str) {
            if ($str === '') {
                continue;
            }
            $pos = $case_insensitivity ? stripos($haystack, $str) : strpos($haystack, $str);
            if ($and_flag && $pos === false) {
                return false;
            }
            if (!$and_flag && $pos !== false) {
                return true;
            }
        }
        return !!$and_flag;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_guess') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_guess'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_guess')) {
    /**
     * $string に最も近い文字列を返す
     *
     * N-gram 化して類似度の高い結果を返す。
     * $percent で一致度を受けられる。
     * 予め値が入った変数を渡すとその一致度以上の候補を高い順で配列で返す。
     *
     * この関数の結果（内部実装）は互換性を考慮しない。
     *
     * Example:
     * ```php
     * // 「あいうえお」と最も近い文字列は「あいゆえに」である
     * that(str_guess("あいうえお", [
     *     'かきくけこ', // マッチ度 0%（1文字もかすらない）
     *     'ぎぼあいこ', // マッチ度約 13.1%（"あい"はあるが位置が異なる）
     *     'あいしてる', // マッチ度約 13.8%（"あい"がマッチ）
     *     'かとうあい', // マッチ度約 16.7%（"あい"があり"う"の位置が等しい）
     *     'あいゆえに', // マッチ度約 17.4%（"あい", "え"がマッチ）
     * ]))->isSame('あいゆえに');
     *
     * // マッチ度30%以上を高い順に配列で返す
     * $percent = 30;
     * that(str_guess("destory", [
     *     'describe',
     *     'destroy',
     *     'destruct',
     *     'destiny',
     *     'destinate',
     * ], $percent))->isSame([
     *     'destroy',
     *     'destiny',
     *     'destruct',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 調べる文字列
     * @param array $candidates 候補文字列配列
     * @param ?float $percent マッチ度（％）を受ける変数
     * @return string|array 候補の中で最も近い文字列
     */
    function str_guess(?string $string, $candidates, &$percent = null)
    {
        $candidates = array_filter(arrayval($candidates, false), 'strlen');
        if (!$candidates) {
            throw new \InvalidArgumentException('$candidates is empty.');
        }

        // uni, bi, tri して配列で返すクロージャ
        $ngramer = static function ($string) {
            $result = [];
            foreach ([1, 2, 3] as $n) {
                $result[$n] = ngram($string, $n);
            }
            return $result;
        };

        $sngram = $ngramer($string);

        $result = array_fill_keys($candidates, null);
        foreach ($candidates as $candidate) {
            $cngram = $ngramer($candidate);

            // uni, bi, tri で重み付けスコア（var_dump したいことが多いので配列に入れる）
            $scores = [];
            foreach ($sngram as $n => $_) {
                $scores[$n] = count(array_intersect($sngram[$n], $cngram[$n])) / max(count($sngram[$n]), count($cngram[$n])) * $n;
            }
            $score = array_sum($scores) * 10 + 1;

            // ↑のスコアが同じだった場合を考慮してレーベンシュタイン距離で下駄を履かせる
            $score -= damerau_levenshtein($sngram[1], $cngram[1]) / max(count($sngram[1]), count($cngram[1]));

            // 10(uni) + 20(bi) + 30(tri) + 1(levenshtein) で最大は 61
            $score = $score / 61 * 100;

            $result[$candidate] = $score;
        }

        arsort($result);
        if ($percent === null) {
            $percent = reset($result);
        }
        else {
            return array_map('strval', array_keys(array_filter($result, fn($score) => $score >= $percent)));
        }

        return (string) key($result);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_lchop') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_lchop'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_lchop')) {
    /**
     * 先頭の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_lchop("$PATH/hoge.php", "$PATH/"))->isSame('hoge.php');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $prefix 削ぎ落とす先頭文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_lchop(?string $string, ?string $prefix, $case_insensitivity = false)
    {
        return str_chop($string, $prefix, '', $case_insensitivity);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_patch') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_patch'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_patch')) {
    /**
     * テキストに patch を当てる
     *
     * diff 形式は現在のところ unified のみ。
     * reject の仕様はなく、ハンクが一つでも検出・適用不可なら例外を投げる。
     *
     * Example:
     * ```php
     * $xstring = <<<HERE
     * equal line
     * delete line
     * equal line
     * HERE;
     * $ystring = <<<HERE
     * equal line
     * equal line
     * append line
     * HERE;
     * // xstring から ystring へのパッチ
     * $patch = str_diff($xstring, $ystring, ['stringify' => 'unified=3']);
     * // xstring に適用すれば ystring になる
     * that(str_patch($xstring, $patch))->isSame($ystring);
     * // ystring に reverse で適用すれば xstring に戻る
     * that(str_patch($ystring, $patch, ['reverse' => true]))->isSame($xstring);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 文字列
     * @param string $patch パッチ文字列
     * @param array $options オプション配列
     * @return string パッチ適用結果
     */
    function str_patch(?string $string, ?string $patch, $options = [])
    {
        $options += [
            'encoding' => null,
            'format'   => 'unified', // パッチ形式（未実装。現在は unified のみ）
            'fuzz'     => 0,         // ハンク検出失敗時に同一行を伏せる量（未実装でおそらく実装しない。diff 側でせっかく出力してるのに無視するのはもったいない）
            'reverse'  => false,     // 逆パッチフラグ
            'forward'  => false,     // 既に当たっているなら例外を投げずにスルーする
        ];

        // 空文字の時は特別扱いで「差分なし」とみなす（差分がないなら diff 結果が空文字になるので必然的に渡ってくる機会が多くなる）
        if (!strlen($patch)) {
            return $string;
        }

        $recover = mb_ereg_options([
            'encoding'      => $options['encoding'],
            'regex_options' => 'r',
        ]);

        $parts = mb_ereg_split('(^@@\s+-\d+(?:,\d+)?\s+\+\d+(?:,\d+)?\s+@@\r?\n)', $patch, -1, PREG_SPLIT_DELIM_CAPTURE);
        $comment = array_shift($parts);
        assert(is_string($comment) && count($parts) % 2 === 0);
        if (!$parts) {
            throw new \InvalidArgumentException('$patch is invalid');
        }

        $matches = [];
        foreach (array_chunk($parts, 2) as $chunk) {
            mb_ereg('^@@\s+-(?<oldpos>\d+)(,(?<oldlen>\d+))?\s+\+(?<newpos>\d+)(,(?<newlen>\d+))?\s+@@\r?\n', $chunk[0], $match);
            $matches[] = array_map(fn($m) => $m === false ? null : $m, $match) + ['diff' => $chunk[1]];
        }

        $hunks = [];
        foreach ($matches as $match) {
            $hunk = new class($match['oldpos'], $match['oldlen'], $match['newpos'], $match['newlen'], $match['diff']) {
                private int $oldOffset;
                private int $oldLength;

                private int $newOffset;
                private int $newLength;

                private array $diffs;

                private int   $oldOriginalOffset;
                private int   $newOriginalOffset;
                private array $oldContents = [];
                private array $newContents = [];

                public function __construct($oldpos, $oldlen, $newpos, $newlen, $diff)
                {
                    $this->oldOffset = $oldpos - 1;
                    $this->oldLength = $oldlen ?? 1;
                    $this->newOffset = $newpos - 1;
                    $this->newLength = $newlen ?? 1;
                    $this->diffs = mb_ereg_split('\\R', $diff, -1, PREG_SPLIT_NO_EMPTY);

                    $this->oldOriginalOffset = $this->oldOffset;
                    $this->newOriginalOffset = $this->newOffset;

                    foreach ($this->diffs as $diff) {
                        switch ($diff[0]) {
                            case ' ':
                                $this->oldContents[] = $this->newContents[] = substr($diff, 1);
                                break;
                            case '-':
                                $this->oldContents[] = substr($diff, 1);
                                break;
                            case '+':
                                $this->newContents[] = substr($diff, 1);
                                break;
                        }
                    }

                    assert($this->oldLength === count($this->oldContents));
                    assert($this->newLength === count($this->newContents));
                }

                public function reverse()
                {
                    [
                        $this->oldOriginalOffset,
                        $this->oldOffset,
                        $this->oldLength,
                        $this->oldContents,
                        $this->newOriginalOffset,
                        $this->newOffset,
                        $this->newLength,
                        $this->newContents,
                    ] = [
                        $this->newOriginalOffset,
                        $this->newOriginalOffset, // ミスではない
                        $this->newLength,
                        $this->newContents,
                        $this->oldOriginalOffset,
                        $this->oldOriginalOffset, // ミスではない
                        $this->oldLength,
                        $this->oldContents,
                    ];
                }

                public function detect(array $lines, int $delta)
                {
                    $nearest = static function (int $start, int $min, int $max) {
                        yield 0;
                        for ($delta = 1, $limit = max($start - $min, $max - $start); $delta <= $limit; $delta++) {
                            if (($start - $delta) >= $min) {
                                yield -$delta;
                            }
                            if (($start + $delta) <= $max) {
                                yield +$delta;
                            }
                        }
                    };

                    foreach ($nearest($this->oldOffset + $delta, 0, count($lines) - $this->oldLength) as $offset) {
                        if ($this->oldContents === array_slice($lines, $this->oldOffset + $offset, $this->oldLength)) {
                            $this->oldOffset += $offset;
                            return $offset;
                        }
                    }

                    throw new \UnexpectedValueException("not found hunk block\n" . implode("\n", $this->diffs));
                }

                public function apply(int &$current, array $lines)
                {
                    $result = array_merge(array_slice($lines, $current, $this->oldOffset - $current), $this->newContents);
                    $current = $this->oldOffset + $this->oldLength;

                    return $result;
                }
            };

            if ($options['reverse']) {
                $hunk->reverse();
            }

            $hunks[] = $hunk;
        }

        $apply = function ($hunks, $lines) {
            $delta = 0;
            $current = 0;
            $result = [];
            foreach ($hunks as $hunk) {
                $delta = $hunk->detect($lines, $delta);

                $result = array_merge($result, $hunk->apply($current, $lines));
            }
            $result = array_merge($result, array_slice($lines, $current));

            return implode("\n", $result);
        };

        try {
            $lines = mb_split('\\R', $string);
            return $apply($hunks, $lines);
        }
        catch (\Exception $e) {
            // reverse で当ててみて例外が飛ばないなら元の文字列を返す
            if ($options['forward']) {
                foreach ($hunks as $hunk) {
                    $hunk->reverse();
                }
                $apply($hunks, $lines);
                return $string;
            }
            throw $e;
        }
        finally {
            $recover();
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_putcsv') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_putcsv'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_putcsv')) {
    /**
     * fputcsv の文字列版（str_getcsv の put 版）
     *
     * 普通の配列を与えるとシンプルに "a,b,c" のような1行を返す。
     * 多次元配列（2次元のみを想定）や Traversable を与えるとループして "a,b,c\nd,e,f" のような複数行を返す。
     *
     * Example:
     * ```php
     * // シンプルな1行を返す
     * that(str_putcsv(['a', 'b', 'c']))->isSame("a,b,c");
     * that(str_putcsv(['a', 'b', 'c'], "\t"))->isSame("a\tb\tc");
     * that(str_putcsv(['a', ' b ', 'c'], " ", "'"))->isSame("a ' b ' c");
     *
     * // 複数行を返す
     * that(str_putcsv([['a', 'b', 'c'], ['d', 'e', 'f']]))->isSame("a,b,c\nd,e,f");
     * that(str_putcsv((function() {
     *     yield ['a', 'b', 'c'];
     *     yield ['d', 'e', 'f'];
     * })()))->isSame("a,b,c\nd,e,f");
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param iterable $array 値の配列 or 値の配列の配列
     * @param string $delimiter フィールド区切り文字
     * @param string $enclosure フィールドを囲む文字
     * @param string $escape エスケープ文字
     * @return string CSV 文字列
     */
    function str_putcsv($array, $delimiter = ',', $enclosure = '"', $escape = "\\")
    {
        static $fp = null;
        $fp ??= fopen('php://memory', 'rw+');
        rewind($fp);
        ftruncate($fp, 0);
        if (is_array($array) && array_depth($array, 2) === 1) {
            $array = [$array];
        }
        foreach ($array as $line) {
            fputcsv($fp, $line, $delimiter, $enclosure, $escape);
        }
        rewind($fp);
        return rtrim(stream_get_contents($fp), "\n");
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_quote') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_quote')) {
    /**
     * 文字列をダブルクォート文字列に変換する
     *
     * 文字ではうまく表現できないが、例えば「本当の改行」が \n になり、「本当のタブ文字」が \t になる。
     * コントロール文字は "\code" 形式のようになる。
     * 「得られた文字列は eval すると元に戻る」とでも言えばいいか。
     *
     * 制御文字をそのまま出力するとまずい状況が稀によくある（特に行指向媒体への改行文字）。
     * この関数を通せば php の文字列の体裁を保ったまま1行化できる。
     * 端的に言えば var_export の文字列特化版。
     *
     * 挙動は $options である程度制御可能。
     * 各 $options は原則的に文字のマップか true を渡す（true の場合はデフォルトが使用される）。
     * 一部、それ以外の値・型に対応しているものもある。
     *
     * - escape-character: 制御文字のうち、明確なエスケープシーケンスが存在する場合はそれを使用する
     *   - control-character にオーバーラップするがこちらが優先される
     * - control-character: 00 ～ 1F+7F の制御文字を \code 形式にする
     *   - 文字列で "oct", "hex", "HEX" も指定できる。その場合それぞれ \oct, \xhex, \xHEX 形式になる
     * - special-character: ダブルクオート内の文字列が文字列であるための変換を行う
     *   - 原則的にデフォルトに任せて指定すべきではない
     *
     * Example:
     * ```php
     * // （非常に分かりにくいが）下記のように変換される
     * that(str_quote("\$a\nb\rc\x00"))->isSame("\"\\\$a\\nb\\rc\\0\"");
     * // 文字としての意味は一緒であり要するに表現形式の違いなので、php の世界で eval すれば元の文字列に戻る
     * that(eval('return ' . str_quote("\$a\nb\rc\x00") . ';'))->isSame("\$a\nb\rc\x00");
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $options オプション配列
     * @return string クォート文字列
     */
    function str_quote(string $string, array $options = []): string
    {
        $options += [
            'escape-character'  => true,
            'control-character' => true,
            'special-character' => true,
            'heredoc'           => '',
            'nowdoc'            => '',
            'indent'            => 0,
        ];

        assert(!($options['heredoc'] && $options['nowdoc']));

        // nowdoc にエスケープは存在しないのでそのまま埋め込む（その結果壊れてもこの関数の責務ではない）
        if (strlen($options['nowdoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<'{$options['nowdoc']}'\n{$indent}{$string}\n{$indent}{$options['nowdoc']}";
        }

        // @see https://www.php.net/manual/ja/language.types.string.php#language.types.string.syntax.double
        $special_chars = [
            '\\' => '\\\\', // バックスラッシュ
            '"'  => '\\"',  // 二重引用符
            '$'  => '\\$',  // ドル記号
        ];
        $escape_chars = [
            "\11" => '\\t', // 水平タブ (HT またはアスキーの 0x09 (9))
            "\12" => '\\n', // ラインフィード (LF またはアスキーの 0x0A (10))
            "\13" => '\\v', // 垂直タブ (VT またはアスキーの 0x0B (11))
            "\14" => '\\f', // フォームフィード (FF またはアスキーの 0x0C (12))
            "\15" => '\\r', // キャリッジリターン (CR またはアスキーの 0x0D (13))
            "\33" => '\\e', // エスケープ (ESC あるいはアスキーの 0x1B (27))
        ];
        $control_chars = [
            "\0"   => "\\0",
            "\1"   => "\\1",
            "\2"   => "\\2",
            "\3"   => "\\3",
            "\4"   => "\\4",
            "\5"   => "\\5",
            "\6"   => "\\6",
            "\7"   => "\\7",
            "\10"  => "\\10",
            "\11"  => "\\11",
            "\12"  => "\\12",
            "\13"  => "\\13",
            "\14"  => "\\14",
            "\15"  => "\\15",
            "\16"  => "\\16",
            "\17"  => "\\17",
            "\20"  => "\\20",
            "\21"  => "\\21",
            "\22"  => "\\22",
            "\23"  => "\\23",
            "\24"  => "\\24",
            "\25"  => "\\25",
            "\26"  => "\\26",
            "\27"  => "\\27",
            "\30"  => "\\30",
            "\31"  => "\\31",
            "\32"  => "\\32",
            "\33"  => "\\33",
            "\34"  => "\\34",
            "\35"  => "\\35",
            "\36"  => "\\36",
            "\37"  => "\\37",
            "\177" => "\\177",
        ];

        // heredoc 用の特殊処理（タイプ可能な文字はエスケープしなくてもよいだろう）
        if (strlen($options['heredoc'])) {
            $control_chars = array_diff_key($control_chars, $escape_chars);
            $escape_chars = [];
            unset($special_chars['"']);
        }

        $charmap = [];
        if ($options['special-character']) {
            $charmap += is_array($options['special-character']) ? $options['special-character'] : $special_chars;
        }
        if ($options['escape-character']) {
            $charmap += is_array($options['escape-character']) ? $options['escape-character'] : $escape_chars;
        }
        if ($options['control-character']) {
            if ($options['control-character'] === 'oct') {
                // デフォで oct にしてあるので変換不要
                assert(end($control_chars) === "\\177");
            }
            if ($options['control-character'] === 'hex') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02x', octdec(trim($v, '\\'))), $control_chars);
            }
            if ($options['control-character'] === 'HEX') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02X', octdec(trim($v, '\\'))), $control_chars);
            }
            $charmap += is_array($options['control-character']) ? $options['control-character'] : $control_chars;
        }

        $string = strtr($string, $charmap);

        if (strlen($options['heredoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<{$options['heredoc']}\n{$indent}{$string}\n{$indent}{$options['heredoc']}";
        }

        return '"' . $string . '"';
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_rchop') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_rchop'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_rchop')) {
    /**
     * 末尾の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列から .php を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_rchop("$PATH/hoge.php", ".php"))->isSame("$PATH/hoge");
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $suffix 削ぎ落とす末尾文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_rchop(?string $string, ?string $suffix, $case_insensitivity = false)
    {
        return str_chop($string, '', $suffix, $case_insensitivity);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_submap') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_submap'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_submap')) {
    /**
     * 指定文字列を置換する
     *
     * $subject を $replaces に従って置換する。
     * 具体的には「$replaces を 複数指定できる str_subreplace」に近い。
     *
     * strtr とは「N 番目のみ置換できる」点で異なる。
     * つまり、$replaces=['hoge' => [2 => 'fuga']] とすると「2 番目の 'hoge' が 'fuga' に置換される」という動作になる（0 ベース）。
     *
     * $replaces の要素に非配列を与えた場合は配列化される。
     * つまり `$replaces = ['hoge' => 'fuga']` は `$replaces = ['hoge' => ['fuga']]` と同じ（最初のマッチを置換する）。
     *
     * $replace に空配列を与えると何もしない。
     * 負数キーは後ろから数える動作となる。
     * また、置換後の文字列は置換対象にはならない。
     *
     * N 番目の検索文字列が見つからない場合は例外を投げる。
     * ただし、文字自体が見つからない場合は投げない。
     *
     * Example:
     * ```php
     * // "hello, world" の l と o を置換
     * that(str_submap('hello, world', [
     *     // l は0番目と2番目のみを置換（1番目は何も行われない）
     *     'l' => [
     *         0 => 'L1',
     *         2 => 'L3',
     *     ],
     *     // o は後ろから数えて1番目を置換
     *     'o' => [
     *         -1 => 'O',
     *     ],
     * ]))->isSame('heL1lo, wOrL3d');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $subject 対象文字列
     * @param array $replaces 読み換え配列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 置換された文字列
     */
    function str_submap(?string $subject, $replaces, $case_insensitivity = false)
    {
        assert(is_iterable($replaces));

        $isubject = $subject;
        if ($case_insensitivity) {
            $isubject = strtolower($isubject);
        }

        // 負数対応のために逆数計算（ついでに整数チェック）
        $mapping = [];
        foreach ($replaces as $from => $map) {
            $ifrom = $from;
            if ($case_insensitivity) {
                $ifrom = strtolower($ifrom);
            }
            $subcount = substr_count($isubject, $ifrom);
            if ($subcount === 0) {
                continue;
            }
            $mapping[$ifrom] = [];
            $map = is_iterable($map) ? $map : [$map];
            foreach ($map as $n => $to) {
                $origN = $n;
                if (!is_int($n)) {
                    throw new \InvalidArgumentException('$replaces key must be integer.');
                }
                if ($n < 0) {
                    $n += $subcount;
                }
                if (!(0 <= $n && $n < $subcount)) {
                    throw new \InvalidArgumentException("notfound search string '$from' of {$origN}th.");
                }
                $mapping[$ifrom][$n] = $to;
            }
        }

        // 空はそのまま返す
        if (is_empty($mapping)) {
            return $subject;
        }

        // いろいろ試した感じ正規表現が最もシンプルかつ高速だった

        $repkeys = array_keys($mapping);
        $counter = array_fill_keys($repkeys, 0);
        $patterns = array_map(fn($k) => preg_quote($k, '#'), $repkeys);

        $i_flag = $case_insensitivity ? 'i' : '';
        return preg_replace_callback("#" . implode('|', $patterns) . "#u$i_flag", function ($matches) use (&$counter, $mapping, $case_insensitivity) {
            $imatch = $matches[0];
            if ($case_insensitivity) {
                $imatch = strtolower($imatch);
            }
            $index = $counter[$imatch]++;
            if (array_key_exists($index, $mapping[$imatch])) {
                return $mapping[$imatch][$index];
            }
            return $matches[0];
        }, $subject);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\str_subreplace') || (new \ReflectionFunction('ryunosuke\\ltsv\\str_subreplace'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\str_subreplace')) {
    /**
     * 指定文字列を置換する
     *
     * $subject 内の $search を $replaces に置換する。
     * str_replace とは「N 番目のみ置換できる」点で異なる。
     * つまり、$search='hoge', $replace=[2 => 'fuga'] とすると「2 番目の 'hoge' が 'fuga' に置換される」という動作になる（0 ベース）。
     *
     * $replace に 非配列を与えた場合は配列化される。
     * つまり `$replaces = 'hoge'` は `$replaces = [0 => 'hoge']` と同じ（最初のマッチを置換する）。
     *
     * $replace に空配列を与えると何もしない。
     * 負数キーは後ろから数える動作となる。
     * また、置換後の文字列は置換対象にはならない。
     *
     * N 番目の検索文字列が見つからない場合は例外を投げる。
     * ただし、文字自体が見つからない場合は投げない。
     *
     * Example:
     * ```php
     * // 1番目（0ベースなので2番目）の x を X に置換
     * that(str_subreplace('xxx', 'x', [1 => 'X']))->isSame('xXx');
     * // 0番目（最前列）の x を Xa に、-1番目（最後尾）の x を Xz に置換
     * that(str_subreplace('!xxx!', 'x', [0 => 'Xa', -1 => 'Xz']))->isSame('!XaxXz!');
     * // 置換結果は置換対象にならない
     * that(str_subreplace('xxx', 'x', [0 => 'xxx', 1 => 'X']))->isSame('xxxXx');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $subject 対象文字列
     * @param string $search 検索文字列
     * @param array|string $replaces 置換文字列配列（単一指定は配列化される）
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 置換された文字列
     */
    function str_subreplace(?string $subject, ?string $search, $replaces, $case_insensitivity = false)
    {
        $replaces = is_iterable($replaces) ? $replaces : [$replaces];

        // 空はそのまま返す
        if (is_empty($replaces)) {
            return $subject;
        }

        // 負数対応のために逆数計算（ついでに整数チェック）
        $subcount = $case_insensitivity ? substr_count(strtolower($subject), strtolower($search)) : substr_count($subject, $search);
        if ($subcount === 0) {
            return $subject;
        }
        $mapping = [];
        foreach ($replaces as $n => $replace) {
            $origN = $n;
            if (!is_int($n)) {
                throw new \InvalidArgumentException('$replaces key must be integer.');
            }
            if ($n < 0) {
                $n += $subcount;
            }
            if (!(0 <= $n && $n < $subcount)) {
                throw new \InvalidArgumentException("notfound search string '$search' of {$origN}th.");
            }
            $mapping[$n] = $replace;
        }
        $maxseq = max(array_keys($mapping));
        $offset = 0;
        for ($n = 0; $n <= $maxseq; $n++) {
            $pos = $case_insensitivity ? stripos($subject, $search, $offset) : strpos($subject, $search, $offset);
            if (isset($mapping[$n])) {
                $subject = substr_replace($subject, $mapping[$n], $pos, strlen($search));
                $offset = $pos + strlen($mapping[$n]);
            }
            else {
                $offset = $pos + strlen($search);
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strcat') || (new \ReflectionFunction('ryunosuke\\ltsv\\strcat'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strcat')) {
    /**
     * 文字列結合の関数版
     *
     * Example:
     * ```php
     * that(strcat('a', 'b', 'c'))->isSame('abc');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param mixed ...$variadic 結合する文字列（可変引数）
     * @return string 結合した文字列
     */
    function strcat(?string ...$variadic)
    {
        return implode('', $variadic);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strpos_array') || (new \ReflectionFunction('ryunosuke\\ltsv\\strpos_array'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strpos_array')) {
    /**
     * 複数の文字列で strpos する
     *
     * $needles のそれぞれの位置を配列で返す。
     * ただし、見つからなかった文字は結果に含まれない。
     *
     * Example:
     * ```php
     * // 見つかった位置を返す
     * that(strpos_array('hello world', ['hello', 'world']))->isSame([
     *     0 => 0,
     *     1 => 6,
     * ]);
     * // 見つからない文字は含まれない
     * that(strpos_array('hello world', ['notfound', 'world']))->isSame([
     *     1 => 6,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param iterable $needles 位置を取得したい文字列配列
     * @param int $offset 開始位置
     * @return array $needles それぞれの位置配列
     */
    function strpos_array(?string $haystack, $needles, $offset = 0)
    {
        if ($offset < 0) {
            $offset += strlen($haystack);
        }

        $result = [];
        foreach (arrayval($needles, false) as $key => $needle) {
            $pos = strpos($haystack, $needle, $offset);
            if ($pos !== false) {
                $result[$key] = $pos;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strpos_closest') || (new \ReflectionFunction('ryunosuke\\ltsv\\strpos_closest'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strpos_closest')) {
    /**
     * 指定位置から左右どちらかの探索を行う
     *
     * 一つ前/後の指定文字の位置を返す
     * 端的に言えば strpo/strposr の自動使い分け＋範囲外でもエラーにならない版。
     *
     * $nth は負数で左探索、正数で右探索だが、スキップ数も兼ねる。
     *
     * Example:
     * ```php
     * //        +0123456789A1234567
     * //        -7654321A9876543210
     * $string = 'hello hello hello';
     *
     * // 0文字目から右探索すれば0文字目が引っかかる
     * that(strpos_closest($string, 'hello', 0, +1))->isSame(0);
     * // ↑のスキップ（2つ目）版
     * that(strpos_closest($string, 'hello', 0, +2))->isSame(6);
     * // 5文字目から右探索すれば6文字目が引っかかる
     * that(strpos_closest($string, 'hello', 5, +1))->isSame(6);
     * // ↑のスキップ（2つ目）版
     * that(strpos_closest($string, 'hello', 5, +2))->isSame(12);
     * // 8文字目から右探索すれば12文字目が引っかかる（2個目の hello の途中なので3個目の hello から引っかかる）
     * that(strpos_closest($string, 'hello', 8, +1))->isSame(12);
     * // ↑のスキップ（2つ目）版
     * that(strpos_closest($string, 'hello', 8, +2))->isSame(null);
     *
     * // 0文字目から左探索しても見つからない
     * that(strpos_closest($string, 'hello', 0, -1))->isSame(null);
     * // 5文字目から左探索すれば0文字目が引っかかる
     * that(strpos_closest($string, 'hello', 5, -1))->isSame(0);
     * // 8文字目から左探索すれば0文字目が引っかかる（2個目の hello の途中なので1個目の hello から引っかかる）
     * that(strpos_closest($string, 'hello', 8, -1))->isSame(0);
     * // 11文字目から左探索すれば6文字目が引っかかる
     * that(strpos_closest($string, 'hello', 11, -1))->isSame(6);
     * // ↑のスキップ（2つ目）版
     * that(strpos_closest($string, 'hello', 11, -2))->isSame(0);
     *
     * // 範囲外でもエラーにならない
     * that(strpos_closest($string, 'hello', -999, +1))->isSame(0);  // 「数直線のはるか左方から探索を始めて 0 文字目で見つかった」のようなイメージ
     * that(strpos_closest($string, 'hello', +999, -1))->isSame(12); // 「数直線のはるか右方から探索を始めて 12 文字目で見つかった」のようなイメージ
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string $needle 位置を取得したい文字列
     * @param ?int $offset 開始位置。 null を渡すと $nth の方向に応じて自動で定まる
     * @param int $nth 左右指定兼スキップ数（正数で右探索、負数で左探索）
     * @return ?int 見つかった位置
     */
    function strpos_closest(string $haystack, string $needle, ?int $offset = null, int $nth = 1): ?int
    {
        assert($nth !== 0);

        $reverse = $nth < 0;
        $nth = abs($nth);

        $offset ??= $reverse ? strlen($haystack) : 0;

        for ($i = 0; $i < $nth; $i++) {
            if ($i > 0) {
                $offset++;
            }

            if ($offset < -strlen($haystack)) {
                $offset = -strlen($haystack);
            }
            if ($offset > strlen($haystack)) {
                $offset = strlen($haystack);
            }

            if ($reverse) {
                $offset = strposr($haystack, $needle, $offset);
            }
            else {
                $offset = strpos($haystack, $needle, $offset);
            }

            if ($offset === false) {
                return null;
            }
        }
        return $offset;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strpos_escaped') || (new \ReflectionFunction('ryunosuke\\ltsv\\strpos_escaped'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strpos_escaped')) {
    /**
     * エスケープを考慮して strpos する
     *
     * 文字列中のエスケープ中でない生の文字を検索する。
     * 例えば `"abc\nxyz"` という文字列で `"n"` という文字は存在しないとみなす。
     * `"\n"` は改行のエスケープシーケンスであり、 `"n"` という文字ではない（エスケープシーケンスとして "n" を流用しているだけ）。
     * 逆に `"\\n"` はバックスラッシュと `"n"` という文字であり `"n"` が存在する。
     * 簡単に言えば「直前にバックスラッシュがある場合はヒットしない strpos」である。
     * バックスラッシュは $escape 引数で指定可能。
     *
     * $needle 自体にエスケープ文字を含む場合、反対の意味で検索する。
     * つまり、「直前にバックスラッシュがある場合のみヒットする strpos」になる。
     *
     * $offset 引数を指定するとその位置から探索を開始するが、戻り読みはしないのでエスケープ文字の真っ只中を指定する場合は注意。
     * 例えば `"\n"` は改行文字だけであるが、offset に 1 に指定して "n" を探すとマッチする。
     *
     * Example:
     * ```php
     * # 分かりにくいので \ ではなく % をエスケープ文字とする
     * $defargs = [0, '%'];
     *
     * // これは null である（"%d" という文字の列であるため "d" という文字は存在しない）
     * that(strpos_escaped('%d', 'd', ...$defargs))->isSame(null);
     * // これは 2 である（"%" "d" という文字の列であるため（d の前の % は更にその前の % に呑まれておりメタ文字ではない））
     * that(strpos_escaped('%%d', 'd', ...$defargs))->isSame(2);
     *
     * // これは 0 である（% をつけて検索するとそのエスケープシーケンス的なものそのものを探すため）
     * that(strpos_escaped('%d', '%d', ...$defargs))->isSame(0);
     * // これは null である（"%" "d" という文字の列であるため "%d" という文字は存在しない）
     * that(strpos_escaped('%%d', '%d', ...$defargs))->isSame(null);
     * // これは 2 である（"%" "%d" という文字の列であるため）
     * that(strpos_escaped('%%%d', '%d', ...$defargs))->isSame(2);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 探す文字
     * @param int $offset 開始位置
     * @param string $escape エスケープ文字
     * @param ?string $found 見つかった文字が格納される
     * @return ?int 見つかった位置
     */
    function strpos_escaped(?string $haystack, $needle, $offset = 0, $escape = '\\', &$found = null)
    {
        $q_escape = preg_quote($escape, '#');
        if (is_stringable($needle)) {
            $needle = preg_split("#($q_escape?.)#u", $needle, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
        }

        $needles = arrayval($needle);
        assert(!in_array($escape, $needles, true), sprintf('$needle must not contain only escape charactor ("%s")', implode(', ', $needles)));

        $matched = [];
        foreach (array_map(fn($c) => preg_quote($c, '#'), $needles) as $need) {
            if (preg_match_all("#((?:$q_escape)*?)($need)#u", $haystack, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER, $offset)) {
                foreach ($matches as [, $m_escape, $m_needle]) {
                    if ((strlen($m_escape[0]) / strlen($escape)) % 2 === 0) {
                        $matched[$m_needle[1]] ??= $m_needle[0];
                    }
                }
            }
        }
        if (!$matched) {
            $found = null;
            return null;
        }

        ksort($matched);
        $min = array_key_first($matched);
        $found = $matched[$min];
        return $min;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strpos_quoted') || (new \ReflectionFunction('ryunosuke\\ltsv\\strpos_quoted'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strpos_quoted')) {
    /**
     * クオートを考慮して strpos する
     *
     * Example:
     * ```php
     * // クオート中は除外される
     * that(strpos_quoted('hello "this" is world', 'is'))->isSame(13);
     * // 開始位置やクオート文字は指定できる（5文字目以降の \* に囲まれていない hoge の位置を返す）
     * that(strpos_quoted('1:hoge, 2:*hoge*, 3:hoge', 'hoge', 5, '*'))->isSame(20);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|iterable $needle 位置を取得したい文字列
     * @param int $offset 開始位置
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @param ?string $found $needle の内、見つかった文字列が格納される
     * @return ?int $needle の位置
     */
    function strpos_quoted(?string $haystack, $needle, $offset = 0, $enclosure = "'\"", $escape = '\\', &$found = null)
    {
        if (is_string($enclosure)) {
            if (strlen($enclosure)) {
                $chars = str_split($enclosure);
                $enclosure = array_combine($chars, $chars);
            }
            else {
                $enclosure = [];
            }
        }
        $needles = arrayval($needle, false);

        $strlen = strlen($haystack);

        if ($offset < 0) {
            $offset += $strlen;
        }

        $found = null;
        $enclosing = [];
        for ($i = $offset; $i < $strlen; $i++) {
            if ($i !== 0 && $haystack[$i - 1] === $escape) {
                continue;
            }
            foreach ($enclosure as $start => $end) {
                if (substr_compare($haystack, $end, $i, strlen($end)) === 0) {
                    if ($enclosing && $enclosing[count($enclosing) - 1] === $end) {
                        array_pop($enclosing);
                        $i += strlen($end) - 1;
                        continue 2;
                    }
                }
                if (substr_compare($haystack, $start, $i, strlen($start)) === 0) {
                    $enclosing[] = $end;
                    $i += strlen($start) - 1;
                    continue 2;
                }
            }

            if (empty($enclosing)) {
                foreach ($needles as $needle) {
                    if (substr_compare($haystack, $needle, $i, strlen($needle)) === 0) {
                        $found = $needle;
                        return $i;
                    }
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strposr') || (new \ReflectionFunction('ryunosuke\\ltsv\\strposr'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strposr')) {
    /**
     * デフォで左探索な strrpos
     *
     * 個人的に strrpos の offset の挙動が分かりにくい。
     * - offset>=0: 先頭から offset スキップ＋**右探索**
     * - offset< 0: 末尾から -offset スキップ＋**左探索**
     *
     * r と銘打っているんだから offset に依らずにデフォで左探索して欲しい。
     * 特に offset 未指定だと 0 なので「先頭から末尾まで読んで最後に見つかった場所を返す」という非常に非効率的なことになっている（実際の実装は違うようだけど）。
     * さらに「単純に50文字目から左探索したい」だけなのに offset が気持ち悪いことになる（50 - strlen($string)）。
     * 要するに https://www.php.net/manual/ja/function.strrpos.php#76447 これ。
     *
     * offset で検索文字列の途中に飛び込んだ場合は見つからないとみなす（strrpos は見つかったとみなす）。
     * この挙動は説明しにくいので Example を参照。
     *
     * Example:
     * ```php
     * //        +0123456789A1234567
     * //        -7654321A9876543210
     * $string = 'hello hello hello';
     *
     * // offset を省略すると末尾から左探索になる
     * that(strposr($string, 'hello'))->isSame(12);
     * // 標準の文字列関数のように負数で後ろからの探索になる
     * that(strposr($string, 'hello', -1))->isSame(6);
     * // 0文字目から左探索しても見つからない
     * that(strposr($string, 'hello', 0))->isSame(false);
     * // 5文字目から左探索すれば0文字目が引っかかる
     * that(strposr($string, 'hello', 5))->isSame(0);
     * // 13文字目から左探索すれば6文字目が引っかかる（13文字目は3個目の hello の途中なので2個目の hello から引っかかる）
     * that(strposr($string, 'hello', 13))->isSame(6);
     * // この動作は strrpos だと異なる（途中文字列も拾ってしまう）
     * that(strrpos($string, 'hello', -4))->isSame(12);
     * // そもそも strrpos は負数指定しないと右探索なので使いにくくてしょうがない
     * that(strrpos($string, 'hello', 5))->isSame(12);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string $needle 位置を取得したい文字列
     * @param ?int $offset 開始位置。 null を渡すと末尾からの探索になる
     * @return int|false 見つかった位置
     */
    function strposr(string $haystack, string $needle, ?int $offset = null): int|false
    {
        $offset ??= strlen($haystack);

        if ($offset < 0) {
            $offset += strlen($haystack);
        }

        if (strlen($haystack) < $offset) {
            throw new \ValueError('strposr(): Argument #3 ($offset) must be contained in argument #1 ($haystack)');
        }

        $result = strrpos($haystack, $needle, $offset - strlen($haystack));
        // 仮に見つかってもオフセットを跨いでる場合は -1 して再検索
        if ($result !== false && $result + strlen($needle) > $offset) {
            // が、先頭文字の場合は -1 する意味もない（そもそもエラーになる）ので false で返してしまってよい
            if ($result === 0) {
                return false;
            }
            return strrpos($haystack, $needle, $result - 1 - strlen($haystack));
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strrstr') || (new \ReflectionFunction('ryunosuke\\ltsv\\strrstr'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strrstr')) {
    /**
     * 文字列が最後に現れる位置以前を返す
     *
     * strstr の逆のイメージで文字列を後ろから探索する動作となる。
     * strstr の動作は「文字列を前から探索して指定文字列があったらそれ以後を返す」なので、
     * その逆の動作の「文字列を後ろから探索して指定文字列があったらそれ以前を返す」という挙動を示す。
     *
     * strstr の「needle が文字列でない場合は、 それを整数に変換し、その番号に対応する文字として扱います」は直感的じゃないので踏襲しない。
     * （全体的にこの動作をやめよう、という RFC もあったはず）。
     *
     * 第3引数の意味合いもデフォルト値も逆になるので、単純に呼べばよくある「指定文字列より後ろを（指定文字列を含めないで）返す」という動作になる。
     *
     * Example:
     * ```php
     * // パス中の最後のディレクトリを取得
     * that(strrstr("path/to/1:path/to/2:path/to/3", ":"))->isSame('path/to/3');
     * // $after_needle を false にすると逆の動作になる
     * that(strrstr("path/to/1:path/to/2:path/to/3", ":", false))->isSame('path/to/1:path/to/2:');
     * // （参考）strrchr と違い、文字列が使えるしその文字そのものは含まれない
     * that(strrstr("A\r\nB\r\nC", "\r\n"))->isSame('C');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 調べる文字列
     * @param string $needle 検索文字列
     * @param bool $after_needle $needle より後ろを返すか
     * @return ?string
     */
    function strrstr(?string $haystack, ?string $needle, $after_needle = true)
    {
        // return strrev(strstr(strrev($haystack), strrev($needle), $after_needle));

        $lastpos = mb_strrpos($haystack, $needle);
        if ($lastpos === false) {
            return null;
        }

        if ($after_needle) {
            return mb_substr($haystack, $lastpos + mb_strlen($needle));
        }
        else {
            return mb_substr($haystack, 0, $lastpos + mb_strlen($needle));
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\strtr_escaped') || (new \ReflectionFunction('ryunosuke\\ltsv\\strtr_escaped'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\strtr_escaped')) {
    /**
     * エスケープを考慮して strtr する
     *
     * 「エスケープ」についての詳細は strpos_escaped を参照。
     *
     * $replace_pairs は [from => to] な配列を指定する。
     * to がクロージャの場合はキーとオフセットでコールバックされる。
     *
     * strtr と同様、最も長いキーから置換を行い、置換後の文字列は対象にならない。
     *
     * Example:
     * ```php
     * # 分かりにくいので \ ではなく % をエスケープ文字とする
     * that(strtr_escaped('XYZ ab %% %s', [
     *     'ab'  => 'AB',  // 2. 1 で置換された文字は対象にならない
     *     'A'   => '%a',  // 使われない
     *     'Z'   => '%z',  // 使われない
     *     '%%'  => 'p',   // 普通に置換される
     *     's'   => 'S',   // エスケープが対象なので置換されない（%s は文字 "s" ではない（\n が文字 "n" ではないのと同じ））
     *     'XYZ' => 'abc', // 1. 後ろにあるがまず置換される
     * ], '%'))->isSame('abc AB p %s');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $replace_pairs 置換するペア
     * @param string $escape エスケープ文字
     * @return string 置換された文字列
     */
    function strtr_escaped(?string $string, $replace_pairs, $escape = '\\')
    {
        uksort($replace_pairs, fn($a, $b) => strlen($b) - strlen($a));
        $froms = array_keys($replace_pairs);

        $offset = 0;
        while (($pos = strpos_escaped($string, $froms, $offset, $escape, $found)) !== null) {
            $to = $replace_pairs[$found];
            $replaced = $to instanceof \Closure ? $to($found, $pos) : $to;
            $string = substr_replace($string, $replaced, $pos, strlen($found));
            $offset = $pos + strlen($replaced);
        }
        return $string;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\blank_if') || (new \ReflectionFunction('ryunosuke\\ltsv\\blank_if'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\blank_if')) {
    /**
     * 値が空なら null を返す
     *
     * `is_empty($value) ? $value : null` とほぼ同じ。
     * 言ってしまえば「falsy な値を null に変換する」とも言える。
     *
     * ここでいう falsy とは php 標準の `empty` ではなく本ライブラリの `is_empty` であることに留意（"0" は空ではない）。
     * さらに利便性のため 0, 0.0 も空ではない判定をする（strpos や array_search などで「0 は意味のある値」という事が多いので）。
     * 乱暴に言えば「仮に文字列化したとき、情報量がゼロ」が falsy になる。
     *
     * - 「 `$var ?: 'default'` で十分なんだけど "0" が…」
     * - 「 `$var ?? 'default'` で十分なんだけど false が…」
     *
     * という状況はまれによくあるはず。
     *
     * ?? との親和性のため null を返す動作がデフォルトだが、そのデフォルト値は引数で渡すこともできる。
     * 用途は Example を参照。
     *
     * Example:
     * ```php
     * // falsy な値は null を返すので null 合体演算子でデフォルト値が得られる
     * that(blank_if(null) ?? 'default')->isSame('default');
     * that(blank_if('')   ?? 'default')->isSame('default');
     * // falsy じゃない値の場合は引数をそのまま返すので null 合体演算子には反応しない
     * that(blank_if(0)   ?? 'default')->isSame(0);   // 0 は空ではない
     * that(blank_if('0') ?? 'default')->isSame('0'); // "0" は空ではない
     * that(blank_if(1)   ?? 'default')->isSame(1);
     * that(blank_if('X') ?? 'default')->isSame('X');
     * // 第2引数で返る値を指定できるので下記も等価となる。ただし、php の仕様上第2引数が必ず評価されるため、関数呼び出しなどだと無駄な処理となる
     * that(blank_if(null, 'default'))->isSame('default');
     * that(blank_if('',   'default'))->isSame('default');
     * that(blank_if(0,    'default'))->isSame(0);
     * that(blank_if('0',  'default'))->isSame('0');
     * that(blank_if(1,    'default'))->isSame(1);
     * that(blank_if('X',  'default'))->isSame('X');
     * // 第2引数の用途は少し短く書けることと演算子の優先順位のつらみの回避程度（`??` は結構優先順位が低い。下記を参照）
     * that(0 < blank_if(null) ?? 1)->isFalse();  // (0 < null) ?? 1 となるので false
     * that(0 < blank_if(null, 1))->isTrue();     // 0 < 1 となるので true
     * that(0 < (blank_if(null) ?? 1))->isTrue(); // ?? で同じことしたいならこのように括弧が必要
     *
     * # ここから下は既存言語機構との比較（愚痴っぽいので読まなくてもよい）
     *
     * // エルビス演算子は "0" にも反応するので正直言って使いづらい（php における falsy の定義は広すぎる）
     * that(null ?: 'default')->isSame('default');
     * that(''   ?: 'default')->isSame('default');
     * that(1    ?: 'default')->isSame(1);
     * that('0'  ?: 'default')->isSame('default'); // こいつが反応してしまう
     * that('X'  ?: 'default')->isSame('X');
     * // 逆に null 合体演算子は null にしか反応しないので微妙に使い勝手が悪い（php の標準関数が false を返したりするし）
     * that(null ?? 'default')->isSame('default'); // こいつしか反応しない
     * that(''   ?? 'default')->isSame('');
     * that(1    ?? 'default')->isSame(1);
     * that('0'  ?? 'default')->isSame('0');
     * that('X'  ?? 'default')->isSame('X');
     * // 恣意的な例だが、 array_search は false も 0 も返し得るので ?: は使えない。 null を返すこともないので ?? も使えない（エラーも吐かない）
     * that(array_search('a', ['a', 'b', 'c']) ?: 'default')->isSame('default'); // 見つかったのに 0 に反応するので 'default' になってしまう
     * that(array_search('x', ['a', 'b', 'c']) ?? 'default')->isSame(false);     // 見つからないので 'default' としたいが false になってしまう
     * // 要するに単に「見つからなかった場合に 'default' としたい」だけなんだが、下記のようにめんどくさいことをせざるを得ない
     * that(array_search('x', ['a', 'b', 'c']) === false ? 'default' : array_search('x', ['a', 'b', 'c']))->isSame('default'); // 3項演算子で2回呼ぶ
     * that(($tmp = array_search('x', ['a', 'b', 'c']) === false) ? 'default' : $tmp)->isSame('default');                      // 一時変数を使用する（あるいは if 文）
     * // このように書きたかった
     * that(blank_if(array_search('x', ['a', 'b', 'c'])) ?? 'default')->isSame('default'); // null 合体演算子版
     * that(blank_if(array_search('x', ['a', 'b', 'c']), 'default'))->isSame('default');   // 第2引数版
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param mixed $var 判定する値
     * @param mixed $default 空だった場合のデフォルト値
     * @return mixed 空なら $default, 空じゃないなら $var をそのまま返す
     */
    function blank_if($var, $default = null)
    {
        if (is_object($var)) {
            // 文字列化できるかが優先
            if (is_stringable($var)) {
                return strlen($var) ? $var : $default;
            }
            // 次点で countable
            if (is_countable($var)) {
                return count($var) ? $var : $default;
            }
            return $var;
        }

        // 0, 0.0, "0" は false
        if ($var === 0 || $var === 0.0 || $var === '0') {
            return $var;
        }

        // 上記以外は empty に任せる
        return empty($var) ? $default : $var;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cast') || (new \ReflectionFunction('ryunosuke\\ltsv\\cast'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cast')) {
    /**
     * php の型変換に準じてキャストする
     *
     * 「php の型変換」とは strict_type=0 の時の暗黙の変換を指す（(type)等のキャストではない）。
     * eval で呼び出して判定するため、決して $type に外部入力を渡してはならない。
     *
     * この関数を使うシチュエーションはほぼない。
     * 呼び先のためならそれを普通に呼べば同じエラーになるし、用途が分かっているなら通常のキャストで十分。
     * 「呼び先が型宣言されていない」とか「numeric であることを担保したい」とか、限られた状況でしか使えないし使うべきではない。
     * 通常の(type)キャストが強すぎる（特に int）のため、「エラーになってくれる弱いキャスト」のようなイメージ。
     *
     * Example:
     * ```php
     * # 下記のように変換される
     * that(cast("1", 'int'))->isSame(1);
     * that(cast(1, 'string'))->isSame('1');
     * that(cast(1, 'int|string'))->isSame(1);
     * that(cast([], 'array|ArrayAccess'))->isSame([]);
     * that(cast($ao = new \ArrayObject(), 'ArrayAccess&Countable'))->isSame($ao);
     *
     * # 下記はすべて TypeError になる
     * // cast("hoge", 'int');             // 非数値文字列 は int に変換できない
     * // cast([], 'string');              // array は string に変換できない
     * // cast(new \stdClass(), 'bool');   // object は bool に変換できない
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param mixed $value 取得される配列・オブジェクト
     * @param string $type 型文字列
     * @param mixed $default 失敗したときのデフォルト値（null も立派な値なので例外を飛ばすためには未指定時にしなければならない）
     * @return mixed キャストされた値
     */
    function cast($value, string $type, $default = null)
    {
        // 気休め程度だが一応チェック（呼び元の責務なのであんまり厳密にやってもしょうがない）
        if (!preg_match('#^[?\\\\_a-z0-9|&()]+$#i', $type)) {
            throw new \InvalidArgumentException("$type is illegal type");
        }

        // php8.2 の DNF の模倣（8.2 に対応したらまるっと不要）
        if (strpbrk($type, '(&)') !== false) {
            if (!is_typeof($value, $type)) {
                if (func_num_args() === 3) {
                    return $default;
                }
                throw new \TypeError(sprintf("must be of type %s, %s given", $type, get_debug_type($type)));
            }
            // ↑でとりあえずマッチすることは保証されたのであとは変換のために | 繋ぎで呼び出せばよい
            $type = implode('|', preg_split('#([?()|&])#', $type, -1, PREG_SPLIT_NO_EMPTY));
        }

        // 緩い変換なので一部は互換型を追加する必要がある
        $types = array_map(fn($type) => trim(trim($type, '\\')), preg_split('#([?()|&])#', $type, -1, PREG_SPLIT_NO_EMPTY));
        if (in_array('Stringable', $types) && !in_array('string', $types)) {
            $types[] = 'string';
        }
        $type = implode('|', $types);

        // 判定・変換が複雑極まるため実際に投げてその値を返すのが最も間違いが少ない
        static $test_functions = [];
        $test_functions[$type] ??= eval("return static fn({$type} \$value) => \$value;");
        try {
            return $test_functions[$type]($value);
        }
        catch (\TypeError $e) {
            if (func_num_args() === 3) {
                return $default;
            }
            throw $e;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\instance_of') || (new \ReflectionFunction('ryunosuke\\ltsv\\instance_of'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\instance_of')) {
    /**
     * instanceof 構文の関数版
     *
     * ただし、bool ではなく ?object を返す。
     * つまり「instanceof が true ならそのまま、false なら null」を返す。
     * これは ?-> との親和性を考慮している。
     *
     * Example:
     * ```php
     *  // 実質的に下記は同じ
     * $object = new \Exception('message');
     * that(($object instanceof \Exception ? $object : null)?->getMessage())->is('message');
     * that(instance_of($object, \Exception::class)?->getMessage())->is('message');
     *
     * $object = new \stdClass();
     * that(($object instanceof \Exception ? $object : null)?->getMessage())->isNull();
     * that(instance_of($object, \Exception::class)?->getMessage())->isNull();
     * // Exception ではないが null でもないので下記のようにはできない
     * // $object?->getMessage();
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @template T as object
     * @param T $object 調べるオブジェクト
     * @param string|object $class クラス名
     * @return ?T $object が $class のインスタンスなら $object, そうでなければ null
     */
    function instance_of($object, $class)
    {
        return $object instanceof $class ? $object : null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\try_catch') || (new \ReflectionFunction('ryunosuke\\ltsv\\try_catch'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\try_catch')) {
    /**
     * try ～ catch 構文の関数版
     *
     * 例外機構構文が冗長なことがまれによくあるはず。
     *
     * Example:
     * ```php
     * // 例外が飛ばない場合は平和極まりない
     * $try = function ($a, $b, $c) {return [$a, $b, $c];};
     * that(try_catch($try, null, 1, 2, 3))->isSame([1, 2, 3]);
     * // 例外が飛ぶ場合は特殊なことをしなければ例外オブジェクトが返ってくる
     * $try = function () {throw new \Exception('tried');};
     * that(try_catch($try)->getMessage())->isSame('tried');
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param callable $try try ブロッククロージャ
     * @param ?callable $catch catch ブロッククロージャ
     * @param mixed ...$variadic $try に渡る引数
     * @return \Exception|mixed 例外が飛ばなかったら $try ブロックの返り値、飛んだなら $catch の返り値（デフォルトで例外オブジェクト）
     */
    function try_catch($try, $catch = null, ...$variadic)
    {
        return try_catch_finally($try, $catch, null, ...$variadic);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\try_catch_finally') || (new \ReflectionFunction('ryunosuke\\ltsv\\try_catch_finally'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\try_catch_finally')) {
    /**
     * try ～ catch ～ finally 構文の関数版
     *
     * 例外機構構文が冗長なことがまれによくあるはず。
     *
     * Example:
     * ```php
     * $finally_count = 0;
     * $finally = function () use (&$finally_count) {$finally_count++;};
     * // 例外が飛ぼうと飛ぶまいと $finally は実行される
     * $try = function ($a, $b, $c) {return [$a, $b, $c];};
     * that(try_catch_finally($try, null, $finally, 1, 2, 3))->isSame([1, 2, 3]);
     * that($finally_count)->isSame(1); // 呼ばれている
     * // 例外を投げるが、 $catch で握りつぶす
     * $try = function () {throw new \Exception('tried');};
     * that(try_catch_finally($try, null, $finally, 1, 2, 3)->getMessage())->isSame('tried');
     * that($finally_count)->isSame(2); // 呼ばれている
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param callable $try try ブロッククロージャ
     * @param ?callable $catch catch ブロッククロージャ
     * @param ?callable $finally finally ブロッククロージャ
     * @param mixed ...$variadic $try に渡る引数
     * @return \Exception|mixed 例外が飛ばなかったら $try ブロックの返り値、飛んだなら $catch の返り値（デフォルトで例外オブジェクト）
     */
    function try_catch_finally($try, $catch = null, $finally = null, ...$variadic)
    {
        if ($catch === null) {
            $catch = fn($v) => $v;
        }

        try {
            return $try(...$variadic);
        }
        catch (\Exception $tried_ex) {
            try {
                return $catch($tried_ex);
            }
            catch (\Exception $catched_ex) {
                throw $catched_ex;
            }
        }
        finally {
            if ($finally !== null) {
                $finally();
            }
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\try_close') || (new \ReflectionFunction('ryunosuke\\ltsv\\try_close'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\try_close')) {
    /**
     * try ～ finally 構文の close 特化版
     *
     * $try の呼び出し完了後に必ず close するようにする。
     * C# の using, java の try-with-resource みたいなもの。
     *
     * $resources 引数は [filename, mode], [filename => mode] のような配列を受け付け、中で fopen される。
     *
     * resource 型を想定しているが、オブジェクトの場合は close, free, dispose あたりを試みる。
     * このメソッド候補は互換性を問わず変更されることがある。
     * そもそも、stream 以外のリソースや完全不透明クラスはオマケのようなもので完全サポートはしないし互換性も考慮しない。
     *
     * close で例外が飛んだ場合は握りつぶされる。
     * この握りつぶした例外を取得する方法は今のところ存在しない。
     *
     * Example:
     * ```php
     * that(try_close(fn($fp, $string) => fwrite($fp, $string), $tmpfile = tmpfile(), 'test'))->is(4);
     * that(gettype($tmpfile))->is('resource (closed)'); // 閉じている
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param callable $try try ブロッククロージャ
     * @param object|resource|array ...$resources $try に渡る引数
     * @return mixed $try ブロックの返り値
     */
    function try_close($callback, ...$resources)
    {
        // hash to array
        foreach ($resources as $n => $resource) {
            if (is_array($resource) && is_hasharray($resource)) {
                array_splice($resources, $n, 1, iterator_to_array(arrays($resource)));
            }
        }
        // array to resource
        foreach ($resources as $n => $resource) {
            if (is_array($resource)) {
                $resources[$n] = fopen(...$resource);
            }
        }

        try {
            return $callback(...$resources);
        }
        catch (\Throwable $t) {
            // $t を設定するために catch ブロックが必要
            throw $t;
        }
        finally {
            // 逆順で閉じる（今のところあまり意味はないが C#/java もそうなってる）
            foreach (array_reverse($resources, true) as $n => $resource) {
                try {
                    $names = ['close', 'free', 'dispose'];

                    if (is_resource($resource)) {
                        $rtype = get_resource_type($resource);
                        if ($rtype === 'stream') {
                            fclose($resource);
                        }
                        else {
                            // fclose は stoream しか使えず、他は大抵専用の XXX_close のようなものが存在する
                            // @codeCoverageIgnoreStart
                            foreach ($names as $method) {
                                $funcname = explode(' ', $rtype)[0] . "_{$method}";
                                if (is_callable($funcname)) {
                                    $funcname($resource);
                                    break;
                                }
                            }
                            // @codeCoverageIgnoreEnd
                        }
                    }
                    if (is_object($resource)) {
                        foreach ($names as $method) {
                            if (is_callable([$resource, $method])) {
                                $resource->$method();
                                break;
                            }

                            // php8.0 からリソースから不透明クラスへの移行が進んでいる（リソースがクラスになっただけでメソッドが生えているわけではない）
                            // その変換は容易ではない（例えば↓は curl_close を想定しているが、CurlShareHandle 等のクラスもあり完全対応しない）
                            $funcname = (new \ReflectionClass($resource))->getExtension()?->getName() . "_{$method}";
                            if (is_callable($funcname)) {
                                $funcname($resource);
                                break;
                            }
                        }
                    }
                }
                catch (\Throwable $t2) {
                    // どうする？
                    // java の try-with-resource は close 例外を握りつぶして後から getSuppressed で取得できるようになっている
                    // php には getSuppressed なんてない。 previous があるが後から設定できないし設定済みかもしれないので上書きはよくない
                    // 文脈的には確実に閉じたいわけなので throw することもできないし、欲しい例外は $callback 内の例外であって close の例外ではない

                    // @codeCoverageIgnoreStart
                    if (1 === 2) {
                        // エラー化する？（欲しいとき以外は邪魔だし例外オブジェクトとしては取得できない）
                        trigger_error($t2, E_USER_WARNING);

                        // 溜めておいて error_get_last みたいな別関数で取得できるようにする？（「握りつぶした例外をとりあえず溜めておく場所」は有用な気もする）
                        $suppressed[$n] = $t2;

                        // 直代入？ （php8.2 以降は不可能）
                        if (isset($t)) {
                            $t->suppressed = $t2;
                        }
                    }
                    // @codeCoverageIgnoreEnd
                }
            }
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\try_finally') || (new \ReflectionFunction('ryunosuke\\ltsv\\try_finally'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\try_finally')) {
    /**
     * try ～ finally 構文の関数版
     *
     * 例外は投げっぱなす。例外機構構文が冗長なことがまれによくあるはず。
     *
     * Example:
     * ```php
     * $finally_count = 0;
     * $finally = function () use (&$finally_count) {$finally_count++;};
     * // 例外が飛ぼうと飛ぶまいと $finally は実行される
     * $try = function ($a, $b, $c) {return [$a, $b, $c];};
     * that(try_finally($try, $finally, 1, 2, 3))->isSame([1, 2, 3]);
     * that($finally_count)->isSame(1); // 呼ばれている
     * // 例外は投げっぱなすが、 $finally は実行される
     * $try = function () {throw new \Exception('tried');};
     * try {try_finally($try, $finally, 1, 2, 3);} catch(\Exception $e){}
     * that($finally_count)->isSame(2); // 呼ばれている
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param callable $try try ブロッククロージャ
     * @param ?callable $finally finally ブロッククロージャ
     * @param mixed ...$variadic $try に渡る引数
     * @return \Exception|mixed 例外が飛ばなかったら $try ブロックの返り値、飛んだなら $catch の返り値（デフォルトで例外オブジェクト）
     */
    function try_finally($try, $finally = null, ...$variadic)
    {
        return try_catch_finally($try, fn($arg) => throw $arg, $finally, ...$variadic);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\try_null') || (new \ReflectionFunction('ryunosuke\\ltsv\\try_null'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\try_null')) {
    /**
     * 例外を握りつぶす try 構文
     *
     * 例外機構構文が冗長なことがまれによくあるはず。
     *
     * Example:
     * ```php
     * // 例外が飛ばない場合は平和極まりない
     * $try = function ($a, $b, $c) {return [$a, $b, $c];};
     * that(try_null($try, 1, 2, 3))->isSame([1, 2, 3]);
     * // 例外が飛ぶ場合は null が返ってくる
     * $try = function () {throw new \Exception('tried');};
     * that(try_null($try))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param callable $try try ブロッククロージャ
     * @param mixed ...$variadic $try に渡る引数
     * @return mixed 例外が飛ばなかったら $try ブロックの返り値、飛んだなら null
     */
    function try_null($try, ...$variadic)
    {
        try {
            return $try(...$variadic);
        }
        catch (\Exception) {
            return null;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\try_return') || (new \ReflectionFunction('ryunosuke\\ltsv\\try_return'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\try_return')) {
    /**
     * 例外が飛んだら例外オブジェクトを返す
     *
     * 例外機構構文が冗長なことがまれによくあるはず。
     *
     * Example:
     * ```php
     * // 例外が飛ばない場合は平和極まりない
     * $try = function ($a, $b, $c) {return [$a, $b, $c];};
     * that(try_return($try, 1, 2, 3))->isSame([1, 2, 3]);
     * // 例外が飛ぶ場合は例外オブジェクトが返ってくる
     * $try = function () {throw new \Exception('tried');};
     * that(try_return($try))->IsInstanceOf(\Exception::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param callable $try try ブロッククロージャ
     * @param mixed ...$variadic $try に渡る引数
     * @return mixed 例外が飛ばなかったら $try ブロックの返り値、飛んだなら null
     */
    function try_return($try, ...$variadic)
    {
        try {
            return $try(...$variadic);
        }
        catch (\Exception $tried_ex) {
            return $tried_ex;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\base62_decode') || (new \ReflectionFunction('ryunosuke\\ltsv\\base62_decode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\base62_decode')) {
    /**
     * 数値とアルファベットで base62 デコードする
     *
     * 対で使うと思うので base62_encode を参照。
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $string base62 文字列
     * @return string 変換元文字列
     */
    function base62_decode($string)
    {
        // あくまで数値として扱うので先頭の 0 は吹き飛んでしまう
        $zeropos = strspn($string, "0");
        $zeroprefix = str_repeat("\0", $zeropos);
        $string = substr($string, $zeropos);

        // php<8.2 の str_split は [""] を返すし gmp が扱うのはあくまで数値なので空文字は特別扱いとする
        if (!strlen($string)) {
            return $zeroprefix;
        }

        // 隠し第2引数が false の場合は gmp を使わない（ロジックのテスト用なので実運用で渡してはならない）
        if (extension_loaded('gmp') && !(func_num_args() === 2 && func_get_arg(1) === false)) {
            return $zeroprefix . gmp_export(gmp_init($string, 62));
        }

        static $basechars_assoc = null;
        $basechars_assoc ??= array_flip(str_split('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'));

        $chars = str_split($string);
        $base62 = array_map(fn($c) => $basechars_assoc[$c] ?? throw new \InvalidArgumentException("string is not an base62"), $chars);
        $bytes = base_convert_array($base62, 62, 256);
        return $zeroprefix . implode('', array_map('chr', $bytes));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\base62_encode') || (new \ReflectionFunction('ryunosuke\\ltsv\\base62_encode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\base62_encode')) {
    /**
     * 数値とアルファベットで base62 エンコードする
     *
     * あくまでエンコードであって引数は文字列として扱う。つまり数値の基数変換ではない。
     *
     * base64 と違い、下記の特徴がある。
     * - =パディングなし
     * - 記号が入らない（完全に URL セーフ）
     * - ASCII 順（元の推移律が維持される）
     *
     * 変換効率もあまり変わらないため、文字列が小さい間はほぼ base64_encode の上位互換に近い。
     * ただし gmp が入っていないと猛烈に遅い。
     *
     * Example:
     * ```php
     * that(base62_encode('abcdefg'))->isSame('21XiSSifQN');
     * that(base62_decode('21XiSSifQN'))->isSame('abcdefg');
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $string 変換元文字列
     * @return string base62 文字列
     */
    function base62_encode($string)
    {
        // あくまで数値として扱うので先頭の 0 は吹き飛んでしまう
        $zeropos = strspn($string, "\0");
        $zeroprefix = str_repeat("0", $zeropos);
        $string = substr($string, $zeropos);

        // php<8.2 の str_split は [""] を返すし gmp が扱うのはあくまで数値なので空文字は特別扱いとする
        if (!strlen($string)) {
            return $zeroprefix;
        }

        // 隠し第2引数が false の場合は gmp を使わない（ロジックのテスト用なので実運用で渡してはならない）
        if (extension_loaded('gmp') && !(func_num_args() === 2 && func_get_arg(1) === false)) {
            return $zeroprefix . gmp_strval(gmp_import($string), 62);
        }

        static $basechars_index = null;
        $basechars_index ??= str_split('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz');

        $chars = str_split($string);
        $bytes = array_map('ord', $chars);
        $base62 = base_convert_array($bytes, 256, 62);
        return $zeroprefix . implode('', array_map(fn($v) => $basechars_index[$v], $base62));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\base64url_decode') || (new \ReflectionFunction('ryunosuke\\ltsv\\base64url_decode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\base64url_decode')) {
    /**
     * url safe な base64_decode
     *
     * 対で使うと思うので base64_encode を参照。
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $string base64url 文字列
     * @return string 変換元文字列
     */
    function base64url_decode($string)
    {
        return base64_decode(strtr($string, ['-' => '+', '_' => '/']));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\base64url_encode') || (new \ReflectionFunction('ryunosuke\\ltsv\\base64url_encode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\base64url_encode')) {
    /**
     * url safe な base64_encode
     *
     * れっきとした RFC があるのかは分からないが '+' => '-', '/' => '_' がデファクトだと思うのでそのようにしてある。
     * パディングの = も外す。
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $string 変換元文字列
     * @return string base64url 文字列
     */
    function base64url_encode($string)
    {
        return rtrim(strtr(base64_encode($string), ['+' => '-', '/' => '_']), '=');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\dataurl_decode') || (new \ReflectionFunction('ryunosuke\\ltsv\\dataurl_decode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\dataurl_decode')) {
    /**
     * DataURL をデコードする
     *
     * Example:
     * ```php
     * that(dataurl_decode("data:text/plain;charset=US-ASCII,hello%2C%20world"))->isSame('hello, world');
     * that(dataurl_decode("data:text/plain;charset=US-ASCII;base64,aGVsbG8sIHdvcmxk", $metadata))->isSame('hello, world');
     * that($metadata)->is([
     *     "mimetype" => "text/plain",
     *     "charset"  => "US-ASCII",
     *     "base64"   => true,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $url DataURL
     * @param array $metadata スキームのメタ情報が格納される
     * @return ?string 元データ。失敗時は null
     */
    function dataurl_decode($url, &$metadata = [])
    {
        $pos = strpos($url, ',');
        $head = substr($url, 0, $pos);
        $body = substr($url, $pos + 1);

        if (!preg_match('#^data:(?<mimetype>[^;]+?)?(;charset=(?<charset>[^;]+?))?(;(?<base64>[^;]+?))?$#iu', $head, $matches, PREG_UNMATCHED_AS_NULL)) {
            return null;
        }

        $metadata = [
            'mimetype' => $matches['mimetype'] ?? null,
            'charset'  => $matches['charset'] ?? null,
            'base64'   => isset($matches['base64']),
        ];

        $decoder = function ($data) use ($metadata) {
            if ($metadata['base64']) {
                return base64_decode($data, true);
            }
            else {
                return rawurldecode($data);
            }
        };

        $decoded = $decoder($body);
        if ($decoded === false) {
            return null;
        }

        if ($metadata['charset'] !== null) {
            if (!(mb_compatible_encoding($metadata['charset'], mb_internal_encoding()) ?? true)) {
                $decoded = mb_convert_encoding($decoded, mb_internal_encoding(), $metadata['charset']);
            }
        }

        return $decoded;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\dataurl_encode') || (new \ReflectionFunction('ryunosuke\\ltsv\\dataurl_encode'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\dataurl_encode')) {
    /**
     * DataURL をエンコードする
     *
     * $metadata で mimetype や エンコード等を指定できる。
     * 指定されていない場合、自動検出して埋め込まれる。
     *
     * - mimetype(?string): 特筆無し
     * - charset(?string): 自動検出は mime 名になる。明示指定はそのまま埋め込まれる
     * - base64(?bool): true:base64encode, false:urlencode, null: raw
     *   - null の raw はスキームとしては base64 となる。つまり既に base64 の文字列が手元にある場合（変換したくない場合）に指定する
     *
     * Example:
     * ```php
     * that(dataurl_encode("hello, world", ['base64' => false]))->isSame("data:text/plain;charset=US-ASCII,hello%2C%20world");
     * that(dataurl_encode("hello, world", ['mimetype' => 'text/csv', 'charset' => 'hoge']))->isSame("data:text/csv;charset=hoge;base64,aGVsbG8sIHdvcmxk");
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $data エンコードするデータ
     * @param array $metadata エンコードオプション
     * @return string DataURL
     */
    function dataurl_encode($data, $metadata = [])
    {
        if (!isset($metadata['mimetype'], $metadata['charset'])) {
            try {
                $finfo = finfo_open();
                [$mimetype, $charset] = preg_split('#;\\s#', finfo_buffer($finfo, $data, FILEINFO_MIME), 2, PREG_SPLIT_NO_EMPTY);

                $metadata['mimetype'] ??= $mimetype;
                $metadata['charset'] ??= mb_preferred_mime_name(explode('=', $charset, 2)[1]);
            }
            finally {
                finfo_close($finfo);
            }
        }

        if (!array_key_exists('base64', $metadata)) {
            $metadata['base64'] = true;
        }

        $encoder = function ($data) use ($metadata) {
            if ($metadata['base64'] === null) {
                return $data;
            }

            if ($metadata['base64']) {
                return base64_encode($data);
            }
            else {
                return rawurlencode($data);
            }
        };

        return "data:"
            . $metadata['mimetype']
            . (strlen($metadata['charset']) ? ";charset=" . $metadata['charset'] : "")
            . (($metadata['base64'] ?? true) ? ';base64' : '')
            . "," . $encoder($data);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\query_build') || (new \ReflectionFunction('ryunosuke\\ltsv\\query_build'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\query_build')) {
    /**
     * 数値キーを削除する http_build_query
     *
     * php の世界において配列のクエリ表現は `var[]=1&var[]=2` で事足りる。
     * しかし http_build_query では数値キーでも必ず `var[0]=1&var[1]=2` になる。
     * それはそれで正しいし、他言語との連携が必要な場合はそうせざるを得ない状況もあるが、単純に php だけで配列を表したい場合は邪魔だし文字長が長くなる。
     * この関数を使うと数値キーを削除し、`var[]=1&var[]=2` のようなクエリ文字列を生成できる。
     *
     * シグネチャは http_build_query と同じで、 $numeric_prefix に数値的文字列を与えたときのみ動作が変化する。
     * （$numeric_prefix の意味を考えればこの引数に数値的文字列を与える意味は皆無だろうので流用している）。
     *
     * - 1 を与えると最前列を残して [] (%5B%5D) が置換される
     * - 2 を与えると最前列とその右を残して [] (%5B%5D) が置換される
     * - 要するに正数を与えると「abs(n) 個を残して [] (%5B%5D) を置換する」という指定になる
     * - -1 を与えると最後尾の [] (%5B%5D) が置換される
     * - -2 を与えると最後尾とその左の [] (%5B%5D) が置換される
     * - 要するに負数を与えると「右から abs(n) 個の [] (%5B%5D) を置換する」という指定になる
     *
     * この仕様は `v[][]=1&v[][]=2` のようなときにおいしくないためである。
     * これは `$v=[[1], [2]]` のような値になるが、この場合 `$v=[[1, 2]]` という値が欲しい、という事が多い。
     * そのためには `v[0][]=1&v[0][]=2` のようにする必要があるための数値指定である。
     *
     * $brackets で配列ブラケット文字を指定できるが、現実的には下記の3択だろう。
     * - ['%5B','%5D']: デフォルトのパーセントエンコーディング文字
     * - ['[', ']']: [] のままにする（ブラケットは必ずしもパーセントエンコーディングが必須ではない）
     * - ['', '']: ブラケットを削除する（他言語のために配列パラメータを抑止したいことがある）
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param array|object $data クエリデータ
     * @param string|int|null $numeric_prefix 数値キープレフィックス
     * @param string|null $arg_separator クエリセパレータ
     * @param int $encoding_type エンコードタイプ
     * @param string[]|string|null $brackets 配列ブラケット文字
     * @return string クエリ文字列
     */
    function query_build($data, $numeric_prefix = null, $arg_separator = null, $encoding_type = \PHP_QUERY_RFC1738, $brackets = null)
    {
        $data = arrayval($data, false);
        if (!$data) {
            return '';
        }

        $arg_separator ??= ini_get('arg_separator.output');
        $brackets ??= ['%5B', '%5D'];

        if (!is_array($brackets)) {
            $brackets = [$brackets, ''];
        }
        $brackets = array_values($brackets);

        $REGEX = '%5B\d+%5D';
        $NOSEQ = implode('', $brackets);
        if ($numeric_prefix === null || ctype_digit(trim($numeric_prefix, '-+'))) {
            $queries = explode($arg_separator, http_build_query($data, '', $arg_separator, $encoding_type));
        }
        else {
            $queries = explode($arg_separator, http_build_query($data, $numeric_prefix, $arg_separator, $encoding_type));
        }
        foreach ($queries as &$q) {
            [$k, $v] = explode('=', $q, 2);

            // 0は置換しないを意味する
            if ($numeric_prefix === 0) {
                // do nothing
                assert($numeric_prefix === 0);
            }
            // null は無制限置換
            elseif ($numeric_prefix === null) {
                $k = preg_replace("#$REGEX#u", $NOSEQ, $k);
            }
            else {
                $count = $numeric_prefix > 0 ? 0 : -preg_match_all("#$REGEX#u", $k);
                $k = preg_replace_callback("#$REGEX#u", function ($m) use (&$count, $numeric_prefix, $NOSEQ) {
                    return $count++ >= $numeric_prefix ? $NOSEQ : $m[0];
                }, $k);
            }

            $k = str_replace(['%5B', '%5D'], $brackets, $k);

            $q = "$k=$v";
        }

        return implode($arg_separator, $queries);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\query_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\query_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\query_parse')) {
    /**
     * parse_str の返り値版
     *
     * 標準の parse_str は参照で受ける謎シグネチャなのでそれを返り値に変更したもの。
     * と同時に parse_str はドットやスペースをアンダースコアに置換するため、それを避ける独自実装がある。
     * $arg_separator や $encoding_type を指定すると独自実装で動きかつその引数の挙動でパースされる。
     *
     * Example:
     * ```php
     * // 普通に使えばネイティブの返り値版
     * that(query_parse('a.b=ab&x[y][z]=xyz'))->is([
     *     'a_b' => 'ab',
     *     'x'   => ['y' => ['z' => 'xyz']],
     * ]);
     * // パラメータを渡せば独自実装（& 以外を指定できたり . を維持できたりする）
     * that(query_parse('a.b=ab|x[y][z]=xyz', '|'))->is([
     *     'a.b' => 'ab',
     *     'x'   => ['y' => ['z' => 'xyz']],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $query クエリ文字列
     * @param ?string $arg_separator クエリ文字列
     * @param ?int $encoding_type クエリ文字列
     * @return array クエリのパース結果配列
     */
    function query_parse($query, $arg_separator = null, $encoding_type = null)
    {
        // 指定されていないなら php ネイティブ
        if ($arg_separator === null && $encoding_type === null) {
            parse_str($query, $result);
            return $result;
        }

        $arg_separator ??= ini_get('arg_separator.input');
        $encoding_type ??= PHP_QUERY_RFC1738;

        $params = multiexplode(str_split($arg_separator), $query);
        $result = [];
        foreach ($params as $param) {
            [$name, $value] = explode("=", trim($param), 2) + [1 => ''];
            if ($name === '') {
                continue;
            }
            if ($encoding_type === PHP_QUERY_RFC1738) {
                $name = urldecode($name);
                $value = urldecode($value);
            }
            elseif ($encoding_type === PHP_QUERY_RFC3986) {
                $name = rawurldecode($name);
                $value = rawurldecode($value);
            }

            if (preg_match_all('#\[([^]]*)\]#mu', $name, $matches, PREG_OFFSET_CAPTURE)) {
                $name = substr($name, 0, $matches[0][0][1]);
                $keys = array_column($matches[1], 0);

                $receiver = &$result[$name];
                foreach ($keys as $key) {
                    if (strlen($key) === 0) {
                        if (!is_array($receiver)) {
                            $receiver = [];
                        }
                        $key = max(array_filter(array_keys($receiver ?? []), 'is_int') ?: [-1]) + 1;
                    }
                    $receiver = &$receiver[$key];
                }
            }
            else {
                $receiver = &$result[$name];
            }

            $receiver = $value;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\uri_build') || (new \ReflectionFunction('ryunosuke\\ltsv\\uri_build'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\uri_build')) {
    /**
     * parse_uri の逆
     *
     * URI のパーツを与えると URI として構築する。
     * パーツは不完全でも良い。例えば scheme を省略すると "://" すら付かない URI が生成される。
     *
     * "query" パートだけは配列が許容される。その場合クエリ文字列に変換される。
     *
     * Example:
     * ```php
     * // 完全指定
     * that(uri_build([
     *     'scheme'   => 'http',
     *     'user'     => 'user',
     *     'pass'     => 'pass',
     *     'host'     => 'localhost',
     *     'port'     => '80',
     *     'path'     => '/path/to/file',
     *     'query'    => ['id' => 1],
     *     'fragment' => 'hash',
     * ]))->isSame('http://user:pass@localhost:80/path/to/file?id=1#hash');
     * // 一部だけ指定
     * that(uri_build([
     *     'scheme'   => 'http',
     *     'host'     => 'localhost',
     *     'path'     => '/path/to/file',
     *     'fragment' => 'hash',
     * ]))->isSame('http://localhost/path/to/file#hash');
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param array $parts URI の各パーツ配列
     * @param array $options オプション
     * @return string URI 文字列
     */
    function uri_build($parts, $options = [])
    {
        $parts += [
            'scheme'   => '',
            'user'     => '',
            'pass'     => '',
            'host'     => '',
            'port'     => '',
            'path'     => '',
            'query'    => '',
            'fragment' => '',
        ];
        $options = array_replace_recursive([
            'query' => [
                'index'     => 0,
                'bracket'   => null,
                'separator' => ini_get('arg_separator.output'),
            ],
        ], $options);

        $parts['user'] = rawurlencode($parts['user']);
        $parts['pass'] = rawurlencode($parts['pass']);
        $parts['host'] = filter_var($parts['host'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? "[{$parts['host']}]" : $parts['host'];
        $parts['path'] = ltrim($parts['path'], '/');
        if (is_array($parts['query'])) {
            $parts['query'] = query_build(
                $parts['query'],
                $options['query']['index'],
                $options['query']['separator'],
                \PHP_QUERY_RFC1738,
                $options['query']['bracket'],
            );
        }

        $uri = '';
        $uri .= concat($parts['scheme'], '://');
        $uri .= concat($parts['user'] . concat(':', $parts['pass']), '@');
        $uri .= concat($parts['host']);
        $uri .= concat(':', $parts['port']);
        $uri .= concat('/', $parts['path']);
        $uri .= concat('?', $parts['query']);
        $uri .= concat('#', rawurlencode($parts['fragment']));
        return $uri;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\uri_parse') || (new \ReflectionFunction('ryunosuke\\ltsv\\uri_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\uri_parse')) {
    /**
     * parse_url の仕様を少しいじったもの
     *
     * parse_url とは下記が異なる。
     *
     * - "単一文字列" はホスト名とみなされる（parse_url はパスとみなされる）
     * - パートがなくてもキー自体は生成される（そしてその値は $default で指定したもの）
     * - query は配列で返す（parse_str される）
     * - パート値をスカラー値で返すことはできない（必ず8要素の配列を返す）
     *
     * Example:
     * ```php
     * // 完全指定
     * that(uri_parse('http://user:pass@localhost:80/path/to/file?id=1#hash'))->is([
     *     'scheme'   => 'http',
     *     'user'     => 'user',
     *     'pass'     => 'pass',
     *     'host'     => 'localhost',
     *     'port'     => '80',
     *     'path'     => '/path/to/file',
     *     'query'    => ['id' => 1],
     *     'fragment' => 'hash',
     * ]);
     * // デフォルト値つき
     * that(uri_parse('localhost/path/to/file', [
     *     'scheme'   => 'http', // scheme のデフォルト値
     *     'user'     => 'user', // user のデフォルト値
     *     'port'     => '8080', // port のデフォルト値
     *     'host'     => 'hoge', // host のデフォルト値
     * ]))->is([
     *     'scheme'   => 'http',      // scheme はないのでデフォルト値が使われている
     *     'user'     => 'user',      // user はないのでデフォルト値が使われている
     *     'pass'     => '',
     *     'host'     => 'localhost', // host はあるのでデフォルト値が使われていない
     *     'port'     => '8080',      // port はないのでデフォルト値が使われている
     *     'path'     => '/path/to/file',
     *     'query'    => [],
     *     'fragment' => '',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $uri パースする URI
     * @param array|string $default $uri に足りないパーツがあった場合のデフォルト値。文字列を与えた場合はそのパース結果がデフォルト値になる
     * @return array URI の各パーツ配列
     */
    function uri_parse($uri, $default = [])
    {
        /** @noinspection RequiredAttributes */
        $regex = "
            (?:(?<scheme>[a-z][-+.0-9a-z]*)://)?
            (?:
              (?: (?<user>(?:[-.~\\w]|%[0-9a-f][0-9a-f]|[!$&-,;=])*)?
              (?::(?<pass>(?:[-.~\\w]|%[0-9a-f][0-9a-f]|[!$&-,;=])*))?@)?
            )?
            (?<host>((?:\\[[0-9a-f:]+\\]) | (?:[-.~\\w]|%[0-9a-f][0-9a-f]|[!$&-,;=]))*)
            (?::(?<port>\d{0,5}))?
            (?<path>(?:/(?: [-.~\\w!$&'()*+,;=:@] | %[0-9a-f]{2} )* )*)?
            (?:\\?(?<query>[^\\#]*))?
            (?:\\#(?<fragment>.*))?
        ";

        $default_default = [
            'scheme'   => '',
            'user'     => '',
            'pass'     => '',
            'host'     => '',
            'port'     => '',
            'path'     => '',
            'query'    => '',
            'fragment' => '',
        ];

        // 配列以外はパースしてそれをデフォルトとする
        if (!is_array($default)) {
            $default = preg_capture("#^$regex\$#ix", (string) $default, $default_default);
        }

        // パース。先頭の // はスキーム省略とみなすので除去する
        $uri = preg_splice('#^//#', '', $uri);
        $parts = preg_capture("#^$regex\$#ix", $uri, $default + $default_default);

        // 諸々調整（認証エンコード、IPv6、パス / の正規化、クエリ配列化）
        $parts['user'] = $parts['user'] === null ? null : rawurldecode($parts['user']);
        $parts['pass'] = $parts['pass'] === null ? null : rawurldecode($parts['pass']);
        $parts['host'] = $parts['host'] === null ? null : preg_splice('#^\\[(.+)]$#', '$1', $parts['host']);
        $parts['path'] = $parts['path'] === null ? null : rawurldecode(concat('/', ltrim($parts['path'], '/')));
        $parts['fragment'] = $parts['fragment'] === null ? null : rawurldecode($parts['fragment']);

        if (is_string($parts['query'])) {
            parse_str($parts['query'], $parts['query']);
        }

        return $parts;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\benchmark') || (new \ReflectionFunction('ryunosuke\\ltsv\\benchmark'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\benchmark')) {
    /**
     * 簡易ベンチマークを取る
     *
     * 「指定ミリ秒内で何回コールできるか？」でベンチする。
     * メモリ使用量も取れるが ticks を利用しているのであまり正確ではないし、モノによっては計測できない（バージョンアップで memory_reset_peak_usage に変更される）。
     *
     * $suite は ['表示名' => $callable] 形式の配列。
     * 表示名が与えられていない場合、それらしい名前で表示する。
     *
     * Example:
     * ```php
     * // intval と int キャストはどちらが早いか調べる
     * benchmark([
     *     'intval',
     *     'intcast' => fn($v) => (int) $v,
     * ], ['12345'], 10);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param array|callable $suite ベンチ対象処理
     * @param array $args 各ケースに与えられる引数
     * @param int $millisec 呼び出しミリ秒
     * @param bool $output true だと標準出力に出力される
     * @return array ベンチ結果の配列
     */
    function benchmark($suite, $args = [], $millisec = 1000, $output = true)
    {
        $benchset = [];
        foreach (arrayize($suite) as $name => $caller) {
            if (!is_callable($caller, false, $callname)) {
                throw new \InvalidArgumentException('caller is not callable.');
            }

            if (is_int($name)) {
                // クロージャは "Closure::__invoke" になるので "ファイル#開始行-終了行" にする
                if ($caller instanceof \Closure) {
                    $ref = new \ReflectionFunction($caller);
                    $callname = $ref->getFileName() . '#' . $ref->getStartLine() . '-' . $ref->getEndLine();
                }
                $name = $callname;
            }

            if (isset($benchset[$name])) {
                throw new \InvalidArgumentException('duplicated benchname.');
            }

            $closure = \Closure::fromCallable($caller);
            // for compatible (wait for memory_reset_peak_usage)
            try {
                // いったん受けて返すことで tick を誘発する
                // @codeCoverageIgnoreStart
                $caller = function (&...$args) use ($caller) {
                    $dummy = $caller(...$args);
                    return $dummy;
                };
                // @codeCoverageIgnoreEnd
                $closure = evaluate("declare(ticks=1);\n" . var_export3($caller, ['outmode' => 'eval']));
            }
            catch (\Throwable) { // @codeCoverageIgnore
                // do nothing
            }
            $benchset[$name] = $closure;
        }

        if (!$benchset) {
            throw new \InvalidArgumentException('benchset is empty.');
        }

        // opcache を利用するようなベンチはこの辺を切っておかないと正確な結果にならない
        // ウォームアップで mtime が更新され、その1秒以内にベンチが走るので一切 opcache が効かなくなるため
        $restore = ini_sets([
            'opcache.validate_timestamps'    => 0,
            'opcache.file_update_protection' => "0",
        ]);

        // ウォームアップ兼検証（大量に実行してエラーの嵐になる可能性があるのでウォームアップの時点でエラーがないかチェックする）
        $handler_restore = set_error_exception_handler();
        $assertions = [];
        foreach ($benchset as $name => $caller) {
            $args2 = $args;
            $assertions[$name] = $caller(...$args2);
        }
        $handler_restore();

        // 返り値の検証（ベンチマークという性質上、基本的に戻り値が一致しないのはおかしい）
        // rand/mt_rand, md5/sha1 のような例外はあるが、そんなのベンチしないし、クロージャでラップすればいいし、それでも邪魔なら @ で黙らせればいい
        $context = is_ansi(STDOUT) ? 'cli' : 'plain';
        $diffs = [];
        foreach ($assertions as $name => $return) {
            $diffs[var_pretty($return, [
                'context'   => $context,
                'limit'     => 1024,
                'maxcolumn' => 80,
                'return'    => true,
            ])][] = $name;
        }
        if (count($diffs) > 1) {
            $head = $body = [];
            foreach ($diffs as $return => $names) {
                $head[] = count($names) === 1 ? $names[0] : '(' . implode(' | ', $names) . ')';
                $body[implode(" & ", $names)] = $return;
            }
            trigger_error(sprintf("Results of %s are different.\n", implode(' & ', $head)));
            if (error_reporting() & E_USER_NOTICE) {
                // @codeCoverageIgnoreStart
                echo markdown_table([$body], [
                    'context' => $context,
                ]);
                // @codeCoverageIgnoreEnd
            }
        }

        // ベンチ
        $cpu_timer = cpu_timer();
        $tick = function () use (&$usage) {
            $usage = max($usage, memory_get_usage());
        };
        register_tick_function($tick);
        $stats = [];
        foreach ($benchset as $name => $caller) {
            $usage = null;
            gc_collect_cycles();
            $cpu_timer->start();
            $memory = memory_get_usage();
            $microtime = microtime(true);
            $end = $microtime + $millisec / 1000;
            $args2 = $args;
            for ($n = 0; ($t = microtime(true)) <= $end; $n++) {
                $caller(...$args2);
                $elapsed = microtime(true) - $t;
                $stats[$name]['fastest'] = min($stats[$name]['fastest'] ?? PHP_FLOAT_MAX, $elapsed);
                $stats[$name]['slowest'] = max($stats[$name]['slowest'] ?? PHP_FLOAT_MIN, $elapsed);
            }
            $stats[$name]['count'] = $n;
            $stats[$name]['mills'] = (microtime(true) - $microtime) / $n;
            $stats[$name]['cpu'] = $cpu_timer->result();
            $stats[$name]['memory'] = $usage === null ? null : $usage - $memory;
        }
        unregister_tick_function($tick);

        $restore();

        // 結果配列
        $result = [];
        $minmills = min(array_column($stats, 'mills'));
        uasort($stats, fn($a, $b) => $b['count'] <=> $a['count']);
        foreach ($stats as $name => $stat) {
            $result[$name] = [
                'name'    => $name,
                'cpu'     => $stat['cpu'],
                'memory'  => $stat['memory'],
                'called'  => $stat['count'],
                'fastest' => $stat['fastest'],
                'slowest' => $stat['slowest'],
                'mills'   => $stat['mills'],
                'ratio'   => $stat['mills'] / $minmills,
            ];
        }

        // 出力するなら出力
        if ($output) {
            $number_format = function ($value, $ratio = 1, $decimal = 0, $nullvalue = '') {
                return $value === null ? $nullvalue : number_format($value * $ratio, $decimal);
            };
            printf("Running %s cases (between %s ms):\n", count($benchset), $number_format($millisec));
            echo markdown_table(array_map(function ($v) use ($number_format) {
                return [
                    'name'        => $v['name'],
                    'cpu(user)'   => $number_format($v['cpu']['user'], 1000, 3),
                    'cpu(system)' => $number_format($v['cpu']['system'], 1000, 3),
                    'cpu(idle)'   => $number_format($v['cpu']['idle'], 1000, 3),
                    'memory(KB)'  => $number_format($v['memory'], 1 / 1024, 3, "N/A"),
                    'called'      => $number_format($v['called']),
                    'fastest(ms)' => $number_format($v['fastest'], 1000, 6),
                    'slowest(ms)' => $number_format($v['slowest'], 1000, 6),
                    'average(ms)' => $number_format($v['mills'], 1000, 6),
                    'ratio'       => $number_format($v['ratio'], 1, 3),
                ];
            }, $result));
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\built_in_server') || (new \ReflectionFunction('ryunosuke\\ltsv\\built_in_server'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\built_in_server')) {
    /**
     * ビルトインサーバーを起動する
     *
     * 単に別プロセスで php -S するだけなので本番では使用してはならない。
     * 少し小細工として下記を実装してある。
     *
     * - $router: クロージャを渡せる
     * - $options['last-modified']: true にすると存在するファイルの 304 キャッシュが有効になる
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param string $document_root 公開ディレクトリ兼カレントディレクトリ
     * @param string|callable $router ルータースクリプト or クロージャ
     * @param array $options オプション配列
     * @return \ProcessAsync|object プロセスオブジェクト
     */
    function built_in_server($document_root, $router = null, $options = [])
    {
        $options += [
            'host'          => '0.0.0.0', // bind アドレス
            'port'          => 8000,      // bind ポート
            'last-modified' => true,      // 静的ファイルの 304 キャッシュの有効無効
            // php.ini のエントリ
            '-d'            => [
                'opcache.enable' => 1,
                'uopz.disable'   => 1, // built in server で uopz が有効だとおかしなエラーを吐くことを確認
            ],
        ];

        // @codeCoverageIgnoreStart
        $mimetypes = GENERAL_MIMETYPE;
        $response304 = static function () use ($mimetypes) {
            //$file = $_SERVER['DOCUMENT_ROOT'] . $_SERVER['REQUEST_URI'];
            $file = $_SERVER['SCRIPT_FILENAME'];
            $ext = strtolower(pathinfo($file, PATHINFO_EXTENSION));
            if (file_exists($file) && $ext !== 'php') {
                $modifiedSince = filter_input(INPUT_SERVER, 'HTTP_IF_MODIFIED_SINCE');
                $lastModified = filemtime($file);
                if ($modifiedSince && strtotime($modifiedSince) >= $lastModified) {
                    http_response_code(304);
                    header('content-type:' . ($mimetypes[$ext] ?? 'text/plain'));
                }
                else {
                    http_response_code(200);
                    header('content-type:' . ($mimetypes[$ext] ?? 'text/plain'));
                    header('last-modified:' . gmdate('D, d M Y H:i:s \G\M\T', $lastModified));
                    readfile($file);
                }
                exit;
            }
        };
        // @codeCoverageIgnoreEnd

        $mainscript = null;
        if (is_string($router) && file_exists($router)) {
            $mainscript = $router;
        }
        elseif (is_callable($router)) {
            $autoload = array_merge([auto_loader()], function_configure('process.autoload'));
            $router_code = var_export3($router, true);
            $static_code = $options['last-modified'] ? var_export3($response304, true) . '();' : '';

            $maincode = '<?php
            $autoload = ' . var_export($autoload, true) . ';
            foreach ($autoload as $file) {
                require_once $file;
            }
            ' . $static_code . '
            return ' . $router_code . '();
        ';
            file_put_contents($mainscript = sys_get_temp_dir() . '/router-' . sha1($maincode) . '.php', $maincode);
        }
        elseif ($options['last-modified']) {
            $static_code = var_export3($response304, true) . '();';
            $maincode = '<?php
            ' . $static_code . '
            return false;
        ';
            file_put_contents($mainscript = sys_get_temp_dir() . '/router-' . sha1($maincode) . '.php', $maincode);
        }

        $process = process_async(php_binary(), array_filter([
            '-S' => "{$options['host']}:{$options['port']}",
            '-t' => $document_root,
            '-d' => array_maps((array) $options['-d'], fn($v, $k) => is_int($k) ? $v : "$k=$v"),
            $mainscript,
        ], fn($v) => $v !== null), '', $stdout, $stderr, $document_root);

        return $process;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cache') || (new \ReflectionFunction('ryunosuke\\ltsv\\cache'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cache')) {
    /**
     * シンプルにキャッシュする
     *
     * この関数は get/set/delete を兼ねる。
     * キャッシュがある場合はそれを返し、ない場合は $provider を呼び出してその結果をキャッシュしつつそれを返す。
     *
     * $provider に null を与えるとキャッシュの削除となる。
     *
     * Example:
     * ```php
     * $provider = fn() => rand();
     * // 乱数を返す処理だが、キャッシュされるので同じ値になる
     * $rand1 = cache('rand', $provider);
     * $rand2 = cache('rand', $provider);
     * that($rand1)->isSame($rand2);
     * // $provider に null を与えると削除される
     * cache('rand', null);
     * $rand3 = cache('rand', $provider);
     * that($rand1)->isNotSame($rand3);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param string $key キャッシュのキー
     * @param ?callable $provider キャッシュがない場合にコールされる callable
     * @param ?string $namespace 名前空間
     * @return mixed キャッシュ
     */
    function cache($key, $provider, $namespace = null)
    {
        static $cacheobject;
        $cacheobject ??= new class(function_configure('cachedir')) {
            const CACHE_EXT = '.php-cache';

            /** @var string キャッシュディレクトリ */
            private $cachedir;

            /** @var array 内部キャッシュ */
            private $cache;

            /** @var array 変更感知配列 */
            private $changed;

            public function __construct($cachedir)
            {
                $this->cachedir = $cachedir;
                $this->cache = [];
                $this->changed = [];
            }

            public function __destruct()
            {
                // 変更されているもののみ保存
                foreach ($this->changed as $namespace => $dummy) {
                    $filepath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    $content = "<?php\nreturn " . var_export($this->cache[$namespace], true) . ";\n";

                    $temppath = tempnam(sys_get_temp_dir(), 'cache');
                    if (file_put_contents($temppath, $content) !== false) {
                        @chmod($temppath, 0644);
                        if (!@rename($temppath, $filepath)) {
                            @unlink($temppath); // @codeCoverageIgnore
                        }
                    }
                }
            }

            public function has($namespace, $key)
            {
                // ファイルから読み込む必要があるので get しておく
                $this->get($namespace, $key);
                return array_key_exists($key, $this->cache[$namespace]);
            }

            public function get($namespace, $key)
            {
                // 名前空間自体がないなら作る or 読む
                if (!isset($this->cache[$namespace])) {
                    $nsarray = [];
                    $cachpath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    if (file_exists($cachpath)) {
                        $nsarray = require $cachpath;
                    }
                    $this->cache[$namespace] = $nsarray;
                }

                return $this->cache[$namespace][$key] ?? null;
            }

            public function set($namespace, $key, $value)
            {
                // 新しい値が来たら変更フラグを立てる
                if (!isset($this->cache[$namespace]) || !array_key_exists($key, $this->cache[$namespace]) || $this->cache[$namespace][$key] !== $value) {
                    $this->changed[$namespace] = true;
                }

                $this->cache[$namespace][$key] = $value;
            }

            public function delete($namespace, $key)
            {
                $this->changed[$namespace] = true;
                unset($this->cache[$namespace][$key]);
            }

            public function clear()
            {
                // インメモリ情報をクリアして・・・
                $this->cache = [];
                $this->changed = [];

                // ファイルも消す
                foreach (glob($this->cachedir . '/*' . self::CACHE_EXT) as $file) {
                    unlink($file);
                }
            }
        };

        // flush (for test)
        if ($key === null) {
            if ($provider === null) {
                $cacheobject->clear();
            }
            $cacheobject = null;
            return;
        }

        $namespace ??= __FILE__;

        $exist = $cacheobject->has($namespace, $key);
        if ($provider === null) {
            $cacheobject->delete($namespace, $key);
            return $exist;
        }
        if (!$exist) {
            $cacheobject->set($namespace, $key, $provider());
        }
        return $cacheobject->get($namespace, $key);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cache_fetch') || (new \ReflectionFunction('ryunosuke\\ltsv\\cache_fetch'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cache_fetch')) {
    /**
     * psr-16 cache で「無かったらコールバックを実行して set」する
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param \Psr\SimpleCache\CacheInterface $cacher キャッシュオブジェクト
     * @param string $key キャッシュキー
     * @param callable $provider データプロバイダ
     * @param ?int $ttl キャッシュ時間
     * @return mixed キャッシュデータ
     */
    function cache_fetch($cacher, $key, $provider, $ttl = null)
    {
        $data = $cacher->get($key);
        if ($data === null) {
            $data = $provider();
            $cacher->set($key, $data, $ttl);
        }
        return $data;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cacheobject') || (new \ReflectionFunction('ryunosuke\\ltsv\\cacheobject'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cacheobject')) {
    /**
     * psr-16 を実装したキャッシュオブジェクトを返す
     *
     * このオブジェクトはあくまで「他のパッケージに依存したくない」場合のデフォルト実装としての使用を想定している。
     *
     * - キャッシュはファイルシステムに保存される
     * - キャッシュキーの . はディレクトリ区切りとして使用される
     * - TTL を指定しなかったときのデフォルト値は約100年（実質無期限だろう）
     * - psr-16 にはない getOrSet(fetch) が生えている（利便性が非常に高く使用頻度が多いため）
     *
     * 性質上、参照されない期限切れキャッシュが溜まり続けるが $clean_probability を渡すと一定確率で削除される。
     * $clean_probability は 1 が 100%（必ず削除）、 0 が 0%（削除しない）である。
     * 削除処理は軽くはないため高頻度な実行は避けなければならない。
     * clean メソッドが生えているので明示的に呼ぶことも可能。
     *
     * psr/simple-cache （\Psr\SimpleCache\CacheInterface）が存在するなら implement される。
     * 存在しないなら素の無名クラスで返す。
     * 動作に違いはないが instanceoof や class_implements に違いが出てくるので注意。
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param ?string $directory キャッシュ保存ディレクトリ
     * @param float $clean_probability 不要キャッシュの削除確率
     * @return \Cacheobject psr-16 実装オブジェクト
     */
    function cacheobject($directory = null, $clean_probability = 0)
    {
        static $cacheobjects = [];

        $directory ??= function_configure('cachedir');
        $cacheobject = $cacheobjects[$directory] ??= new class($directory) {
            private $directory;
            private $entries = [];

            public function __construct(string $directory)
            {
                assert(strlen($directory));
                $this->directory = $directory;
            }

            public function __debugInfo()
            {
                $class = self::class;
                $props = (array) $this;

                // 全キャッシュは情報量としてでかすぎるが、何がどこに配置されているかくらいは有ってもいい
                $ekey = "\0$class\0entries";
                assert(array_key_exists($ekey, $props));
                $props[$ekey] = array_reduce(array_keys($props[$ekey]), fn($acc, $k) => $acc + [$k => $this->_getFilename($k)], []);

                return $props;
            }

            private function _exception(string $message = "", int $code = 0, \Throwable $previous = null): \Throwable
            {
                return interface_exists(\Psr\SimpleCache\InvalidArgumentException::class)
                    ? new class ( $message, $code, $previous ) extends \InvalidArgumentException implements \Psr\SimpleCache\InvalidArgumentException { }
                    : new class ( $message, $code, $previous ) extends \InvalidArgumentException { };
            }

            private function _validateKey(string $key): void
            {
                if ($key === '') {
                    throw $this->_exception("\$key is empty string");
                }
                if (strpbrk($key, '{}()/\\@:') !== false) {
                    throw $this->_exception("\$key contains reserved character({}()/\\@:)");
                }
            }

            private function _normalizeTtl($ttl): int
            {
                if ($ttl === null) {
                    return 60 * 60 * 24 * 365 * 100;
                }
                if (is_int($ttl)) {
                    return $ttl;
                }
                if ($ttl instanceof \DateInterval) {
                    return (new \DateTime())->setTimestamp(0)->add($ttl)->getTimestamp();
                }
                throw $this->_exception("\$ttl must be null|int|DateInterval(" . gettype($ttl) . ")");
            }

            private function _getFilename(string $key): string
            {
                return $this->directory . DIRECTORY_SEPARATOR . strtr(rawurlencode($key), ['.' => DIRECTORY_SEPARATOR]) . ".php-cache";
            }

            private function _getCacheFilenames(): array
            {
                return file_list($this->directory, [
                    '!type'     => ['dir', 'link'],
                    'extension' => ['php-cache'],
                ]) ?? [];
            }

            private function _getMetadata(string $filename): ?array
            {
                $fp = @fopen($filename, "r");
                if ($fp === false) {
                    return null;
                }
                try {
                    $first = fgets($fp);
                    $meta = @json_decode(substr($first, strpos($first, '#') + 1), true);
                    return $meta ?: null;
                }
                finally {
                    fclose($fp);
                }
            }

            public function keys(?string $pattern = null)
            {
                $files = $this->_getCacheFilenames();

                $now = time();
                $result = [];
                foreach ($files as $file) {
                    $meta = $this->_getMetadata($file);
                    if ($meta && ($pattern === null || fnmatch($pattern, $meta['key']))) {
                        $result[$meta['key']] = [
                            'realpath' => $file,
                            'size'     => filesize($file),
                            'ttl'      => $meta['expire'] - $now,
                        ];
                    }
                }
                return $result;
            }

            public function clean()
            {
                $files = file_list($this->directory, [
                    '!type' => 'link',
                ]);

                foreach ($files as $file) {
                    if (is_file($file)) {
                        $meta = $this->_getMetadata($file);
                        if (isset($meta['expire']) && $meta['expire'] < time()) {
                            @unlink($file);
                        }
                    }
                    elseif (is_dir($file)) {
                        @rmdir($file);
                    }
                }
            }

            public function fetch($key, $provider, $ttl = null)
            {
                $value = $this->get($key);
                if ($value === null) {
                    $value = $provider($this);
                    $this->set($key, $value, $ttl);
                }
                return $value;
            }

            public function fetchMultiple($providers, $ttl = null)
            {
                $result = $this->getMultiple(array_keys($providers));
                foreach ($providers as $key => $provider) {
                    $result[$key] ??= $this->fetch($key, $provider, $ttl);
                }
                return $result;
            }

            public function get($key, $default = null)
            {
                $this->_validateKey($key);

                error_clear_last();
                $entry = $this->entries[$key] ?? @include $this->_getFilename($key);
                if (error_get_last() !== null || $entry[0] < time()) {
                    $this->delete($key);
                    return $default;
                }

                $this->entries[$key] = $entry;
                return $entry[1];
            }

            public function set($key, $value, $ttl = null)
            {
                $this->_validateKey($key);
                $ttl = $this->_normalizeTtl($ttl);

                if ($ttl <= 0) {
                    return $this->delete($key);
                }

                $expire = time() + $ttl;
                $this->entries[$key] = [$expire, $value];
                $meta = json_encode(['key' => $key, 'expire' => $expire]);
                // var_export3 はあらゆる出力を可能にしているので **読み込み時** のオーバーヘッドがでかく、もし var_export が使えるならその方が格段に速い
                // しかし要素を再帰的に全舐め（is_exportable）しないと「var_export できるか？」は分からないというジレンマがある
                // このコンテキストは「キャッシュ」なので書き込み時のオーバーヘッドよりも読み込み時のオーバーヘッドを優先して判定を行っている
                if (is_exportable($this->entries[$key])) {
                    $code = var_export($this->entries[$key], true);
                }
                else {
                    $code = var_export3($this->entries[$key], true);
                }
                return !!file_set_contents($this->_getFilename($key), "<?php # $meta\nreturn $code;\n");
            }

            public function delete($key)
            {
                $this->_validateKey($key);

                unset($this->entries[$key]);
                return @unlink($this->_getFilename($key));
            }

            public function provide($provider, ...$args)
            {
                $provider_hash = (string) new \ReflectionFunction($provider);
                $cacheid = "autoprovide." . hash('fnv164', $provider_hash);
                $key = $provider_hash . '@' . serialize($args);

                $cache = $this->get($cacheid) ?? [];
                if (!array_key_exists($key, $cache)) {
                    $result = $provider(...$args);
                    if ($result === null) {
                        return null;
                    }
                    $cache[$key] = $result;
                    $this->set($cacheid, $cache);
                }
                return $cache[$key];
            }

            public function clear()
            {
                $this->entries = [];

                $files = $this->_getCacheFilenames();
                return count($files) === count(array_filter(array_map('unlink', $files)));
            }

            public function getMultiple($keys, $default = null)
            {
                return array_each($keys, function (&$result, $v) use ($default) {
                    $result[$v] = $this->get($v, $default);
                }, []);
            }

            public function setMultiple($values, $ttl = null)
            {
                return array_each($values, function (&$result, $v, $k) use ($ttl) {
                    $result = $this->set($k, $v, $ttl) && $result;
                }, true);
            }

            public function deleteMultiple($keys)
            {
                return array_each($keys, function (&$result, $v) {
                    $result = $this->delete($v) && $result;
                }, true);
            }

            public function has($key)
            {
                return $this->get($key) !== null;
            }
        };

        static $cleaned = [];
        if ($clean_probability !== 0 && !($cleaned[$directory] ?? false)) {
            $cleaned[$directory] = true;
            if ($clean_probability * 100 >= rand(1, 100)) {
                $cacheobject->clean();
            }
        }

        /** @noinspection PhpIncompatibleReturnTypeInspection */
        return !interface_exists(\Psr\SimpleCache\CacheInterface::class) ? $cacheobject : new class($cacheobject) implements \Psr\SimpleCache\CacheInterface {
            private $cacheobject;

            public function __construct($cacheobject)
            {
                $this->cacheobject = $cacheobject;
            }

            // @formatter:off
            public function clean()                                          { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function keys($pattern = null): iterable                  { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function fetch($key, $provider, $ttl = null): mixed       { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function fetchMultiple($providers, $ttl = null): iterable { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function get($key, $default = null): mixed                { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function set($key, $value, $ttl = null): bool             { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function delete($key): bool                               { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function provide($provider, ...$args): mixed              { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function clear(): bool                                    { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function getMultiple($keys, $default = null): iterable    { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function setMultiple($values, $ttl = null): bool          { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function deleteMultiple($keys): bool                      { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function has($key): bool                                  { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            // @formatter:on
        };
    }
}

assert(!function_exists('ryunosuke\\ltsv\\function_configure') || (new \ReflectionFunction('ryunosuke\\ltsv\\function_configure'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\function_configure')) {
    /**
     * 本ライブラリの設定を行う
     *
     * 各関数の挙動を変えたり、デフォルトオプションを設定できる。
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param array|?string $option 設定。文字列指定時はその値を返す
     * @return array|string 設定値
     */
    function function_configure($option)
    {
        static $config = [];

        // default
        $config['cachedir'] ??= sys_get_temp_dir() . DIRECTORY_SEPARATOR . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['storagedir'] ??= DIRECTORY_SEPARATOR === '/' ? '/var/tmp/rf' : (getenv('ALLUSERSPROFILE') ?: sys_get_temp_dir()) . '\\rf';
        $config['placeholder'] ??= '';
        $config['var_stream'] ??= 'VarStreamV010000';
        $config['memory_stream'] ??= 'MemoryStreamV010000';
        $config['array.variant'] ??= false;
        $config['chain.version'] ??= 2;
        $config['chain.nullsafe'] ??= false;
        $config['process.autoload'] ??= [];

        // setting
        if (is_array($option)) {
            foreach ($option as $name => $entry) {
                $option[$name] = $config[$name] ?? null;
                switch ($name) {
                    default:
                        $config[$name] = $entry;
                        break;
                    case 'cachedir':
                    case 'storagedir':
                        $entry ??= $config[$name];
                        if (!file_exists($entry)) {
                            @mkdir($entry, 0777 & (~umask()), true);
                        }
                        $config[$name] = realpath($entry);
                        break;
                    case 'placeholder':
                        if (strlen($entry)) {
                            $entry = ltrim($entry[0] === '\\' ? $entry : __NAMESPACE__ . '\\' . $entry, '\\');
                            if (!defined($entry)) {
                                define($entry, tmpfile() ?: [] ?: '' ?: 0.0 ?: null ?: false);
                            }
                            if (!is_resourcable(constant($entry))) {
                                // もしリソースじゃないと一意性が保てず致命的になるので例外を投げる
                                throw new \RuntimeException('placeholder is not resource'); // @codeCoverageIgnore
                            }
                            $config[$name] = $entry;
                        }
                        break;
                }
            }
            return $option;
        }

        // getting
        if ($option === null) {
            return $config;
        }
        if (is_string($option)) {
            switch ($option) {
                default:
                    return $config[$option] ?? null;
                case 'cachedir':
                case 'storagedir':
                    $dirname = $config[$option];
                    if (!file_exists($dirname)) {
                        @mkdir($dirname, 0777 & (~umask()), true); // @codeCoverageIgnore
                    }
                    return realpath($dirname);
            }
        }

        throw new \InvalidArgumentException(sprintf('$option is unknown type(%s)', gettype($option)));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\number_serial') || (new \ReflectionFunction('ryunosuke\\ltsv\\number_serial'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\number_serial')) {
    /**
     * 連続した数値の配列を縮めて返す
     *
     * 例えば `[1, 2, 4, 6, 7, 9]` が `['1~2', 4, '6~7', 9]` になる。
     * 結合法則は指定可能（上記は "~" を指定したもの）。
     * null を与えると配列の配列で返すことも可能。
     *
     * Example:
     * ```php
     * // 単純に文字列指定
     * that(number_serial([1, 2, 4, 6, 7, 9], 1, '~'))->is(['1~2', 4, '6~7', 9]);
     * // null を与えると from, to の配列で返す
     * that(number_serial([1, 2, 4, 6, 7, 9], 1, null))->is([[1, 2], [4, 4], [6, 7], [9, 9]]);
     * // $step は負数・小数・逆順も対応している（正負でよしなにソートされる）
     * that(number_serial([-9, 0.2, 0.5, -0.3, 0.1, 0, -0.2, 9], -0.1, '~'))->is([9, 0.5, '0.2~0', '-0.2~-0.3', -9]);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param iterable|array $numbers 数値配列
     * @param int|float $step 連続とみなすステップ。負数を指定すれば逆順指定にも使える
     * @param string|null|\Closure $separator 連続列を結合する文字列（string: 文字結合、null: 配列、Closure: 2引数が渡ってくる）
     * @param bool $doSort ソートをするか否か。事前にソート済みであることが明らかであれば false の方が良い
     * @return array 連続値をまとめた配列
     */
    function number_serial($numbers, $step = 1, $separator = null, $doSort = true)
    {
        $precision = ini_get('precision');
        $step = $step + 0;

        if ($doSort) {
            $numbers = kvsort($numbers, $step < 0 ? -SORT_NUMERIC : SORT_NUMERIC);
        }

        $build = function ($from, $to) use ($separator, $precision) {
            if ($separator instanceof \Closure) {
                return $separator($from, $to);
            }
            if (varcmp($from, $to, SORT_NUMERIC, $precision) === 0) {
                if ($separator === null) {
                    return [$from, $to];
                }
                return $from;
            }
            elseif ($separator === null) {
                return [$from, $to];
            }
            else {
                return $from . $separator . $to;
            }
        };

        $result = [];
        foreach ($numbers as $number) {
            $number = $number + 0;
            if (!isset($from, $to)) {
                $from = $to = $number;
                continue;
            }
            if (varcmp($to + $step, $number, SORT_NUMERIC, $precision) !== 0) {
                $result[] = $build($from, $to);
                $from = $number;
            }
            $to = $number;
        }
        if (isset($from, $to)) {
            $result[] = $build($from, $to);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arrayable_key_exists') || (new \ReflectionFunction('ryunosuke\\ltsv\\arrayable_key_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arrayable_key_exists')) {
    /**
     * 配列・ArrayAccess にキーがあるか調べる
     *
     * 配列が与えられた場合は array_key_exists と同じ。
     * ArrayAccess は一旦 isset で確認した後 null の場合は実際にアクセスして試みる。
     *
     * Example:
     * ```php
     * $array = [
     *     'k' => 'v',
     *     'n' => null,
     * ];
     * // 配列は array_key_exists と同じ
     * that(arrayable_key_exists('k', $array))->isTrue();  // もちろん存在する
     * that(arrayable_key_exists('n', $array))->isTrue();  // isset ではないので null も true
     * that(arrayable_key_exists('x', $array))->isFalse(); // 存在しないので false
     * that(isset($array['n']))->isFalse();                // isset だと null が false になる（参考）
     *
     * $object = new \ArrayObject($array);
     * // ArrayAccess は isset + 実際に取得を試みる
     * that(arrayable_key_exists('k', $object))->isTrue();  // もちろん存在する
     * that(arrayable_key_exists('n', $object))->isTrue();  // isset ではないので null も true
     * that(arrayable_key_exists('x', $object))->isFalse(); // 存在しないので false
     * that(isset($object['n']))->isFalse();                // isset だと null が false になる（参考）
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param string|int $key キー
     * @param array|\ArrayAccess $arrayable 調べる値
     * @return bool キーが存在するなら true
     */
    function arrayable_key_exists($key, $arrayable)
    {
        if (is_array($arrayable) || $arrayable instanceof \ArrayAccess) {
            return attr_exists($key, $arrayable);
        }

        throw new \InvalidArgumentException(sprintf('%s must be array or ArrayAccess (%s).', '$arrayable', var_type($arrayable)));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\arrayval') || (new \ReflectionFunction('ryunosuke\\ltsv\\arrayval'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\arrayval')) {
    /**
     * array キャストの関数版
     *
     * intval とか strval とかの array 版。
     * ただキャストするだけだが、関数なのでコールバックとして使える。
     *
     * $recursive を true にすると再帰的に適用する（デフォルト）。
     * 入れ子オブジェクトを配列化するときなどに使える。
     *
     * Example:
     * ```php
     * // キャストなので基本的には配列化される
     * that(arrayval(123))->isSame([123]);
     * that(arrayval('str'))->isSame(['str']);
     * that(arrayval([123]))->isSame([123]); // 配列は配列のまま
     *
     * // $recursive = false にしない限り再帰的に適用される
     * $stdclass = (object) ['key' => 'val'];
     * that(arrayval([$stdclass], true))->isSame([['key' => 'val']]); // true なので中身も配列化される
     * that(arrayval([$stdclass], false))->isSame([$stdclass]);       // false なので中身は変わらない
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var array 化する値
     * @param bool $recursive 再帰的に行うなら true
     * @return array array 化した配列
     */
    function arrayval($var, $recursive = true)
    {
        // return json_decode(json_encode($var), true);

        // 無駄なループを回したくないので非再帰で配列の場合はそのまま返す
        if (!$recursive && is_array($var)) {
            return $var;
        }

        if (is_primitive($var)) {
            return (array) $var;
        }

        $result = [];
        foreach ($var as $k => $v) {
            if ($recursive && !is_primitive($v)) {
                $v = arrayval($v, $recursive);
            }
            $result[$k] = $v;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\attr_exists') || (new \ReflectionFunction('ryunosuke\\ltsv\\attr_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\attr_exists')) {
    /**
     * 配列・オブジェクトを問わずキーやプロパティの存在を確認する
     *
     * 配列が与えられた場合は array_key_exists と同じ。
     * オブジェクトは一旦 isset で確認した後 null の場合は実際にアクセスして試みる。
     *
     * Example:
     * ```php
     * $array = [
     *     'k' => 'v',
     *     'n' => null,
     * ];
     * // 配列は array_key_exists と同じ
     * that(attr_exists('k', $array))->isTrue();  // もちろん存在する
     * that(attr_exists('n', $array))->isTrue();  // isset ではないので null も true
     * that(attr_exists('x', $array))->isFalse(); // 存在しないので false
     *
     * $object = (object) $array;
     * // オブジェクトでも使える
     * that(attr_exists('k', $object))->isTrue();  // もちろん存在する
     * that(attr_exists('n', $object))->isTrue();  // isset ではないので null も true
     * that(attr_exists('x', $object))->isFalse(); // 存在しないので false
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param int|string $key 調べるキー
     * @param array|object $value 調べられる配列・オブジェクト
     * @return bool $key が存在するなら true
     */
    function attr_exists($key, $value)
    {
        return attr_get($key, $value, $dummy = new \stdClass()) !== $dummy;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\attr_get') || (new \ReflectionFunction('ryunosuke\\ltsv\\attr_get'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\attr_get')) {
    /**
     * 配列・オブジェクトを問わずキーやプロパティの値を取得する
     *
     * 配列が与えられた場合は array_key_exists でチェック。
     * オブジェクトは一旦 isset で確認した後 null の場合は実際にアクセスして取得する。
     *
     * Example:
     * ```php
     * $array = [
     *     'k' => 'v',
     *     'n' => null,
     * ];
     * that(attr_get('k', $array))->isSame('v');                  // もちろん存在する
     * that(attr_get('n', $array))->isSame(null);                 // isset ではないので null も true
     * that(attr_get('x', $array, 'default'))->isSame('default'); // 存在しないのでデフォルト値
     *
     * $object = (object) $array;
     * // オブジェクトでも使える
     * that(attr_get('k', $object))->isSame('v');                  // もちろん存在する
     * that(attr_get('n', $object))->isSame(null);                 // isset ではないので null も true
     * that(attr_get('x', $object, 'default'))->isSame('default'); // 存在しないのでデフォルト値
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param int|string $key 取得するキー
     * @param array|object $value 取得される配列・オブジェクト
     * @param mixed $default なかった場合のデフォルト値
     * @return mixed $key の値
     */
    function attr_get($key, $value, $default = null)
    {
        if (is_array($value)) {
            return array_key_exists($key, $value) ? $value[$key] : $default;
        }

        if ($value instanceof \ArrayAccess) {
            // あるならあるでよい
            if (isset($value[$key])) {
                return $value[$key];
            }
            // 問題は「ない場合」と「あるが null だった場合」の区別で、ArrayAccess の実装次第なので一元的に確定するのは不可能
            // ここでは「ない場合はなんらかのエラー・例外が出るはず」という前提で実際に値を取得して確認する
            try {
                error_clear_last();
                $result = @$value[$key];
                return error_get_last() ? $default : $result;
            }
            catch (\Throwable) {
                return $default;
            }
        }

        // 上記のプロパティ版
        if (is_object($value)) {
            try {
                if (isset($value->$key)) {
                    return $value->$key;
                }
                error_clear_last();
                $result = @$value->$key;
                return error_get_last() ? $default : $result;
            }
            catch (\Throwable) {
                return $default;
            }
        }

        throw new \InvalidArgumentException(sprintf('%s must be array or object (%s).', '$value', var_type($value)));
    }
}

assert(!function_exists('ryunosuke\\ltsv\\cipher_metadata') || (new \ReflectionFunction('ryunosuke\\ltsv\\cipher_metadata'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\cipher_metadata')) {
    /**
     * 暗号化アルゴリズムのメタデータを返す
     *
     * ※ 内部向け
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param string $cipher 暗号化方式（openssl_get_cipher_methods で得られるもの）
     * @return array 暗号化アルゴリズムのメタデータ
     */
    function cipher_metadata($cipher)
    {
        static $cache = [];

        $cipher = strtolower($cipher);

        if (!in_array($cipher, openssl_get_cipher_methods())) {
            return [];
        }

        if (isset($cache[$cipher])) {
            return $cache[$cipher];
        }

        // var_export(array_reduce(openssl_get_cipher_methods(), fn($carry, $item) => $carry + [$item => @openssl_cipher_key_length($item)], []));
        $keylens = [
            'aes-128-cbc'             => 16,
            'aes-128-cbc-cts'         => false,
            'aes-128-cbc-hmac-sha1'   => 16,
            'aes-128-cbc-hmac-sha256' => 16,
            'aes-128-ccm'             => 16,
            'aes-128-cfb'             => 16,
            'aes-128-cfb1'            => 16,
            'aes-128-cfb8'            => 16,
            'aes-128-ctr'             => 16,
            'aes-128-ecb'             => 16,
            'aes-128-gcm'             => 16,
            'aes-128-ocb'             => 16,
            'aes-128-ofb'             => 16,
            'aes-128-siv'             => false,
            'aes-128-wrap'            => 16,
            'aes-128-wrap-inv'        => false,
            'aes-128-wrap-pad'        => 16,
            'aes-128-wrap-pad-inv'    => false,
            'aes-128-xts'             => 32,
            'aes-192-cbc'             => 24,
            'aes-192-cbc-cts'         => false,
            'aes-192-ccm'             => 24,
            'aes-192-cfb'             => 24,
            'aes-192-cfb1'            => 24,
            'aes-192-cfb8'            => 24,
            'aes-192-ctr'             => 24,
            'aes-192-ecb'             => 24,
            'aes-192-gcm'             => 24,
            'aes-192-ocb'             => 24,
            'aes-192-ofb'             => 24,
            'aes-192-siv'             => false,
            'aes-192-wrap'            => 24,
            'aes-192-wrap-inv'        => false,
            'aes-192-wrap-pad'        => 24,
            'aes-192-wrap-pad-inv'    => false,
            'aes-256-cbc'             => 32,
            'aes-256-cbc-cts'         => false,
            'aes-256-cbc-hmac-sha1'   => 32,
            'aes-256-cbc-hmac-sha256' => 32,
            'aes-256-ccm'             => 32,
            'aes-256-cfb'             => 32,
            'aes-256-cfb1'            => 32,
            'aes-256-cfb8'            => 32,
            'aes-256-ctr'             => 32,
            'aes-256-ecb'             => 32,
            'aes-256-gcm'             => 32,
            'aes-256-ocb'             => 32,
            'aes-256-ofb'             => 32,
            'aes-256-siv'             => false,
            'aes-256-wrap'            => 32,
            'aes-256-wrap-inv'        => false,
            'aes-256-wrap-pad'        => 32,
            'aes-256-wrap-pad-inv'    => false,
            'aes-256-xts'             => 64,
            'aria-128-cbc'            => 16,
            'aria-128-ccm'            => 16,
            'aria-128-cfb'            => 16,
            'aria-128-cfb1'           => 16,
            'aria-128-cfb8'           => 16,
            'aria-128-ctr'            => 16,
            'aria-128-ecb'            => 16,
            'aria-128-gcm'            => 16,
            'aria-128-ofb'            => 16,
            'aria-192-cbc'            => 24,
            'aria-192-ccm'            => 24,
            'aria-192-cfb'            => 24,
            'aria-192-cfb1'           => 24,
            'aria-192-cfb8'           => 24,
            'aria-192-ctr'            => 24,
            'aria-192-ecb'            => 24,
            'aria-192-gcm'            => 24,
            'aria-192-ofb'            => 24,
            'aria-256-cbc'            => 32,
            'aria-256-ccm'            => 32,
            'aria-256-cfb'            => 32,
            'aria-256-cfb1'           => 32,
            'aria-256-cfb8'           => 32,
            'aria-256-ctr'            => 32,
            'aria-256-ecb'            => 32,
            'aria-256-gcm'            => 32,
            'aria-256-ofb'            => 32,
            'camellia-128-cbc'        => 16,
            'camellia-128-cbc-cts'    => false,
            'camellia-128-cfb'        => 16,
            'camellia-128-cfb1'       => 16,
            'camellia-128-cfb8'       => 16,
            'camellia-128-ctr'        => 16,
            'camellia-128-ecb'        => 16,
            'camellia-128-ofb'        => 16,
            'camellia-192-cbc'        => 24,
            'camellia-192-cbc-cts'    => false,
            'camellia-192-cfb'        => 24,
            'camellia-192-cfb1'       => 24,
            'camellia-192-cfb8'       => 24,
            'camellia-192-ctr'        => 24,
            'camellia-192-ecb'        => 24,
            'camellia-192-ofb'        => 24,
            'camellia-256-cbc'        => 32,
            'camellia-256-cbc-cts'    => false,
            'camellia-256-cfb'        => 32,
            'camellia-256-cfb1'       => 32,
            'camellia-256-cfb8'       => 32,
            'camellia-256-ctr'        => 32,
            'camellia-256-ecb'        => 32,
            'camellia-256-ofb'        => 32,
            'chacha20'                => 32,
            'chacha20-poly1305'       => 32,
            'des-ede-cbc'             => 16,
            'des-ede-cfb'             => 16,
            'des-ede-ecb'             => 16,
            'des-ede-ofb'             => 16,
            'des-ede3-cbc'            => 24,
            'des-ede3-cfb'            => 24,
            'des-ede3-cfb1'           => 24,
            'des-ede3-cfb8'           => 24,
            'des-ede3-ecb'            => 24,
            'des-ede3-ofb'            => 24,
            'des3-wrap'               => 24,
            'null'                    => false,
        ];

        $ivlen = openssl_cipher_iv_length($cipher);
        @openssl_encrypt('dummy', $cipher, 'password', 0, str_repeat('x', $ivlen), $tag);
        return $cache[$cipher] = [
            'keylen' => intval($keylens[$cipher] ?? 0),
            'ivlen'  => $ivlen,
            'taglen' => strlen($tag ?? ''),
        ];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\decrypt') || (new \ReflectionFunction('ryunosuke\\ltsv\\decrypt'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\decrypt')) {
    /**
     * 指定されたパスワードで復号化する
     *
     * $password は配列で複数与えることができる。
     * 複数与えた場合、順に試みて複合できた段階でその値を返す。
     *
     * $ciphers は配列で複数与えることができる。
     * 複数与えた場合、順に試みて複合できた段階でその値を返す。
     * v2 以降は生成文字列に $cipher が含まれているため指定不要（今後指定してはならない）。
     *
     * 復号に失敗すると null を返す。
     * 単体で使うことはないと思うので詳細は encrypt を参照。
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param string $cipherdata 復号化するデータ
     * @param string|array $password パスワード
     * @param string|array $ciphers 暗号化方式（openssl_get_cipher_methods で得られるもの）
     * @param string $tag 認証タグ
     * @return mixed 復号化されたデータ
     */
    function decrypt($cipherdata, $password, $ciphers = 'aes-256-cbc', $tag = '')
    {
        $version = $cipherdata[-1] ?? '';
        $cipherdata = base64url_decode(substr($cipherdata, 0, -1));

        if ($version === "4") {
            $cipher = 'aes-256-gcm';
            $metadata = cipher_metadata($cipher);
            $payload = substr($cipherdata, 0, -($metadata['taglen'] + $metadata['ivlen']));
            $tag = substr($cipherdata, strlen($payload), $metadata['taglen']);
            $iv = substr($cipherdata, -$metadata['ivlen']);
            foreach ((array) $password as $pass) {
                $pass = hash_hkdf('sha256', $pass, $metadata['keylen']);
                $decryptdata = openssl_decrypt($payload, $cipher, $pass, OPENSSL_RAW_DATA, str_pad($iv, $metadata['ivlen'], "\0"), $tag);
                if ($decryptdata !== false) {
                    return json_decode(gzinflate($decryptdata), true);
                }
            }
            return null;
        }

        if ($version === "3") {
            $cp = strrpos($cipherdata, ':');
            $ivtagpayload = substr($cipherdata, 0, $cp);
            $cipher = substr($cipherdata, $cp + 1);
            $metadata = cipher_metadata($cipher);
            if (!$metadata) {
                return null;
            }
            $tag = substr($ivtagpayload, 0, $metadata['taglen']);
            $iv = substr($ivtagpayload, $metadata['taglen'], $metadata['ivlen']);
            $payload = substr($ivtagpayload, $metadata['ivlen'] + $metadata['taglen']);
            foreach ((array) $password as $pass) {
                $decryptdata = openssl_decrypt($payload, $cipher, $pass, OPENSSL_RAW_DATA, $iv, $tag);
                if ($decryptdata !== false) {
                    return json_decode(gzinflate($decryptdata), true);
                }
            }
            return null;
        }

        if ($version === "2") {
            [$cipher, $ivtagpayload] = explode(':', $cipherdata, 2) + [1 => null];
            $metadata = cipher_metadata($cipher);
            if (!$metadata) {
                return null;
            }
            $iv = substr($ivtagpayload, 0, $metadata['ivlen']);
            $tag = substr($ivtagpayload, $metadata['ivlen'], $metadata['taglen']);
            $payload = substr($ivtagpayload, $metadata['ivlen'] + $metadata['taglen']);
            $tags = array_merge([$tag], (array) $ciphers);
            foreach ($tags as $tag) {
                if ($metadata['taglen'] === strlen($tag)) {
                    $decryptdata = openssl_decrypt($payload, $cipher, $password, OPENSSL_RAW_DATA, $iv, ...$metadata['taglen'] ? [$tag] : []);
                    if ($decryptdata !== false) {
                        return json_decode(gzinflate($decryptdata), true);
                    }
                }
            }
            return null;
        }

        if ($version === "1") {
            foreach ((array) $ciphers as $c) {
                $ivlen = openssl_cipher_iv_length($c);
                if (strlen($cipherdata) <= $ivlen) {
                    continue;
                }
                $iv = substr($cipherdata, 0, $ivlen);
                $payload = substr($cipherdata, $ivlen);

                $decryptdata = openssl_decrypt($payload, $c, $password, OPENSSL_RAW_DATA, $iv, $tag);
                if ($decryptdata !== false) {
                    $decryptdata = gzinflate($decryptdata);
                    return json_decode($decryptdata, true);
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\encrypt') || (new \ReflectionFunction('ryunosuke\\ltsv\\encrypt'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\encrypt')) {
    /**
     * 指定されたパスワードで暗号化する
     *
     * データは json を経由して base64（URL セーフ） して返す。
     *
     * $tag を与えると認証タグが設定される（非推奨）。
     * $cipher で暗号化メソッドを指定できる（非推奨）。
     * v4 から $cipher は aes-256-gcm 決め打ち、結果に $tag が含まれるようになったので引数は2つだけを推奨。
     * 要するに sodium_crypto_aead_aes256gcm_encrypt+iv と等しくなった。
     *
     * $password は配列で複数与えることができる。
     * 複数与えた場合、先頭の要素が使用される。
     * これは decrypt との親和性のため（password の変更・移行期間は複数を扱いたいことがある）であり、決して「複数のパスワード対応」ではない。
     *
     * データ末尾には v が付与される。
     * これによって処理が変わり、バージョン違いの暗号化文字列を与えたとしても複合することができる。
     *
     * - v0: バージョンのない無印。json -> encrypt -> base64
     * - v1: 上記に圧縮処理を加えたもの。json -> deflate -> encrypt -> base64
     * - v2: 生成文字列に $cipher, $iv, $tag を加えたもの。json -> deflate -> cipher+iv+tag+encrypt -> base64
     * - v3: 生成文字列に $iv, $tag, $cipher を加えたもの。json -> deflate -> encrypt+cipher+iv+tag -> base64
     * - v4: 生成文字列に $tag, $iv を加えたもの。json -> deflate -> encrypt+tag+iv -> base64
     *
     * Example:
     * ```php
     * $plaindata = ['a', 'b', 'c'];
     * $encrypted = encrypt($plaindata, 'password');
     * $decrypted = decrypt($encrypted, 'password');
     * // 暗号化されて base64 の文字列になる
     * that($encrypted)->isString();
     * // 復号化されて元の配列になる
     * that($decrypted)->isSame(['a', 'b', 'c']);
     * // password が異なれば失敗して null を返す
     * that(decrypt($encrypted, 'invalid'))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $plaindata 暗号化するデータ
     * @param string|array $password パスワード。十分な長さでなければならない
     * @param string $cipher 暗号化方式（openssl_get_cipher_methods で得られるもの）
     * @param string $tag 認証タグ
     * @return string 暗号化された文字列
     */
    function encrypt($plaindata, $password, $cipher = null, &$tag = '')
    {
        $original_cipher = $cipher;
        $cipher ??= 'aes-256-gcm';
        $metadata = cipher_metadata($cipher);
        if (!$metadata) {
            throw new \InvalidArgumentException("undefined cipher algorithm('$cipher')");
        }

        $jsondata = json_encode($plaindata, JSON_UNESCAPED_UNICODE);
        $zlibdata = gzdeflate($jsondata, 9);

        $iv = '';
        if ($metadata['ivlen']) {
            $iv = unique_id();
            $rest = $metadata['ivlen'] - strlen($iv);
            if ($rest) {
                $iv = random_bytes($rest) . $iv;
            }
        }
        if ($original_cipher === null) {
            $password = hash_hkdf('sha256', is_array($password) ? reset($password) : $password, $metadata['keylen']);
        }
        $payload = openssl_encrypt($zlibdata, $cipher, $password, OPENSSL_RAW_DATA, $iv, ...$metadata['taglen'] ? [&$tag] : []);

        if ($original_cipher === null) {
            return base64url_encode($payload . $tag . $iv) . '4';
        }
        else {
            return base64url_encode($tag . $iv . $payload . ':' . $cipher) . '3';
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\flagval') || (new \ReflectionFunction('ryunosuke\\ltsv\\flagval'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\flagval')) {
    /**
     * falsy の範囲を少し拡張した bool キャスト
     *
     * 例えば ajax 等で {hoge: false} とすると "false" が飛んできてしまうが、その場合も false 判定されるようになる。
     * この処理は FILTER_VALIDATE_BOOLEAN で行うので "off", "no", 等も false を返す。
     *
     * あとドキュメントには空白文字について言及がないが、どうも trim される模様。
     * trim するかどうかは呼び元で判断すべきだと思う（" true " が true, "    " が false になるのは果たして正しいのか）ので、第2引数で分岐できるようにしてある。
     * boolval やキャストでは trim されないようなのでデフォルト false にしてある。
     *
     * Example:
     * ```php
     * // こういう文字列も false になる
     * that(flagval('false'))->isFalse();
     * that(flagval('off'))->isFalse();
     * that(flagval('no'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var bool 化する値
     * @param bool $trim $var が文字列の場合に trim するか
     * @return bool bool 化した値
     */
    function flagval($var, $trim = false)
    {
        if ($trim === false && is_string($var)) {
            if (strlen(trim($var)) !== strlen($var)) {
                return true;
            }
        }
        return filter_var($var, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE) ?? (bool) $var;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\hashvar') || (new \ReflectionFunction('ryunosuke\\ltsv\\hashvar'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\hashvar')) {
    /**
     * 変数指定をできるようにした compact
     *
     * 名前空間指定の呼び出しは未対応。use して関数名だけで呼び出す必要がある。
     *
     * Example:
     * ```php
     * $hoge = 'HOGE';
     * $fuga = 'FUGA';
     * that(hashvar($hoge, $fuga))->isSame(['hoge' => 'HOGE', 'fuga' => 'FUGA']);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed ...$vars 変数（可変引数）
     * @return array 引数の変数を変数名で compact した配列
     */
    function hashvar(...$vars)
    {
        $num = count($vars);

        $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
        $file = $trace['file'];
        $line = $trace['line'];
        $function = function_shorten($trace['function']);

        $cache = cache($file . '#' . $line, function () use ($file, $line, $function) {
            // 呼び出し元の1行を取得
            $lines = file($file, FILE_IGNORE_NEW_LINES);
            $target = $lines[$line - 1];

            // 1行内で複数呼んでいる場合のための配列
            $caller = [];
            $callers = [];

            // php パーシング
            $starting = false;
            $tokens = \PhpToken::tokenize('<?php ' . $target);
            foreach ($tokens as $token) {
                // トークン配列の場合
                if ($token->id >= 255) {
                    // 自身の呼び出しが始まった
                    if (!$starting && $token->id === T_STRING && $token->text === $function) {
                        $starting = true;
                    }
                    // 呼び出し中でかつ変数トークンなら変数名を確保
                    elseif ($starting && $token->id === T_VARIABLE) {
                        $caller[] = ltrim($token->text, '$');
                    }
                    // 上記以外の呼び出し中のトークンは空白しか許されない
                    elseif ($starting && $token->id !== T_WHITESPACE) {
                        throw new \UnexpectedValueException('argument allows variable only.');
                    }
                }
                // 1文字単位の文字列の場合
                else {
                    // 自身の呼び出しが終わった
                    if ($starting && $token->text === ')' && $caller) {
                        $callers[] = $caller;
                        $caller = [];
                        $starting = false;
                    }
                }
            }

            // 同じ引数の数の呼び出しは区別することが出来ない
            $length = count($callers);
            for ($i = 0; $i < $length; $i++) {
                for ($j = $i + 1; $j < $length; $j++) {
                    if (count($callers[$i]) === count($callers[$j])) {
                        throw new \UnexpectedValueException('argument is ambiguous.');
                    }
                }
            }

            return $callers;
        }, __FUNCTION__);

        // 引数の数が一致する呼び出しを返す
        foreach ($cache as $caller) {
            if (count($caller) === $num) {
                return array_combine($caller, $vars);
            }
        }

        // 仕組み上ここへは到達しないはず（呼び出し元のシンタックスが壊れてるときに到達しうるが、それならばそもそもこの関数自体が呼ばれないはず）。
        throw new \DomainException('syntax error.'); // @codeCoverageIgnore
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_arrayable') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_arrayable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_arrayable')) {
    /**
     * 変数が配列アクセス可能か調べる
     *
     * Example:
     * ```php
     * that(is_arrayable([]))->isTrue();
     * that(is_arrayable(new \ArrayObject()))->isTrue();
     * that(is_arrayable(new \stdClass()))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 配列アクセス可能なら true
     */
    function is_arrayable($var)
    {
        return is_array($var) || $var instanceof \ArrayAccess;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_decimal') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_decimal'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_decimal')) {
    /**
     * 値が10進的か調べる
     *
     * is_numeric を少しキツめにしたような関数で、なるべく「一般人の感覚」で数値とみなせるものを true で返す。
     *
     * なお、 0 始まりは false だが 0 終わり小数は許容される。
     * `1.20000` を false にするような動作だと `1.0` も false にしなければ一貫性がない。
     * しかし `1.0` が false になるのはあまり一般的とはいえない。
     *
     * 空白込みが false なのは空白許可は呼び元に委ねたいため（trim すればいいだけなので）。
     *
     * Example:
     * ```php
     * // 以下は is_numeric と違い false を返す
     * that(is_decimal('.12'))->isFalse();  // 整数部省略
     * that(is_decimal('12.'))->isFalse();  // 小数部省略
     * that(is_decimal('1e2'))->isFalse();  // 指数記法
     * that(is_decimal(' 12 '))->isFalse(); // 空白あり
     * that(is_decimal('012'))->isFalse();  // 0 始まり
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 判定する値
     * @param bool $allow_float false にすると整数のみを許可する
     * @return bool 数値なら true
     */
    function is_decimal($var, $allow_float = true)
    {
        if (!is_numeric($var)) {
            return false;
        }

        $integer = "(0|[1-9][0-9]*)";
        $fraction = $allow_float ? "(\.[0-9]+)?" : "";
        return !!preg_match("/^[+-]?$integer$fraction$/", (string) $var);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_empty') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_empty'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_empty')) {
    /**
     * 値が空か検査する
     *
     * `empty` とほぼ同じ。ただし
     *
     * - string: "0"
     * - countable でない object
     * - countable である object で count() > 0
     *
     * は false 判定する。
     * ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。
     * これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。
     * （例えば `json_decode('{}')` は stdClass を返すが、このような状況は空判定したいことが多いだろう）。
     *
     * なお、関数の仕様上、未定義変数を true 判定することはできない。
     * 未定義変数をチェックしたい状況は大抵の場合コードが悪いが `$array['key1']['key2']` を調べたいことはある。
     * そういう時には使えない（?? する必要がある）。
     *
     * 「 `if ($var) {}` で十分なんだけど "0" が…」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // この辺は empty と全く同じ
     * that(is_empty(null))->isTrue();
     * that(is_empty(false))->isTrue();
     * that(is_empty(0))->isTrue();
     * that(is_empty(''))->isTrue();
     * // この辺だけが異なる
     * that(is_empty('0'))->isFalse();
     * // 第2引数に true を渡すと空の stdClass も empty 判定される
     * $stdclass = new \stdClass();
     * that(is_empty($stdclass, true))->isTrue();
     * // フィールドがあれば empty ではない
     * $stdclass->hoge = 123;
     * that(is_empty($stdclass, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 判定する値
     * @param bool $empty_stdClass 空の stdClass を空とみなすか
     * @return bool 空なら true
     */
    function is_empty($var, $empty_stdClass = false)
    {
        // object は is_countable 次第
        if (is_object($var)) {
            // が、 stdClass だけは特別扱い（stdClass は継承もできるので、クラス名で判定する（継承していたらそれはもう stdClass ではないと思う））
            if ($empty_stdClass && get_class($var) === 'stdClass') {
                return !(array) $var;
            }
            if (is_countable($var)) {
                return !count($var);
            }
            return false;
        }

        // "0" は false
        if ($var === '0') {
            return false;
        }

        // 上記以外は empty に任せる
        return empty($var);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_exportable') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_exportable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_exportable')) {
    /**
     * 値が var_export で出力可能か検査する
     *
     * 「出力可能」とは「意味のある出力」を意味する。
     * 例えば set_state のないオブジェクトはエラーなく set_state コール形式で出力されるが意味のある出力ではない。
     * リソース型はエラーなく NULL で出力されるが意味のある出力ではない。
     * 循環参照は出力できるものの warning が出てかつ循環は切れるため意味のある出力ではない。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 出力可能なら true
     */
    function is_exportable($var): bool
    {
        // スカラー/NULL は OK
        if (is_scalar($var) || is_null($var)) {
            return true;
        }

        // リソース型の変数は、この関数ではエクスポートする事ができません
        if (is_resourcable($var)) {
            return false;
        }

        // var_export() では循環参照を扱うことができません
        if (is_recursive($var)) {
            return false;
        }

        // 配列に制限はない。それゆえに全要素を再帰的に見なければならない
        if (is_array($var)) {
            foreach ($var as $v) {
                if (!is_exportable($v)) {
                    return false;
                }
            }
            return true;
        }

        if (is_object($var)) {
            // 無名クラスは非常に特殊で、出力は class@anonymous{filename}:123$456::__set_state(...) のようになる
            // set_state さえ実装してれば復元可能に思えるが php コードとして不正なのでそのまま実行するとシンタックスエラーになる
            // 'class@anonymous{filename}:123$456'::__set_state(...) のようにクオートすれば実行可能になるが、それは標準 var_export の動作ではない
            // 復元する側がクオートして読み込み…とすれば復元可能だが、そもそもクラスがロードされている保証もない
            // これらのことを考慮するなら「意味のある出力」ではないとみなした方が手っ取り早い
            if ((new \ReflectionClass($var))->isAnonymous()) {
                return false;
            }
            // var_export() が生成する PHP を評価できるようにするためには、処理対象のすべてのオブジェクトがマジックメソッド __set_state を実装している必要があります
            if (method_exists($var, '__set_state')) {
                return true;
            }
            // これの唯一の例外は stdClass です。 stdClass は、配列をオブジェクトにキャストした形でエクスポートされます
            if (get_class($var) === \stdClass::class) {
                return true;
            }
            // マニュアルに記載はないが enum は export できる
            if ($var instanceof \UnitEnum) {
                return true;
            }
            return false;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_primitive') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_primitive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_primitive')) {
    /**
     * 値が複合型でないか検査する
     *
     * 「複合型」とはオブジェクトと配列のこと。
     * つまり
     *
     * - is_scalar($var) || is_null($var) || is_resource($var)
     *
     * と同義（!is_array($var) && !is_object($var) とも言える）。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 複合型なら false
     */
    function is_primitive($var)
    {
        return is_scalar($var) || is_null($var) || is_resourcable($var);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_recursive') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_recursive'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_recursive')) {
    /**
     * 変数が再帰参照を含むか調べる
     *
     * Example:
     * ```php
     * // 配列の再帰
     * $array = [];
     * $array['recursive'] = &$array;
     * that(is_recursive($array))->isTrue();
     * // オブジェクトの再帰
     * $object = new \stdClass();
     * $object->recursive = $object;
     * that(is_recursive($object))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 再帰参照を含むなら true
     */
    function is_recursive($var)
    {
        $core = function ($var, $parents) use (&$core) {
            // 複合型でないなら間違いなく false
            if (is_primitive($var)) {
                return false;
            }

            // 「親と同じ子」は再帰以外あり得ない。よって === で良い（オブジェクトに関してはそもそも等値比較で絶対に一致しない）
            // sql_object_hash とか serialize でキーに保持して isset の方が速いか？
            // → ベンチ取ったところ in_array の方が10倍くらい速い。多分生成コストに起因
            // raw な比較であれば瞬時に比較できるが、isset だと文字列化が必要でかなり無駄が生じていると考えられる
            foreach ($parents as $parent) {
                if ($parent === $var) {
                    return true;
                }
            }

            // 全要素を再帰的にチェック
            $parents[] = $var;
            foreach ($var as $v) {
                if ($core($v, $parents)) {
                    return true;
                }
            }
            return false;
        };
        return $core($var, []);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_resourcable') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_resourcable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_resourcable')) {
    /**
     * 閉じたリソースでも true を返す is_resource
     *
     * マニュアル（ https://www.php.net/manual/ja/function.is-resource.php ）に記載の通り、 isresource は閉じたリソースで false を返す。
     * リソースはリソースであり、それでは不便なこともあるので、閉じていようとリソースなら true を返す関数。
     *
     * Example:
     * ```php
     * // 閉じたリソースを用意
     * $resource = tmpfile();
     * fclose($resource);
     * // is_resource は false を返すが・・・
     * that(is_resource($resource))->isFalse();
     * // is_resourcable は true を返す
     * that(is_resourcable($resource))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool リソースなら true
     */
    function is_resourcable($var)
    {
        if (is_resource($var)) {
            return true;
        }
        // もっといい方法があるかもしれないが、簡単に調査したところ gettype するしか術がないような気がする
        if (strpos(gettype($var), 'resource') === 0) {
            return true;
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_stringable') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_stringable'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_stringable')) {
    /**
     * 変数が文字列化できるか調べる
     *
     * 「配列」「__toString を持たないオブジェクト」が false になる。
     * （厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。
     *
     * Example:
     * ```php
     * // こいつらは true
     * that(is_stringable(null))->isTrue();
     * that(is_stringable(true))->isTrue();
     * that(is_stringable(3.14))->isTrue();
     * that(is_stringable(STDOUT))->isTrue();
     * that(is_stringable(new \Exception()))->isTrue();
     * // こいつらは false
     * that(is_stringable(new \ArrayObject()))->isFalse();
     * that(is_stringable([1, 2, 3]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 文字列化できるなら true
     */
    function is_stringable($var)
    {
        if (is_array($var)) {
            return false;
        }
        if (is_object($var) && !method_exists($var, '__toString')) {
            return false;
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\is_typeof') || (new \ReflectionFunction('ryunosuke\\ltsv\\is_typeof'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\is_typeof')) {
    /**
     * 変数が型に合致するか調べる
     *
     * is_a のビルトイン＋DNF 対応版。
     *
     * DNF の場合、括弧は必須だしネストも不可。
     * 実質的には ReflectionType の文字列表現を与えるのみ。
     *
     * いわゆる strict_types=1 で、型の変換は伴わない。
     * それはそれで不便なことがある（stringable とか）ので対応するかもしれない。
     *
     * Example:
     * ```php
     * that(is_typeof(null, 'null'))->isTrue();
     * that(is_typeof(null, '?int'))->isTrue();
     * that(is_typeof(1234, '?int'))->isTrue();
     * that(is_typeof(1234, 'int|string'))->isTrue();
     * that(is_typeof('ss', 'int|string'))->isTrue();
     * that(is_typeof(null, 'int|string'))->isFalse();
     * that(is_typeof([], 'array|(ArrayAccess&Countable&iterable)'))->isTrue();
     * that(is_typeof(new \ArrayObject(), 'array|(ArrayAccess&Countable&iterable)'))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @param string $typestring 型文字列
     * @param null|object|string $context self,static のコンテキスト
     * @return bool $typestring に合致するなら true
     */
    function is_typeof($var, string $typestring, $context = null)
    {
        $context ??= '';

        $match = function ($type) use ($var, $context) {
            $type = trim($type);
            // ?type は 7.4 を最後に姿を消したが $typestring はただの文字列なので与えられる可能性がなくはない
            if ($type[0] === '?') {
                if ($var === null) {
                    return true;
                }
                $type = substr($type, 1);
            }
            return match ($type) {
                'void', 'never'  => false, // 単一戻り値専用なのでオマケのようなもの
                'mixed'          => true,
                'null'           => $var === null,
                'true'           => $var === true,
                'false'          => $var === false,
                'bool'           => is_bool($var),
                'int'            => is_int($var),
                'float'          => is_float($var),
                'string'         => is_string($var),
                'array'          => is_array($var),
                'object'         => is_object($var),
                'iterable'       => is_iterable($var),
                'callable'       => is_callable($var),
                'countable'      => is_countable($var),   // Countable は配列が引っかからないので Countable/countable を区別している
                'resource'       => is_resourcable($var), // 型宣言できないのでオマケのようなもの
                'self', 'static' => is_a($var, is_object($context) ? get_class($context) : $context),
                default          => is_a($var, $type),
            };
        };

        // DNF の()は必須かつネストしないので単純 explode で問題ない
        foreach (explode('|', $typestring) as $ortype) {
            if (preg_match('#\(?([^)]+)\)?#u', $ortype, $m)) {
                foreach (explode('&', $m[1]) as $andtype) {
                    if (!$match($andtype)) {
                        continue 2;
                    }
                }
                return true;
            }
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\numberify') || (new \ReflectionFunction('ryunosuke\\ltsv\\numberify'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\numberify')) {
    /**
     * 値を何とかして数値化する
     *
     * - 配列は要素数
     * - int/float はそのまま（ただし $decimal に応じた型にキャストされる）
     * - resource はリソースID（php 標準の int キャスト）
     * - null/bool はその int 値（php 標準の int キャストだが $decimal を見る）
     * - それ以外（文字列・オブジェクト）は文字列表現から数値以外を取り除いたもの
     *
     * 文字列・オブジェクト以外の変換は互換性を考慮しない。頻繁に変更される可能性がある（特に配列）。
     *
     * -記号は受け入れるが+記号は受け入れない。
     *
     * Example:
     * ```php
     * // 配列は要素数となる
     * that(numberify([1, 2, 3]))->isSame(3);
     * // int/float は基本的にそのまま
     * that(numberify(123))->isSame(123);
     * that(numberify(123.45))->isSame(123);
     * that(numberify(123.45, true))->isSame(123.45);
     * // 文字列は数値抽出
     * that(numberify('a1b2c3'))->isSame(123);
     * that(numberify('a1b2.c3', true))->isSame(12.3);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 対象の値
     * @param bool $decimal 小数として扱うか
     * @return int|float 数値化した値
     */
    function numberify($var, $decimal = false)
    {
        // resource はその int 値を返す
        if (is_resourcable($var)) {
            return (int) $var;
        }

        // 配列は要素数を返す・・・が、$decimal を見るので後段へフォールスルー
        if (is_array($var)) {
            $var = count($var);
        }
        // null/bool はその int 値を返す・・・が、$decimal を見るので後段へフォールスルー
        if ($var === null || $var === false || $var === true) {
            $var = (int) $var;
        }

        // int はそのまま返す・・・と言いたいところだが $decimal をみてキャストして返す
        if (is_int($var)) {
            if ($decimal) {
                $var = (float) $var;
            }
            return $var;
        }
        // float はそのまま返す・・・と言いたいところだが $decimal をみてキャストして返す
        if (is_float($var)) {
            if (!$decimal) {
                $var = (int) $var;
            }
            return $var;
        }

        // 上記以外は文字列として扱い、数値のみでフィルタする（__toString 未実装は標準に任せる。多分 fatal error）
        $number = preg_replace("#[^-.0-9]#u", '', $var);

        // 正規表現レベルでチェックもできそうだけど大変な匂いがするので is_numeric に日和る
        if (!is_numeric($number)) {
            throw new \UnexpectedValueException("$var to $number, this is not numeric.");
        }

        if ($decimal) {
            return (float) $number;
        }
        return (int) $number;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\numval') || (new \ReflectionFunction('ryunosuke\\ltsv\\numval'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\numval')) {
    /**
     * 値を数値化する
     *
     * int か float ならそのまま返す。
     * 文字列の場合、一言で言えば「.を含むなら float、含まないなら int」を返す。
     * int でも float でも stringable でもない場合は実装依存（ただの int キャスト）。
     *
     * Example:
     * ```php
     * that(numval(3.14))->isSame(3.14);   // int や float はそのまま返す
     * that(numval('3.14'))->isSame(3.14); // . を含む文字列は float を返す
     * that(numval('11', 8))->isSame(9);   // 基数が指定できる
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 数値化する値
     * @param int $base 基数。int 的な値のときしか意味をなさない
     * @return int|float 数値化した値
     */
    function numval($var, $base = 10)
    {
        if (is_int($var) || is_float($var)) {
            return $var;
        }
        if (is_object($var)) {
            $var = (string) $var;
        }
        if (is_string($var) && strpos($var, '.') !== false) {
            return (float) $var;
        }
        return intval($var, $base);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\phpval') || (new \ReflectionFunction('ryunosuke\\ltsv\\phpval'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\phpval')) {
    /**
     * 文字列を php の式として評価して値を返す
     *
     * 実質的には `eval("return $var;")` とほぼ同義。
     * ただ、 eval するまでもない式はそのまま返し、bare な文字列はそのまま文字列として返す（7.2 以前の未定義定数のような動作）。
     *
     * Example:
     * ```php
     * that(phpval('strtoupper($var)', ['var' => 'string']))->isSame('STRING');
     * that(phpval('bare string'))->isSame('bare string');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 評価する式
     * @param array $contextvars eval される場合のローカル変数
     * @return mixed 評価した値
     */
    function phpval($var, $contextvars = [])
    {
        if (!is_string($var)) {
            return $var;
        }

        if (defined($var)) {
            return constant($var);
        }
        if (ctype_digit(ltrim($var, '+-'))) {
            return (int) $var;
        }
        if (is_numeric($var)) {
            return (double) $var;
        }

        set_error_handler(function () { });
        try {
            return evaluate("return $var;", $contextvars);
        }
        catch (\Throwable) {
            return $var;
        }
        finally {
            restore_error_handler();
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\si_prefix') || (new \ReflectionFunction('ryunosuke\\ltsv\\si_prefix'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\si_prefix')) {
    /**
     * 数値に SI 接頭辞を付与する
     *
     * 値は 1 <= $var < 1000(1024) の範囲内に収められる。
     * ヨクト（10^24）～ヨタ（1024）まで。整数だとしても 64bit の範囲を超えるような値の精度は保証しない。
     *
     * Example:
     * ```php
     * // シンプルに k をつける
     * that(si_prefix(12345))->isSame('12.345 k');
     * // シンプルに m をつける
     * that(si_prefix(0.012345))->isSame('12.345 m');
     * // 書式フォーマットを指定できる
     * that(si_prefix(12345, 1000, '%d%s'))->isSame('12k');
     * that(si_prefix(0.012345, 1000, '%d%s'))->isSame('12m');
     * // ファイルサイズを byte で表示する
     * that(si_prefix(12345, 1000, '%d %sbyte'))->isSame('12 kbyte');
     * // ファイルサイズを byte で表示する（1024）
     * that(si_prefix(10240, 1024, '%.3f %sbyte'))->isSame('10.000 kbyte');
     * // フォーマットに null を与えると sprintf せずに配列で返す
     * that(si_prefix(12345, 1000, null))->isSame([12.345, 'k']);
     * // フォーマットにクロージャを与えると実行して返す
     * that(si_prefix(12345, 1000, fn($v, $u) => number_format($v, 2) . $u))->isSame('12.35k');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 丸める値
     * @param int $unit 桁単位。実用上は 1000, 1024 の2値しか指定することはないはず
     * @param string|\Closure $format 書式フォーマット。 null を与えると sprintf せずに配列で返す
     * @return string|array 丸めた数値と SI 接頭辞で sprintf した文字列（$format が null の場合は配列）
     */
    function si_prefix($var, $unit = 1000, $format = '%.3f %s')
    {
        assert($unit > 0);

        $result = function ($format, $var, $unit) {
            if ($format instanceof \Closure) {
                return $format($var, $unit);
            }
            if ($format === null) {
                return [$var, $unit];
            }
            return sprintf($format, $var, $unit);
        };

        if ($var == 0) {
            return $result($format, $var, '');
        }

        $original = $var;
        $var = abs($var);
        $n = 0;
        while (!(1 <= $var && $var < $unit)) {
            if ($var < 1) {
                $n--;
                $var *= $unit;
            }
            else {
                $n++;
                $var /= $unit;
            }
        }
        if (!isset(SI_UNITS[$n])) {
            throw new \InvalidArgumentException("$original is too large or small ($n).");
        }
        return $result($format, ($original > 0 ? 1 : -1) * $var, SI_UNITS[$n][0] ?? '');
    }
}

assert(!function_exists('ryunosuke\\ltsv\\si_unprefix') || (new \ReflectionFunction('ryunosuke\\ltsv\\si_unprefix'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\si_unprefix')) {
    /**
     * SI 接頭辞が付与された文字列を数値化する
     *
     * 典型的な用途は ini_get で得られた値を数値化したいとき。
     * ただし、 ini は 1m のように小文字で指定することもあるので大文字化する必要はある。
     *
     * Example:
     * ```php
     * // 1k = 1000
     * that(si_unprefix('1k'))->isSame(1000);
     * // 1k = 1024
     * that(si_unprefix('1k', 1024))->isSame(1024);
     * // m はメガではなくミリ
     * that(si_unprefix('1m'))->isSame(0.001);
     * // M がメガ
     * that(si_unprefix('1M'))->isSame(1000000);
     * // K だけは特別扱いで大文字小文字のどちらでもキロになる
     * that(si_unprefix('1K'))->isSame(1000);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 数値化する値
     * @param int $unit 桁単位。実用上は 1000, 1024 の2値しか指定することはないはず
     * @return int|float SI 接頭辞を取り払った実際の数値
     */
    function si_unprefix($var, $unit = 1000)
    {
        assert($unit > 0);

        $var = trim($var);

        foreach (SI_UNITS as $exp => $sis) {
            foreach ($sis as $si) {
                if (strpos($var, $si) === (strlen($var) - strlen($si))) {
                    return numval($var) * pow($unit, $exp);
                }
            }
        }

        return numval($var);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\stringify') || (new \ReflectionFunction('ryunosuke\\ltsv\\stringify'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\stringify')) {
    /**
     * 値を何とかして文字列化する
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 文字列化する値
     * @return string $var を文字列化したもの
     */
    function stringify($var)
    {
        $type = gettype($var);
        switch ($type) {
            case 'NULL':
                return 'null';
            case 'boolean':
                return $var ? 'true' : 'false';
            case 'array':
                return var_export2($var, true);
            case 'object':
                if (method_exists($var, '__toString')) {
                    return (string) $var;
                }
                if (method_exists($var, '__serialize') || $var instanceof \Serializable) {
                    return serialize($var);
                }
                if ($var instanceof \JsonSerializable) {
                    return get_class($var) . ':' . json_encode($var, JSON_UNESCAPED_UNICODE);
                }
                return get_class($var);

            default:
                return (string) $var;
        }
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_apply') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_apply'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_apply')) {
    /**
     * 値にコールバックを適用する
     *
     * 普通のスカラー値であれば `$callback($var)` と全く同じ。
     * この関数は「$var が配列だったら中身に適用して返す（再帰）」という点で上記とは異なる。
     *
     * 「配列が与えられたら要素に適用して配列で返す、配列じゃないなら直に適用してそれを返す」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // 素の値は素の呼び出しと同じ
     * that(var_apply(' x ', 'trim'))->isSame('x');
     * // 配列は中身に適用して配列で返す（再帰）
     * that(var_apply([' x ', ' y ', [' z ']], 'trim'))->isSame(['x', 'y', ['z']]);
     * // 第3引数以降は残り引数を意味する
     * that(var_apply(['!x!', '!y!'], 'trim', '!'))->isSame(['x', 'y']);
     * // 「まれによくある」の具体例
     * that(var_apply(['<x>', ['<y>']], 'htmlspecialchars', ENT_QUOTES, 'utf-8'))->isSame(['&lt;x&gt;', ['&lt;y&gt;']]);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var $callback を適用する値
     * @param callable $callback 値変換コールバック
     * @param mixed ...$args $callback の残り引数（可変引数）
     * @return mixed|array $callback が適用された値。元が配列なら配列で返す
     */
    function var_apply($var, $callback, ...$args)
    {
        $iterable = is_iterable($var);
        if ($iterable) {
            $result = [];
            foreach ($var as $k => $v) {
                $result[$k] = var_apply($v, $callback, ...$args);
            }
            return $result;
        }

        return $callback($var, ...$args);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_applys') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_applys'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_applys')) {
    /**
     * 配列にコールバックを適用する
     *
     * 配列であれば `$callback($var)` と全く同じ。
     * この関数は「$var がスカラー値だったら配列化して適用してスカラーで返す」という点で上記とは異なる。
     *
     * 「配列を受け取って配列を返す関数があるが、手元にスカラー値しか無い」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // 配列を受け取って中身を大文字化して返すクロージャ
     * $upper = fn($array) => array_map('strtoupper', $array);
     * // 普通はこうやって使うが・・・
     * that($upper(['a', 'b', 'c']))->isSame(['A', 'B', 'C']);
     * // 手元に配列ではなくスカラー値しか無いときはこうせざるをえない
     * that($upper(['a'])[0])->isSame('A');
     * // var_applys を使うと配列でもスカラーでも統一的に記述することができる
     * that(var_applys(['a', 'b', 'c'], $upper))->isSame(['A', 'B', 'C']);
     * that(var_applys('a', $upper))->isSame('A');
     * # 要するに「大文字化したい」だけなわけだが、$upper が配列を前提としているので、「大文字化」部分を得るには配列化しなければならなくなっている
     * # 「strtoupper だけ切り出せばよいのでは？」と思うかもしれないが、「（外部ライブラリなどで）手元に配列しか受け取ってくれない処理しかない」状況がまれによくある
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var $callback を適用する値
     * @param callable $callback 値変換コールバック
     * @param mixed ...$args $callback の残り引数（可変引数）
     * @return mixed|array $callback が適用された値。元が配列なら配列で返す
     */
    function var_applys($var, $callback, ...$args)
    {
        $iterable = is_iterable($var);
        if (!$iterable) {
            $var = [$var];
        }
        $var = $callback($var, ...$args);
        return $iterable ? $var : $var[0];
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_export2') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_export2'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_export2')) {
    /**
     * 組み込みの var_export をいい感じにしたもの
     *
     * 下記の点が異なる。
     *
     * - 配列は 5.4 以降のショートシンタックス（[]）で出力
     * - ただの配列は1行（[1, 2, 3]）でケツカンマなし、連想配列は桁合わせインデントでケツカンマあり
     * - 文字列はダブルクオート
     * - null は null（小文字）
     * - 再帰構造を渡しても警告がでない（さらに NULL ではなく `'*RECURSION*'` という文字列になる）
     * - 配列の再帰構造の出力が異なる（Example参照）
     *
     * Example:
     * ```php
     * // 単純なエクスポート
     * that(var_export2(['array' => [1, 2, 3], 'hash' => ['a' => 'A', 'b' => 'B', 'c' => 'C']], true))->isSame('[
     *     "array" => [1, 2, 3],
     *     "hash"  => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     * ]');
     * // 再帰構造を含むエクスポート（標準の var_export は形式が異なる。 var_export すれば分かる）
     * $rarray = [];
     * $rarray['a']['b']['c'] = &$rarray;
     * $robject = new \stdClass();
     * $robject->a = new \stdClass();
     * $robject->a->b = new \stdClass();
     * $robject->a->b->c = $robject;
     * that(var_export2(compact('rarray', 'robject'), true))->isSame('[
     *     "rarray"  => [
     *         "a" => [
     *             "b" => [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     *     "robject" => (object) [
     *         "a" => (object) [
     *             "b" => (object) [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     * ]');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     * @param bool|array $options オプション配列（var_export に寄せるため bool も受け付ける）
     * @return string|null $return=true の場合は出力せず結果を返す
     */
    function var_export2($value, $options = [])
    {
        if (!is_array($options)) {
            $options = [
                'return' => !!$options,
            ];
        }

        $options += [
            'minify' => false, // 短縮形で返す（実質的には情報を減らして1行で返す）
            'indent' => 4,     // インデントの空白数
            'return' => false, // 値を戻すか出力するか
        ];

        // 再帰用クロージャ
        $export = function ($value, $context, $nest = 0, $parents = []) use (&$export, $options) {
            // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
            foreach ($parents as $parent) {
                if ($parent === $value) {
                    return $export('*RECURSION*', 'recursion');
                }
            }

            $space = $options['minify'] ? "" : " ";
            $break = $options['minify'] ? "" : "\n";

            // 配列は連想判定したり再帰したり色々
            if (is_array($value)) {
                $spacer1 = str_repeat($space, ($nest + 1) * $options['indent']);
                $spacer2 = str_repeat($space, $nest * $options['indent']);

                $hashed = is_hasharray($value);

                // スカラー値のみで構成されているならシンプルな再帰
                if (!$hashed && array_all($value, fn(...$args) => is_primitive(...$args))) {
                    return '[' . implode(",$space", array_map(fn($v) => $export($v, 'array-value'), $value)) . ']';
                }

                // 連想配列はキーを含めて桁あわせ
                if ($hashed) {
                    $keys = array_map(fn($v) => $export($v, 'array-key'), array_combine($keys = array_keys($value), $keys));
                    $maxlen = max(array_map('strlen', $keys));
                }
                $kvl = '';
                $lastkey = array_key_last($value);
                $parents[] = $value;
                foreach ($value as $k => $v) {
                    $keystr = $hashed ? $keys[$k] . str_repeat($space, $maxlen - strlen($keys[$k])) . "$space=>$space" : '';
                    $kvl .= $spacer1 . $keystr . $export($v, 'array-value', $nest + 1, $parents) . ($k === $lastkey && $options['minify'] ? "" : ",") . "$break";
                }
                return "[$break{$kvl}{$spacer2}]";
            }
            // オブジェクトは単にプロパティを __set_state する文字列を出力する
            elseif (is_object($value)) {
                $parents[] = $value;
                $classname = get_class($value);
                if ($classname === \stdClass::class) {
                    return "(object)$space" . $export((array) $value, 'object', $nest, $parents);
                }
                return $classname . '::__set_state(' . $export(object_properties($value), 'object', $nest, $parents) . ')';
            }
            // 文字列はダブルクオート（場合によってはヒアドキュメント）
            elseif (is_string($value)) {
                // 列揃えのため配列のキーは常にダブルクォート
                if ($context === 'array-key') {
                    return str_quote($value);
                }
                // 改行を含むならヒアドキュメント
                if (!$options['minify'] && str_exists($value, ["\r", "\n"])) {
                    // ただし、改行文字だけの場合は除く（何らかの引数で改行文字だけを渡すシチュエーションはそれなりにあるのでヒアドキュメントだと冗長）
                    if (trim($value, "\r\n") !== '') {
                        return str_quote($value, [
                            'heredoc' => unique_string($value, 'TEXT', '_'),
                            'indent'  => $nest * $options['indent'],
                        ]);
                    }
                }
                return str_quote($value);
            }
            // null は小文字で居て欲しい
            elseif (is_null($value)) {
                return 'null';
            }
            // それ以外は標準に従う
            else {
                return var_export($value, true);
            }
        };

        // 結果を返したり出力したり
        $result = $export($value, null);
        if ($options['return']) {
            return $result;
        }
        echo $result, "\n";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_export3') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_export3'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_export3')) {
    /**
     * var_export を色々と出力できるようにしたもの
     *
     * php のコードに落とし込むことで serialize と比較してかなり高速に動作する。
     *
     * 各種オブジェクトやクロージャ、循環参照を含む配列など様々なものが出力できる。
     * ただし、下記は不可能あるいは復元不可（今度も対応するかは未定）。
     *
     * - 特定の内部クラス（PDO など）
     * - 大部分のリソース
     *
     * オブジェクトは「リフレクションを用いてコンストラクタなしで生成してプロパティを代入する」という手法で復元する。
     * ただしコンストラクタが必須引数無しの場合はコールされる。
     * のでクラスによってはおかしな状態で復元されることがある（大体はリソース型のせいだが…）。
     * sleep, wakeup, Serializable などが実装されているとそれはそのまま機能する。
     * set_state だけは呼ばれないので注意。
     *
     * Generator は元となった関数/メソッドを再コールすることで復元される。
     * その仕様上、引数があると呼べないし、実行位置はリセットされる。
     *
     * クロージャはコード自体を引っ張ってきて普通に function (){} として埋め込む。
     * クラス名のエイリアスや use, $this バインドなど可能な限り復元するが、おそらくあまりに複雑なことをしてると失敗する。
     *
     * リソースはファイル的なリソースであればメタ情報を出力して復元時に再オープンする。
     *
     * 軽くベンチを取ったところ、オブジェクトを含まない純粋な配列の場合、serialize の 200 倍くらいは速い（それでも var_export の方が速いが…）。
     * オブジェクトを含めば含むほど遅くなり、全要素がオブジェクトになると serialize と同程度になる。
     * 大体 var_export:var_export3:serialize が 1:5:1000 くらい。
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value エクスポートする値
     * @param bool|array $return 返り値として返すなら true. 配列を与えるとオプションになる
     * @return string エクスポートされた文字列
     */
    function var_export3($value, $return = false)
    {
        // 原則として var_export に合わせたいのでデフォルトでは bool: false で単に出力するのみとする
        if (is_bool($return)) {
            $return = [
                'return' => $return,
            ];
        }
        $options = $return;
        $options += [
            'format'  => 'pretty', // pretty or minify
            'outmode' => null,     // null: 本体のみ, 'eval': return ...;, 'file': <?php return ...;
        ];
        $options['return'] ??= !!$options['outmode'];

        $var_manager = new class() {
            private $vars = [];
            private $refs = [];

            private function arrayHasReference($array)
            {
                foreach ($array as $k => $v) {
                    $ref = \ReflectionReference::fromArrayElement($array, $k);
                    if ($ref) {
                        return true;
                    }
                    if (is_array($v) && $this->arrayHasReference($v)) {
                        return true;
                    }
                }
                return false;
            }

            public function varId($var)
            {
                // オブジェクトは明確な ID が取れる（generator/closure/object の区分けに処理的な意味はない）
                if (is_object($var)) {
                    $id = ($var instanceof \Generator ? 'generator' : ($var instanceof \Closure ? 'closure' : 'object')) . (spl_object_id($var) + 1);
                    $this->vars[$id] = $var;
                    return $id;
                }
                // 配列は明確な ID が存在しないので、貯めて検索して ID を振る（参照さえ含まなければ ID に意味はないので参照込みのみ）
                if (is_array($var) && $this->arrayHasReference($var)) {
                    $id = array_search($var, $this->vars, true);
                    if (!$id) {
                        $id = 'array' . (count($this->vars) + 1);
                    }
                    $this->vars[$id] = $var;
                    return $id;
                }
                // リソースも一応は ID がある
                if (is_resourcable($var)) {
                    $id = 'resource' . (int) $var;
                    $this->vars[$id] = $var;
                    return $id;
                }
            }

            public function refId($array, $k)
            {
                static $ids = [];
                $ref = \ReflectionReference::fromArrayElement($array, $k);
                if ($ref) {
                    $refid = $ref->getId();
                    $ids[$refid] = ($ids[$refid] ?? count($ids) + 1);
                    $id = 'reference' . $ids[$refid];
                    $this->refs[$id] = $array[$k];
                    return $id;
                }
            }

            public function orphan()
            {
                foreach ($this->refs as $rid => $var) {
                    $vid = array_search($var, $this->vars, true);
                    yield $rid => [!!$vid, $vid, $var];
                }
            }
        };

        // 再帰用クロージャ
        $vars = [];
        $export = function ($value, $nest = 0, $raw = false) use (&$export, &$vars, $var_manager) {
            $spacer0 = str_repeat(" ", 4 * max(0, $nest + 0));
            $spacer1 = str_repeat(" ", 4 * max(0, $nest + 1));
            $raw_export = fn($v) => $v;
            $var_export = fn($v) => var_export($v, true);
            $neighborToken = function ($n, $d, $tokens) {
                for ($i = $n + $d; isset($tokens[$i]); $i += $d) {
                    if ($tokens[$i]->id !== T_WHITESPACE) {
                        return $tokens[$i];
                    }
                }
            };
            $resolveSymbol = function ($token, $prev, $next, $ref) use ($var_export) {
                $text = $token->text;
                if ($token->id === T_STRING) {
                    if ($prev->id === T_NEW || $next->id === T_DOUBLE_COLON || $next->id === T_VARIABLE || $next->text === '{') {
                        $text = namespace_resolve($text, $ref->getFileName(), 'alias') ?? $text;
                    }
                    elseif ($next->text === '(') {
                        $text = namespace_resolve($text, $ref->getFileName(), 'function') ?? $text;
                        // 関数・定数は use しなくてもグローバルにフォールバックされる（=グローバルと名前空間の区別がつかない）
                        if (!function_exists($text) && function_exists($nstext = '\\' . $ref->getNamespaceName() . '\\' . $text)) {
                            $text = $nstext;
                        }
                    }
                    else {
                        $text = namespace_resolve($text, $ref->getFileName(), 'const') ?? $text;
                        // 関数・定数は use しなくてもグローバルにフォールバックされる（=グローバルと名前空間の区別がつかない）
                        if (!const_exists($text) && const_exists($nstext = '\\' . $ref->getNamespaceName() . '\\' . $text)) {
                            $text = $nstext;
                        }
                    }
                }

                // マジック定数の解決（__CLASS__, __TRAIT__ も書き換えなければならないが、非常に大変なので下記のみ）
                if ($token->id === T_FILE) {
                    $text = $var_export($ref->getFileName());
                }
                if ($token->id === T_DIR) {
                    $text = $var_export(dirname($ref->getFileName()));
                }
                if ($token->id === T_NS_C) {
                    $text = $var_export($ref->getNamespaceName());
                }
                if ($text !== null) {
                    $token = clone $token;
                    $token->text = $text;
                }
                return $token;
            };

            $vid = $var_manager->varId($value);
            if ($vid) {
                if (isset($vars[$vid])) {
                    return "\$this->$vid";
                }
                $vars[$vid] = $value;
            }

            if (is_array($value)) {
                $hashed = is_hasharray($value);
                if (!$hashed && array_all($value, fn(...$args) => is_primitive(...$args))) {
                    [$begin, $middle, $end] = ["", ", ", ""];
                }
                else {
                    [$begin, $middle, $end] = ["\n{$spacer1}", ",\n{$spacer1}", ",\n{$spacer0}"];
                }

                $keys = array_map($var_export, array_combine($keys = array_keys($value), $keys));
                $maxlen = max(array_map('strlen', $keys ?: ['']));
                $kvl = [];
                foreach ($value as $k => $v) {
                    $refid = $var_manager->refId($value, $k);
                    $keystr = $hashed ? $keys[$k] . str_repeat(" ", $maxlen - strlen($keys[$k])) . " => " : '';
                    $valstr = $refid ? "&\$this->$refid" : $export($v, $nest + 1);
                    $kvl[] = $keystr . $valstr;
                }
                $kvl = implode($middle, $kvl);
                $declare = $vid ? "\$this->$vid = " : "";
                return "{$declare}[$begin{$kvl}$end]";
            }
            if ($value instanceof \Generator) {
                $ref = new \ReflectionGenerator($value);
                $reffunc = $ref->getFunction();

                if ($reffunc->getNumberOfRequiredParameters() > 0) {
                    throw new \DomainException('required argument Generator is not support.');
                }

                $caller = null;
                if ($reffunc instanceof \ReflectionFunction) {
                    if ($reffunc->isClosure()) {
                        $caller = "({$export($reffunc->getClosure(), $nest)})";
                    }
                    else {
                        $caller = $reffunc->name;
                    }
                }
                if ($reffunc instanceof \ReflectionMethod) {
                    if ($reffunc->isStatic()) {
                        $caller = "{$reffunc->class}::{$reffunc->name}";
                    }
                    else {
                        $caller = "{$export($ref->getThis(), $nest)}->{$reffunc->name}";
                    }
                }
                return "\$this->$vid = {$caller}()";
            }
            if ($value instanceof \Closure) {
                $ref = new \ReflectionFunction($value);
                $bind = $ref->getClosureThis();
                $class = $ref->getClosureScopeClass() ? $ref->getClosureScopeClass()->getName() : null;
                $statics = $ref->getStaticVariables();

                // 内部由来はきちんと fromCallable しないと差異が出てしまう
                if ($ref->isInternal()) {
                    $receiver = $bind ?? $class;
                    $callee = $receiver ? [$receiver, $ref->getName()] : $ref->getName();
                    return "\$this->$vid = \\Closure::fromCallable({$export($callee, $nest)})";
                }

                [$meta, $body] = callable_code($value);
                $arrow = starts_with($meta, 'fn') ? ' => ' : ' ';
                $tokens = array_slice(php_parse("<?php $meta{$arrow}$body;", TOKEN_PARSE), 1, -1);

                $uses = [];
                $context = [
                    'class' => 0,
                    'brace' => 0,
                ];
                foreach ($tokens as $n => $token) {
                    $prev = $neighborToken($n, -1, $tokens) ?? (object) ['id' => null, 'text' => null, 'line' => null];
                    $next = $neighborToken($n, +1, $tokens) ?? (object) ['id' => null, 'text' => null, 'line' => null];

                    // クロージャは何でもかける（クロージャ・無名クラス・ジェネレータ etc）のでネスト（ブレース）レベルを記録しておく
                    if ($token->text === '{') {
                        $context['brace']++;
                    }
                    if ($token->text === '}') {
                        $context['brace']--;
                    }

                    // 無名クラスは色々厄介なので読み飛ばすために覚えておく
                    if ($prev->id === T_NEW && $token->id === T_CLASS) {
                        $context['class'] = $context['brace'];
                    }
                    // そして無名クラスは色々かける上に終了条件が自明ではない（シンタックスエラーでない限りは {} が一致するはず）
                    if ($token->text === '}' && $context['class'] === $context['brace']) {
                        $context['class'] = 0;
                    }

                    // fromCallable 由来だと名前がついてしまう
                    if (!$context['class'] && $prev->id === T_FUNCTION && $token->id === T_STRING) {
                        unset($tokens[$n]);
                        continue;
                    }

                    // use 変数の導出
                    if ($token->id === T_VARIABLE) {
                        $varname = substr($token->text, 1);
                        // クロージャ内クロージャの use に反応してしまうので存在するときのみとする
                        if (array_key_exists($varname, $statics) && !isset($uses[$varname])) {
                            $recurself = $statics[$varname] === $value ? '&' : '';
                            $uses[$varname] = "$spacer1\$$varname = $recurself{$export($statics[$varname], $nest + 1)};\n";
                        }
                    }

                    $tokens[$n] = $resolveSymbol($token, $prev, $next, $ref);
                }

                $code = php_indent(implode('', array_column($tokens, 'text')), [
                    'indent'   => $spacer1,
                    'baseline' => -1,
                ]);
                if ($bind) {
                    $scope = $var_export($class === 'Closure' ? 'static' : $class);
                    $code = "\Closure::bind($code, {$export($bind, $nest + 1)}, $scope)";
                }
                elseif (!is_bindable_closure($value)) {
                    $code = "static $code";
                }

                return "\$this->$vid = (function () {\n{$raw_export(implode('', $uses))}{$spacer1}return $code;\n$spacer0})->call(\$this)";
            }
            if (is_object($value)) {
                $ref = new \ReflectionObject($value);

                // enum はリテラルを返せばよい
                if ($value instanceof \UnitEnum) {
                    $declare = "\\$ref->name::$value->name";
                    if ($ref->getConstant($value->name) === $value) {
                        return "\$this->$vid = $declare";
                    }
                    // enum の polyfill で、__callStatic を利用して疑似的にエミュレートしているライブラリは多い
                    // もっとも、「多い」だけであり、そうとは限らないので値は見る必要はある（例外が飛ぶかもしれないので try も必要）
                    if ($ref->hasMethod('__callStatic')) {
                        try {
                            if ($declare() === $value) {
                                return "\$this->$vid = $declare()";
                            }
                        }
                        catch (\Throwable) { // @codeCoverageIgnore
                            // through. treat regular object
                        }
                    }
                }

                // 弱参照系は同時に渡ってきていれば復元できる
                if ($value instanceof \WeakReference) {
                    $weakreference = $value->get();
                    if ($weakreference === null) {
                        $weakreference = new \stdClass();
                    }
                    return "\$this->$vid = \\WeakReference::create({$export($weakreference, $nest)})";
                }
                if ($value instanceof \WeakMap) {
                    $weakmap = "{$spacer1}\$this->$vid = new \\WeakMap();\n";
                    foreach ($value as $object => $data) {
                        $weakmap .= "{$spacer1}\$this->{$vid}[{$export($object)}] = {$export($data)};\n";
                    }
                    return "\$this->$vid = (function () {\n{$weakmap}{$spacer1}return \$this->$vid;\n$spacer0})->call(\$this)";
                }

                // 内部クラスで serialize 出来ないものは __PHP_Incomplete_Class で代替（復元時に無視する）
                try {
                    if ($ref->isInternal()) {
                        serialize($value);
                    }
                }
                catch (\Exception) {
                    return "\$this->$vid = new \\__PHP_Incomplete_Class()";
                }

                // 無名クラスは定義がないのでパースが必要
                // さらにコンストラクタを呼ぶわけには行かない（引数を検出するのは不可能）ので潰す必要もある
                if ($ref->isAnonymous()) {
                    $fname = $ref->getFileName();
                    $sline = $ref->getStartLine();
                    $eline = $ref->getEndLine();
                    $tokens = php_parse('<?php ' . implode('', array_slice(file($fname), $sline - 1, $eline - $sline + 1)));

                    $block = [];
                    $starting = false;
                    $constructing = 0;
                    $nesting = 0;
                    foreach ($tokens as $n => $token) {
                        $prev = $neighborToken($n, -1, $tokens) ?? [null, null, null];
                        $next = $neighborToken($n, +1, $tokens) ?? [null, null, null];

                        // 無名クラスは new class か new #[Attribute] で始まるはず（new #[A] ClassName は許可されていない）
                        if (($token->id === T_NEW && $next->id === T_CLASS) || ($token->id === T_NEW && $next->id === T_ATTRIBUTE)) {
                            $starting = true;
                        }
                        if (!$starting) {
                            continue;
                        }

                        // コンストラクタの呼び出し引数はスキップする
                        if ($constructing !== null) {
                            if ($token->text === '(') {
                                $constructing++;
                            }
                            if ($token->text === ')') {
                                $constructing--;
                                if ($constructing === 0) {
                                    $constructing = null;          // null を終了済みマークとして変数を再利用している
                                    $block[] = [null, '()', null]; // for psr-12
                                    continue;
                                }
                            }
                            if ($constructing) {
                                continue;
                            }
                        }

                        // 引数ありコンストラクタは呼ばないのでリネームしておく
                        if ($token->text === '__construct' && $ref->getConstructor() && $ref->getConstructor()->getNumberOfRequiredParameters()) {
                            $token = clone $token;
                            $token->text = "replaced__construct";
                        }

                        $block[] = $resolveSymbol($token, $prev, $next, $ref);

                        if ($token->text === '{') {
                            $nesting++;
                        }
                        if ($token->text === '}') {
                            $nesting--;
                            if ($nesting === 0) {
                                break;
                            }
                        }
                    }

                    $code = php_indent(implode('', array_column($block, 'text')), [
                        'indent'   => $spacer1,
                        'baseline' => -1,
                    ]);
                    if ($raw) {
                        return $code;
                    }
                    $classname = "(function () {\n{$spacer1}return $code;\n{$spacer0}})";
                }
                else {
                    $classname = "\\" . get_class($value) . "::class";
                }

                $privates = [];

                // __serialize があるならそれに従う
                if (method_exists($value, '__serialize')) {
                    $fields = $value->__serialize();
                }
                // __sleep があるならそれをプロパティとする
                elseif (method_exists($value, '__sleep')) {
                    $fields = array_intersect_key(object_properties($value, $privates), array_flip($value->__sleep()));
                }
                // それ以外は適当に漁る
                else {
                    $fields = object_properties($value, $privates);
                }

                return "\$this->new(\$this->$vid, $classname, (function () {\n{$spacer1}return {$export([$fields, $privates], $nest + 1)};\n{$spacer0}}))";
            }
            if (is_resourcable($value)) {
                // スタンダードなリソースなら復元できないこともない
                $meta = stream_get_meta_data($value);
                $stream_type = strtolower($meta['stream_type']);
                if (!in_array($stream_type, ['stdio', 'output', 'temp', 'memory'], true)) {
                    throw new \DomainException('resource is supported stream resource only.');
                }
                $meta['position'] = @ftell($value);
                $meta['context'] = stream_context_get_options($value);
                $meta['buffer'] = null;
                if (in_array($stream_type, ['temp', 'memory'], true)) {
                    $meta['buffer'] = stream_get_contents($value, null, 0);
                }
                return "\$this->$vid = \$this->open({$export($meta, $nest + 1)})";
            }

            return is_null($value) ? 'null' : $var_export($value);
        };

        $exported = $export($value, 1);
        $others = [];
        $vars = [];
        foreach ($var_manager->orphan() as $rid => [$isref, $vid, $var]) {
            $declare = $isref ? "&\$this->$vid" : $export($var, 1);
            $others[] = "\$this->$rid = $declare;";
        }

        static $factory = null;
        if ($factory === null) {
            // @codeCoverageIgnoreStart
            $factory = $export(new #[\AllowDynamicProperties] class() {
                public function new(&$object, $class, $provider)
                {
                    if ($class instanceof \Closure) {
                        $object = $class();
                        $reflection = $this->reflect(get_class($object));
                    }
                    else {
                        $reflection = $this->reflect($class);
                        if ($reflection["constructor"] && $reflection["constructor"]->getNumberOfRequiredParameters() === 0) {
                            $object = $reflection["self"]->newInstance();
                        }
                        else {
                            $object = $reflection["self"]->newInstanceWithoutConstructor();
                        }
                    }
                    [$fields, $privates] = $provider();

                    if ($reflection["unserialize"]) {
                        $object->__unserialize($fields);
                        return $object;
                    }

                    foreach ($reflection["parents"] as $parent) {
                        foreach ($this->reflect($parent->name)["properties"] as $name => $property) {
                            if (isset($privates[$parent->name][$name]) && !$privates[$parent->name][$name] instanceof \__PHP_Incomplete_Class) {
                                $property->setValue($object, $privates[$parent->name][$name]);
                            }
                            if (array_key_exists($name, $fields)) {
                                if (!$fields[$name] instanceof \__PHP_Incomplete_Class) {
                                    $property->setValue($object, $fields[$name]);
                                }
                                unset($fields[$name]);
                            }
                        }
                    }
                    foreach ($fields as $name => $value) {
                        $object->$name = $value;
                    }

                    if ($reflection["wakeup"]) {
                        $object->__wakeup();
                    }

                    return $object;
                }

                public function open($metadata)
                {
                    $resource = fopen($metadata['uri'], $metadata['mode'], false, stream_context_create($metadata['context']));
                    if ($resource === false) {
                        return null;
                    }
                    if ($metadata['seekable'] && is_string($metadata['buffer'])) {
                        fwrite($resource, $metadata['buffer']);
                    }
                    if ($metadata['seekable'] && is_int($metadata['position'])) {
                        fseek($resource, $metadata['position']);
                    }
                    return $resource;
                }

                private function reflect($class)
                {
                    static $cache = [];
                    if (!isset($cache[$class])) {
                        $refclass = new \ReflectionClass($class);
                        $cache[$class] = [
                            "self"        => $refclass,
                            "constructor" => $refclass->getConstructor(),
                            "parents"     => [],
                            "properties"  => [],
                            "unserialize" => $refclass->hasMethod("__unserialize"),
                            "wakeup"      => $refclass->hasMethod("__wakeup"),
                        ];
                        for ($current = $refclass; $current; $current = $current->getParentClass()) {
                            $cache[$class]["parents"][$current->name] = $current;
                        }
                        foreach ($refclass->getProperties() as $property) {
                            if (!$property->isStatic()) {
                                $property->setAccessible(true);
                                $cache[$class]["properties"][$property->name] = $property;
                            }
                        }
                    }
                    return $cache[$class];
                }
            }, -1, true);
            // @codeCoverageIgnoreEnd
        }

        $E = fn($v) => $v;
        $result = <<<PHP
            (function () {
                {$E(implode("\n    ", $others))}
                return $exported;
            })->call($factory)
            PHP;

        if ($options['format'] === 'minify') {
            $tmp = tempnam(sys_get_temp_dir(), 've3');
            file_put_contents($tmp, "<?php $result;");
            $result = substr(php_strip_whitespace($tmp), 6, -1);
        }

        if ($options['outmode'] === 'eval') {
            $result = "return $result;";
        }
        if ($options['outmode'] === 'file') {
            $result = "<?php return $result;\n";
        }

        if (!$options['return']) {
            echo $result;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_hash') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_hash'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_hash')) {
    /**
     * 値に複数のハッシュアルゴリズムを適用させて結合して返す
     *
     * $data は何らかの方法で文字列化される（この「何らかの方法」は互換性を担保しない）。
     * 文字長がかなり増えるため、 $base64 に true を与えるとバイナリ変換してその結果を base64（url セーフ）して返す。
     * さらに false を与えると 16進数文字列で返し、 null を与えるとバイナリ文字列で返す。
     *
     * Example:
     * ```php
     * // 配列をハッシュ化する
     * that(var_hash(['a', 'b', 'c']))->isSame('7BDgx6NE2hkXAKtKzhpeJm6-mheMOQWNgrCe7768OiFeoWgA');
     * // オブジェクトをハッシュ化する
     * that(var_hash(new \ArrayObject(['a', 'b', 'c'])))->isSame('-zR2rZ58CzuYhhdHn1Oq90zkYSaxMS-dHUbmb0MTRM4gBpj2');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var ハッシュ化する値
     * @param string[] $algos ハッシュアルゴリズム
     * @param ?bool $base64 結果を base64 化するか
     * @return string ハッシュ文字列
     */
    function var_hash($var, $algos = ['md5', 'sha1'], $base64 = true)
    {
        if (!is_string($var)) {
            $var = serialize($var);
        }

        $algos = arrayize($algos);
        assert($algos);

        $hash = '';
        foreach ($algos as $algo) {
            $hash .= hash($algo, "$var", $base64 !== false);
        }

        if ($base64 !== true) {
            return $hash;
        }

        return base64url_encode($hash);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_html') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_html'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_html')) {
    /**
     * var_export2 を html コンテキストに特化させたようなもの
     *
     * 下記のような出力になる。
     * - `<pre class='var_html'> ～ </pre>` で囲まれる
     * - php 構文なのでハイライトされて表示される
     * - Content-Type が強制的に text/html になる
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     */
    function var_html($value)
    {
        $var_export = function ($value) {
            $result = var_export($value, true);
            $result = highlight_string("<?php " . $result, true);
            $result = preg_replace('#&lt;\\?php(\s|&nbsp;)#u', '', $result, 1);
            $result = preg_replace('#<br />#u', "\n", $result);
            $result = preg_replace('#>\n<#u', '><', $result);
            return $result;
        };

        $export = function ($value, $parents) use (&$export, $var_export) {
            foreach ($parents as $parent) {
                if ($parent === $value) {
                    return '*RECURSION*';
                }
            }
            if (is_array($value)) {
                $count = count($value);
                if (!$count) {
                    return '[empty]';
                }

                $maxlen = max(array_map('strlen', array_keys($value)));
                $kvl = '';
                $parents[] = $value;
                foreach ($value as $k => $v) {
                    $align = str_repeat(' ', $maxlen - strlen($k));
                    $kvl .= $var_export($k) . $align . ' => ' . $export($v, $parents) . "\n";
                }
                $var = "<var style='text-decoration:underline'>$count elements</var>";
                $summary = "<summary style='cursor:pointer;color:#0a6ebd'>[$var]</summary>";
                return "<details style='display:inline;vertical-align:text-top'>$summary$kvl</details>";
            }
            elseif (is_object($value)) {
                $parents[] = $value;
                return get_class($value) . '::' . $export(object_properties($value), $parents);
            }
            elseif (is_null($value)) {
                return 'null';
            }
            elseif (is_resourcable($value)) {
                return ((string) $value) . '(' . get_resource_type($value) . ')';
            }
            else {
                return $var_export($value);
            }
        };

        // text/html を強制する（でないと見やすいどころか見づらくなる）
        // @codeCoverageIgnoreStart
        if (!headers_sent()) {
            header_remove('Content-Type');
            header('Content-Type: text/html');
        }
        // @codeCoverageIgnoreEnd

        echo "<pre class='var_html'>{$export($value, [])}</pre>";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_pretty') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_pretty'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_pretty')) {
    /**
     * var_dump の出力を見やすくしたもの
     *
     * var_dump はとても縦に長い上見づらいので色や改行・空白を調整して見やすくした。
     * sapi に応じて自動で色分けがなされる（$context で指定もできる）。
     * また、 xdebug のように呼び出しファイル:行数が先頭に付与される。
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * Example:
     * ```php
     * // 下記のように出力される（実際は色付きで出力される）
     * $using = 123;
     * var_pretty([
     *     "array"   => [1, 2, 3],
     *     "hash"    => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     *     "object"  => new \Exception(),
     *     "closure" => function () use ($using) { },
     * ]);
     * ?>
     * {
     *   array: [1, 2, 3],
     *   hash: {
     *     a: 'A',
     *     b: 'B',
     *     c: 'C',
     *   },
     *   object: Exception#1 {
     *     message: '',
     *     string: '',
     *     code: 0,
     *     file: '...',
     *     line: 19,
     *     trace: [],
     *     previous: null,
     *   },
     *   closure: Closure#0(static) use {
     *     using: 123,
     *   },
     * }
     * <?php
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     * @param array $options 出力オプション
     * @return string return: true なら値の出力結果
     */
    function var_pretty($value, $options = [])
    {
        $options += [
            'minify'        => false, // 短縮形で返す（実質的には情報を減らして1行で返す）
            'indent'        => 2,     // インデントの空白数
            'context'       => null,  // html なコンテキストか cli なコンテキストか
            'return'        => false, // 値を戻すか出力するか
            'trace'         => false, // スタックトレースの表示
            'callback'      => null,  // 値1つごとのコールバック（値と文字列表現（参照）が引数で渡ってくる）
            'debuginfo'     => true,  // debugInfo を利用してオブジェクトのプロパティを絞るか
            'table'         => true,  // 連想配列の配列の場合にテーブル表示するか（コールバック。true はマークダウン風味固定）
            'maxcolumn'     => null,  // 1行あたりの文字数
            'maxcount'      => null,  // 複合型の要素の数
            'maxdepth'      => null,  // 複合型の深さ
            'maxlength'     => null,  // スカラー・非複合配列の文字数
            'maxlistcolumn' => 120,   // 通常配列を1行化する文字数
            'limit'         => null,  // 最終出力の文字数
            'excludeclass'  => [],    // 除外するクラス名
        ];

        if ($options['context'] === null) {
            $options['context'] = 'html'; // SAPI でテストカバレッジが辛いので if else ではなくデフォルト代入にしてある
            if (PHP_SAPI === 'cli') {
                $options['context'] = is_ansi(STDOUT) && !$options['return'] ? 'cli' : 'plain';
            }
        }

        if ($options['minify']) {
            $options['indent'] = null;
            $options['trace'] = false;
        }

        $appender = new class($options) {
            private $options;
            private $objects;
            private $content;
            private $length;
            private $column;

            public function __construct($options)
            {
                $this->options = $options;
                $this->objects = [];
                $this->content = '';
                $this->length = 0;
                $this->column = 0;
            }

            private function _append($value, $style = null, $data = []): self
            {
                if ($this->options['minify']) {
                    $value = strtr($value, ["\n" => ' ']);
                }

                $strlen = strlen($value);

                if ($this->options['limit'] && $this->options['limit'] < $this->length += $strlen) {
                    throw new \LengthException($this->content);
                }

                //$current = count($this->content) - 1;
                if ($this->options['maxcolumn'] !== null) {
                    $basecolumn = $this->column;
                    $breakpos = strrpos($value, "\n");
                    if ($breakpos === false) {
                        $this->column += $strlen;
                    }
                    else {
                        $this->column = $strlen - $breakpos - 1;
                    }
                    if ($basecolumn !== 0 && $this->column >= $this->options['maxcolumn']) {
                        preg_match('# +#', $this->content, $m, 0, strrpos($this->content, "\n"));
                        $this->column = 0;
                        $this->content .= "\n\t" . ($m[0] ?? '');
                    }
                }

                if ($style === null || $this->options['context'] === 'plain') {
                    $this->content .= $value;
                }
                elseif ($this->options['context'] === 'cli') {
                    $this->content .= ansi_colorize($value, $style);
                }
                elseif ($this->options['context'] === 'html') {
                    // 今のところ bold しか使っていないのでこれでよい
                    $style = $style === 'bold' ? 'font-weight:bold' : "color:$style";
                    $dataattr = array_sprintf($data, 'data-%2$s="%1$s"', ' ');
                    $this->content .= "<span style='$style' $dataattr>" . htmlspecialchars($value, ENT_QUOTES) . '</span>';
                }
                else {
                    throw new \InvalidArgumentException("'{$this->options['context']}' is not supported.");
                }
                return $this;
            }

            public function plain($token, $style = null): self
            {
                return $this->_append($token, $style);
            }

            public function index($token): self
            {
                if (is_int($token)) {
                    return $this->_append($token, 'bold');
                }
                elseif (is_string($token)) {
                    return $this->_append($token, 'red');
                }
                elseif (is_array($token)) {
                    return $this->_append($this->string($token), 'cyan');
                }
                elseif (is_object($token)) {
                    return $this->_append($this->string($token), 'green', ['type' => 'object-index', 'id' => spl_object_id($token)]);
                }
                else {
                    throw new \DomainException(); // @codeCoverageIgnore
                }
            }

            public function value($token): self
            {
                if (is_null($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'null']);
                }
                elseif (is_object($token)) {
                    return $this->_append($this->string($token), 'green', ['type' => 'object', 'id' => spl_object_id($token)]);
                }
                elseif (is_string($token)) {
                    return $this->_append($this->string($token), 'magenta', ['type' => 'scalar']);
                }
                elseif (is_bool($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'bool']);
                }
                elseif (is_scalar($token)) {
                    return $this->_append($this->string($token), 'magenta', ['type' => 'scalar']);
                }
                elseif (is_resourcable($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'resource']);
                }
                else {
                    throw new \DomainException(); // @codeCoverageIgnore
                }
            }

            public function string($token): string
            {
                if (is_null($token)) {
                    return 'null';
                }
                elseif (is_array($token)) {
                    return json_encode($token, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
                }
                elseif (is_object($token)) {
                    if ($token instanceof \Generator) {
                        try {
                            $ref = new \ReflectionGenerator($token);
                            $ename = $ref->getExecutingFile();
                            $eline = $ref->getExecutingLine();
                            return get_class($token) . "#" . spl_object_id($token) . "@$ename:$eline";
                        }
                        catch (\ReflectionException) {
                            return get_class($token) . "#" . spl_object_id($token);
                        }
                    }
                    if ($token instanceof \Closure) {
                        $ref = new \ReflectionFunction($token);
                        $fname = $ref->getFileName();
                        $sline = $ref->getStartLine();
                        $eline = $ref->getEndLine();
                        if ($fname && $sline && $eline) {
                            $lines = $sline === $eline ? $sline : "$sline~$eline";
                            return get_class($token) . "#" . spl_object_id($token) . "@$fname:$lines";
                        }
                    }
                    return get_class($token) . "#" . spl_object_id($token);
                }
                elseif (is_string($token)) {
                    if ($this->options['maxlength']) {
                        $token = str_ellipsis($token, $this->options['maxlength'], '...(too length)...');
                    }
                    return json_encode($token, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
                }
                elseif (is_scalar($token)) {
                    return var_export($token, true);
                }
                elseif (is_resourcable($token)) {
                    return sprintf('%s of type (%s)', $token, get_resource_type($token));
                }
                else {
                    throw new \DomainException(gettype($token)); // @codeCoverageIgnore
                }
            }

            public function array($value): array
            {
                if (is_array($value)) {
                    return $value;
                }
                if (is_object($value)) {
                    if ($this->options['debuginfo'] && method_exists($value, '__debugInfo')) {
                        $properties = [];
                        foreach (array_reverse($value->__debugInfo(), true) as $k => $v) {
                            $p = strrpos($k, "\0");
                            if ($p !== false) {
                                $k = substr($k, $p + 1);
                            }
                            $properties[$k] = $v;
                        }
                    }
                    else {
                        $properties = object_properties($value);
                    }
                    return $properties;
                }
            }

            public function export($value, $nest, $parents, $keys, $callback)
            {
                $position = strlen($this->content);

                $spacer1 = $this->options['indent'] === null ? '' : str_repeat(' ', ($nest + 1) * $this->options['indent']);
                $spacer2 = $this->options['indent'] === null ? '' : str_repeat(' ', ($nest + 0) * $this->options['indent']);

                // オブジェクトは一度処理してれば無駄なので参照表示
                if (is_object($value)) {
                    $id = spl_object_id($value);
                    if (isset($this->objects[$id])) {
                        $this->index($value);
                        goto FINALLY_;
                    }
                    $this->objects[$id] = $value;
                }

                // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
                foreach ($parents as $parent) {
                    if ($parent === $value) {
                        $this->plain('*RECURSION*');
                        goto FINALLY_;
                    }
                }

                if (is_array($value)) {
                    if ($this->options['maxdepth'] && $nest + 1 > $this->options['maxdepth']) {
                        $this->plain('(too deep)');
                        goto FINALLY_;
                    }

                    $parents[] = $value;

                    $count = count($value);
                    $omitted = false;
                    if ($this->options['maxcount'] && ($omitted = $count - $this->options['maxcount']) > 0) {
                        $value = array_slice($value, 0, $this->options['maxcount'], true);
                    }

                    $is_hasharray = is_hasharray($value);
                    $primitive_only = array_all($value, fn(...$args) => is_primitive(...$args));
                    $assoc = !$this->options['minify'] && ($is_hasharray || !$primitive_only);
                    $tableofarray = (function () use ($count, $value) {
                        if ($this->options['minify'] || !$this->options['table'] || $count <= 1) {
                            return null;
                        }

                        $first = reset($value);
                        $objective = is_object($first);
                        if ((!is_array($first) && !$objective) || empty($first)) {
                            return null;
                        }

                        // オブジェクトの一致性は完全同一クラス（継承や実装は見ない）、配列はキーが同じものとする
                        if ($objective) {
                            $first_condition = get_class($first);
                        }
                        else {
                            $first_condition = array_keys($first);
                            if (array_any($first_condition, 'is_int')) {
                                return null;
                            }
                        }

                        foreach ($value as $v) {
                            if (true
                                && !(is_array($v) && array_keys($v) === $first_condition)
                                && !(is_object($v) && get_class($v) === $first_condition)
                            ) {
                                return null;
                            }
                        }

                        return $objective ? "{$first_condition}[]" : 'array[]';
                    })();

                    $key = null;
                    if ($primitive_only) {
                        $lengths = [];
                        foreach ($value as $k => $v) {
                            if ($assoc) {
                                $lengths[] = strlen($this->string($spacer1)) + strlen($this->string($k)) + strlen($this->string($v)) + 4;
                            }
                            else {
                                $lengths[] = strlen($this->string($v)) + 2;
                            }
                        }
                        if ($this->options['maxlength']) {
                            while (count($lengths) > 0 && array_sum($lengths) > $this->options['maxlength']) {
                                $middle = (int) (count($lengths) / 2);
                                $unpos = fn($v, $k, $n) => $n === $middle;
                                array_unset($value, $unpos);
                                array_unset($lengths, $unpos);
                                $key = (int) (count($lengths) / 2);
                            }
                        }
                        // 要素が1つなら複数行化するメリットがないので2以上とする
                        if (count($lengths) >= 2 && ($this->options['maxlistcolumn'] ?? PHP_INT_MAX) <= array_sum($lengths)) {
                            $assoc = !$this->options['minify'] && true;
                        }
                    }

                    if ($count === 0) {
                        $this->plain('[]');
                    }
                    elseif ($tableofarray) {
                        $this->plain($tableofarray, 'green');
                        $this->plain("\n");
                        if ($this->options['table'] === true) {
                            $this->plain(preg_replace('#^#um', $spacer1, markdown_table(array_map(fn($v) => $this->array($v), $value), [
                                'keylabel' => "#",
                                'context'  => $this->options['context'],
                            ])));
                        }
                        else {
                            $this->plain(($this->options['table'])(array_map(fn($v) => $this->array($v), $value), $nest));
                        }
                        $this->plain($spacer2);
                    }
                    elseif ($assoc) {
                        $n = 0;
                        if ($is_hasharray) {
                            $this->plain("{\n");
                        }
                        else {
                            $this->plain("[\n");
                        }
                        if (!$value) {
                            $this->plain($spacer1)->plain('...(too length)...')->plain(",\n");
                        }
                        foreach ($value as $k => $v) {
                            if ($key === $n++) {
                                $this->plain($spacer1)->plain('...(too length)...')->plain(",\n");
                            }
                            $this->plain($spacer1);
                            if ($is_hasharray) {
                                $this->index($k)->plain(': ');
                            }
                            $this->export($v, $nest + 1, $parents, array_merge($keys, [$k]), true);
                            $this->plain(",\n");
                        }
                        if ($omitted > 0) {
                            $this->plain("$spacer1(more $omitted elements)\n");
                        }
                        if ($is_hasharray) {
                            $this->plain("{$spacer2}}");
                        }
                        else {
                            $this->plain("{$spacer2}]");
                        }
                    }
                    else {
                        $lastkey = last_key($value);
                        $n = 0;
                        $this->plain('[');
                        if (!$value) {
                            $this->plain('...(too length)...')->plain(', ');
                        }
                        foreach ($value as $k => $v) {
                            if ($key === $n) {
                                $this->plain('...(too length)...')->plain(', ');
                            }
                            if ($is_hasharray && $n !== $k) {
                                $this->index($k)->plain(':');
                            }
                            $this->export($v, $nest, $parents, array_merge($keys, [$k]), true);
                            if ($k !== $lastkey) {
                                $this->plain(', ');
                            }
                            $n++;
                        }
                        if ($omitted > 0) {
                            $this->plain(" (more $omitted elements)");
                        }
                        $this->plain(']');
                    }
                }
                elseif ($value instanceof \Generator) {
                    $this->value($value);

                    if ($this->options['minify']) {
                        goto FINALLY_;
                    }

                    $this->plain(" {\n");
                    for ($i = 0; $i < 3 && $value->valid(); $i++, $value->next()) {
                        $this->plain("{$spacer1}yield ");
                        $this->index($value->key())->plain(' => ');
                        $this->export($value->current(), $nest + 1, $parents, array_merge($keys, [$value->key()]), true);
                        $this->plain(";\n");
                    }
                    if ($value->valid()) {
                        $this->plain("$spacer1(more yields)\n");
                    }
                    $this->plain("{$spacer2}}");
                }
                elseif ($value instanceof \Closure) {
                    $this->value($value);

                    if ($this->options['minify']) {
                        goto FINALLY_;
                    }

                    $ref = reflect_callable($value);
                    $that = $ref->getClosureThis();
                    $properties = $ref->getStaticVariables();

                    $this->plain("(");
                    if ($that) {
                        $this->index($that);
                    }
                    else {
                        $this->plain("static");
                    }
                    $this->plain(') use ');
                    if ($properties) {
                        $this->export($properties, $nest, $parents, $keys, false);
                    }
                    else {
                        $this->plain('{}');
                    }
                }
                elseif (is_object($value)) {
                    $this->value($value);

                    foreach ((array) $this->options['excludeclass'] as $class) {
                        if ($value instanceof $class) {
                            goto FINALLY_;
                        }
                    }

                    if ($this->options['minify']) {
                        goto FINALLY_;
                    }

                    $properties = $this->array($value);

                    $this->plain(" ");
                    if ($properties) {
                        $this->export($properties, $nest, $parents, $keys, false);
                    }
                    else {
                        $this->plain('{}');
                    }
                }
                else {
                    $this->value($value);
                }

                FINALLY_:
                $content = substr($this->content, $position);
                if ($callback && $this->options['callback']) {
                    ($this->options['callback'])($content, $value, $nest, $keys);
                    $this->content = substr_replace($this->content, $content, $position);
                }
                return $content;
            }
        };

        try {
            $content = $appender->export($value, 0, [], [], false);
        }
        catch (\LengthException $ex) {
            $content = $ex->getMessage() . '(...omitted)';
        }

        if ($options['callback']) {
            ($options['callback'])($content, $value, 0, []);
        }

        // 結果を返したり出力したり
        $traces = [];
        if ($options['trace']) {
            $traces = stacktrace(null, ['format' => "%s:%s", 'args' => false, 'delimiter' => null]);
            $traces = array_reverse(array_slice($traces, 0, $options['trace'] === true ? null : $options['trace']));
            $traces[] = '';
        }
        $result = implode("\n", $traces) . $content;

        if ($options['context'] === 'html') {
            $result = "<pre class='var_pretty'>$result</pre>";
        }
        if ($options['return']) {
            return $result;
        }
        echo $result, "\n";
    }
}

assert(!function_exists('ryunosuke\\ltsv\\var_type') || (new \ReflectionFunction('ryunosuke\\ltsv\\var_type'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\var_type')) {
    /**
     * 値の型を取得する
     *
     * get_debug_type を少しだけ特殊化したもの。
     * 「デバッグ用の型」ではなく「コード化したときに埋め込みやすい型」が主目的。
     *
     * - object の場合は必ず \ が付く
     * - resource の場合はカッコ書き無しで 'resource'
     *
     * 無名クラスの場合は extends, implements の優先順位でその名前を使う。
     * 継承も実装もされていない場合は標準の get_class の結果を返す。
     *
     * Example:
     * ```php
     * // プリミティブ型は get_debug_type と同義
     * that(var_type(false))->isSame('bool');
     * that(var_type(123))->isSame('int');
     * that(var_type(3.14))->isSame('float');
     * that(var_type([1, 2, 3]))->isSame('array');
     * // リソースはなんでも resource
     * that(var_type(STDOUT))->isSame('resource');
     * // オブジェクトは型名を返す
     * that(var_type(new \stdClass))->isSame('\\stdClass');
     * that(var_type(new \Exception()))->isSame('\\Exception');
     * // 無名クラスは継承元の型名を返す（インターフェース実装だけのときはインターフェース名）
     * that(var_type(new class extends \Exception{}))->isSame('\\Exception');
     * that(var_type(new class implements \JsonSerializable{
     *     public function jsonSerialize(): string { return ''; }
     * }))->isSame('\\JsonSerializable');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 型を取得する値
     * @return string 型名
     */
    function var_type($var)
    {
        if (is_object($var)) {
            $ref = new \ReflectionObject($var);
            if ($ref->isAnonymous()) {
                if ($pc = $ref->getParentClass()) {
                    return '\\' . $pc->name;
                }
                if ($is = $ref->getInterfaceNames()) {
                    return '\\' . reset($is);
                }
            }
            return '\\' . get_class($var);
        }
        if (is_resourcable($var)) {
            return 'resource';
        }

        return get_debug_type($var);
    }
}

assert(!function_exists('ryunosuke\\ltsv\\varcmp') || (new \ReflectionFunction('ryunosuke\\ltsv\\varcmp'))->isUserDefined());
if (!function_exists('ryunosuke\\ltsv\\varcmp')) {
    /**
     * php7 の `<=>` の関数版
     *
     * 引数で大文字小文字とか自然順とか型モードとかが指定できる。
     * さらに追加で SORT_STRICT という厳密比較フラグを渡すことができる。
     *
     * Example:
     * ```php
     * // 'a' と 'z' なら 'z' の方が大きい
     * that(varcmp('z', 'a') > 0)->isTrue();
     * that(varcmp('a', 'z') < 0)->isTrue();
     * that(varcmp('a', 'a') === 0)->isTrue();
     *
     * // 'a' と 'Z' なら 'a' の方が大きい…が SORT_FLAG_CASE なので 'Z' のほうが大きい
     * that(varcmp('Z', 'a', SORT_FLAG_CASE) > 0)->isTrue();
     * that(varcmp('a', 'Z', SORT_FLAG_CASE) < 0)->isTrue();
     * that(varcmp('a', 'A', SORT_FLAG_CASE) === 0)->isTrue();
     *
     * // '2' と '12' なら '2' の方が大きい…が SORT_NATURAL なので '12' のほうが大きい
     * that(varcmp('12', '2', SORT_NATURAL) > 0)->isTrue();
     * that(varcmp('2', '12', SORT_NATURAL) < 0)->isTrue();
     *
     * // SORT_STRICT 定数が使える（下記はすべて宇宙船演算子を使うと 0 になる）
     * that(varcmp(['a' => 'A', 'b' => 'B'], ['b' => 'B', 'a' => 'A'], SORT_STRICT) < 0)->isTrue();
     * that(varcmp((object) ['a'], (object) ['a'], SORT_STRICT) < 0)->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $a 比較する値1
     * @param mixed $b 比較する値2
     * @param ?int $mode 比較モード（SORT_XXX）。省略すると型でよしなに選択
     * @param ?int $precision 小数比較の際の誤差桁
     * @return int 等しいなら 0、 $a のほうが大きいなら > 0、 $bのほうが大きいなら < 0
     */
    function varcmp($a, $b, $mode = null, $precision = null)
    {
        // 負数は逆順とみなす
        $reverse = 1;
        if ($mode < 0) {
            $reverse = -1;
            $mode = -$mode;
        }

        // null が来たらよしなにする（なるべく型に寄せるが SORT_REGULAR はキモいので避ける）
        if ($mode === null || $mode === SORT_FLAG_CASE) {
            if ((is_int($a) || is_float($a)) && (is_int($b) || is_float($b))) {
                $mode = SORT_NUMERIC;
            }
            elseif (is_string($a) && is_string($b)) {
                $mode = SORT_STRING | $mode; // SORT_FLAG_CASE が単品で来てるかもしれないので混ぜる
            }
        }

        $flag_case = $mode & SORT_FLAG_CASE;
        $mode = $mode & ~SORT_FLAG_CASE;

        if ($mode === SORT_NUMERIC) {
            $delta = $a - $b;
            if ($precision > 0 && abs($delta) < pow(10, -$precision)) {
                return 0;
            }
            return $reverse * (0 < $delta ? 1 : ($delta < 0 ? -1 : 0));
        }
        if ($mode === SORT_STRING) {
            if ($flag_case) {
                return $reverse * strcasecmp($a, $b);
            }
            return $reverse * strcmp($a, $b);
        }
        if ($mode === SORT_NATURAL) {
            if ($flag_case) {
                return $reverse * strnatcasecmp($a, $b);
            }
            return $reverse * strnatcmp($a, $b);
        }
        if ($mode === SORT_STRICT) {
            return $reverse * ($a === $b ? 0 : ($a > $b ? 1 : -1));
        }

        // for SORT_REGULAR
        return $reverse * ($a == $b ? 0 : ($a > $b ? 1 : -1));
    }
}
